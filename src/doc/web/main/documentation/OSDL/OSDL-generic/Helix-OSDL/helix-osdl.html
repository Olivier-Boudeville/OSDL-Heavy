<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">

<!--    This document is part of the OSDL project. 
        For any comment, please mail to olivier.boudeville@online.fr
-->

<!--    
        Creation date: 2003 April, 23.
        Author: Olivier Boudeville (olivier.boudeville@online.fr)
-->

<html lang="EN">
<head>
  <title>OSDL - Helix-OSDL</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="description" content="OSDL">
  <meta name="keywords" content="OSDL, library, video, game, quality, LGPL">
  <link rel="stylesheet" type="text/css" href="../../../../../common/css/OSDL.css">
  <link href="../../../../../images/OSDL-icon.png" rel="OSDL icon">
</head>

<body>

  <div class="banner">
    <p><em>General</em> <a href="../../../../../common/black.html" onclick="parent.toolbar.location=&#39;../../../../MainMenu.html&#39;">home page</a>
    <a href="../../../../Map.html">site map</a> <a href="mailto:olivier.boudeville@online.fr?subject=[OSDL]%20Helix-OSDL">mail us</a></p>
  </div><a name="_top_"></a> 


<h1>Helix-OSDL: efficient sound and music playback for the Nintendo DS</h1>

<h2>Overview</h2>

<p>
<b>Helix-OSDL</b> is a GPL library to be run from the ARM7 processor of the Nintendo DS so that <b>sound and music playback</b> can be performed, using notably the <a href="http://datatype.helixcommunity.org/mp3dec.html" target="_blank">Helix MP3 decoder</a>. MP3 is to be used mostly for musics, as for punctual sounds the Helix-OSDL PCM/IMA-ADPCM support is generally preferred.
</p>

<p>
Both of these audio content types are used here through <b>OSDL-specific audio file formats</b> (<code>*.osdl.sound</code> and <code>*.osdl.music</code>) for better fine-tuning and DS integration. These files can be generated by a set of OSDL tools available on the GNU/Linux platform.
</p>

<p>
Helix-OSDL offers a way of having rather high-quality music playback on the DS with various features (start, stop, fade-in, fade-out, etc.), while <b>loading as little as possible the main processor (ARM9)</b>. The otherwise often under-used ARM7 takes in charge the actual decoding on the MP3 stream, instead of being mostly idle. Musics are streamed from the ARM9 and transmitted still encoded to the ARM7.
</p>

<p>
Helix-OSDL is developed in pure C, not C++, to fit in the up to 96 kilobytes of RAM available for the ARM7 and to ease its integration in third-party code. A library is used to avoid being too intrusive in the user code, although one can rely directly on our ARM7 full-blown dedicated example executable.
</p>

<p>
The OSDL library has been ported to the DS, thus it offers C++ code for the ARM9 to communicate with the ARM7 Helix-OSDL code. It can be used as a high-level interface to Helix-OSDL, or as an example for alternate implementations, since of course Helix-OSDL can be used by other (non-OSDL) ARM9 code.
</p>


<p>
MP3-based encoding is used for musics, as RAW/WAV files would use a lot of place in the storage medium (ex: linker) and eat of lot of I/O bandwidth for playback. OggVorbis is not used (although we would prefer it to MP3) as its decoding apparently requires more CPU resources than MP3, even with the <a href="http://xiph.org/vorbis/" target="_blank">Tremor</a> implementation; it might be too demanding for the ARM7.
</p>


<p>
<a href="http://datatype.helixcommunity.org/mp3dec.html" target="_blank">Helix </a> is used because open-source lightweight MP3 decoders for low-end devices (with no floating-point hardware support and little memory) are not common, and because this one, being heavily optimized notably for the ARM processors, offers quite impressive performances (a <a href="http://forum.gbadev.org/viewtopic.php?t=13299" target="_blank">reported</a> 128 kbps 44.1 kHz joint stereo playback realtime on the ARM7, with only fixed point maths) and features (variable bitrate and joint stereo), while remaining tiny in memory.
</p>


<p>
The Helix <a href="https://helixcommunity.org/licenses/" target="_blank">licences</a>, commercial and open-source, are however a bit restrictive. As mentioned <a href="https://helixcommunity.org/projects/datatype/summary" target="_blank">here</a>, this software is available under the <em>RealNetworks Community Source License - RCSL 1.2</em>
and <em>RealNetworks Public Source License - RPSL 1.0</em> licenses. Although they are specified <a href="https://helixcommunity.org/licenses/" target="_blank">here</a> and partly discussed <a href="https://helixcommunity.org/licenses/open_source" target="_blank">here</a> and <a href="https://community.helixcommunity.org/2002/intro/getting-started-4" target="_blank">here</a>, they remain rather difficult to understand (the <a href="https://helixcommunity.org/licenses/licensing_faq" target="_blank">licensing FAQ</a> can help). They imply that Helix-OSDL is released under the GPL, and not the LGPL. One has to ensure that one's project is compatible with at least one Helix license before using Helix-OSDL.
</p>


<p>
A DS application being made of two distinct executables (one for each ARM), some sources consider that a different license may apply to each piece of software, if they are deemed loosely coupled here (ex: one can run without the other). With that interpretation, Helix and, therefore, Helix-OSDL could be used on the ARM7 with, say, a GPL license, while the ARM9 could run any type of application, including OSDL-based one and/or LGPL or GPL or proprietary closed software. See this <a href="http://www.gnu.org/licenses/gpl-faq.html#MereAggregation" target="_blank">FAQ</a> for a point of view. Are the DS FIFO a communication mechanism used for communication between two separate programs, like a UNIX pipe? Or should we consider the two parts as intimate enough and being combined actually into a larger program? 
</p>

<p>
Helix-OSDL is based upon our Ceylan-based <a href="http://ceylan.sourceforge.net/Ceylan-latest/Ceylan-userguide.html#ds-ipc" target="_blank">generic high-level IPC system</a>, to convey reliably audio commands between the ARMs.
</p>

<p>
See also our <a href="../../../misc/nintendo-DS/homebrew-guide/HomebrewForDS.html" target="_blank">homebrew guide for the DS</a>, including the discussions about <a href="../../../misc/nintendo-DS/homebrew-guide/HomebrewForDS.html#sound" target="_blank">sound</a> and <a href="../../../misc/nintendo-DS/homebrew-guide/HomebrewForDS.html#audio-transformations" target="_blank">audio transformations</a>.
</p>

<p>
Helix-OSDL can be tested directly: just download <a href="http://sourceforge.net/project/downloading.php?group_id=71354&filename=testHelix-OSDL.zip" target="_blank">testHelix-OSDL.zip</a>, which contains our music test player (<code>testOSDLMusic-0.5-release-patched.r4.nds</code>) and a sample music file (<code>test.osdl.music</code>), to be copied at the root of your DS card. This recording, a French Christmas song interpreted by a family, lasts for about 3 minutes, and is copyright free for non-commercial use. Its homepage is <a href="http://pironsyl.perso.cegetel.net/noelindex.htm" target="_blank">here</a>. Beware, the full test is quite long, as it performs multiple playbacks of the music.
</p>




<h2>Usage</h2>


<h3>Sounds</h3>

<p>
To perform sound playback with Helix-OSDL, <code>osdl.sound</code> files must be used and, thus, generated.
</p>



<h4>Step #1: generating the <code>osdl.sound</code> files</h4>

<p>
Such sound files can be created from WAVE files thanks to OSDL tools running on GNU/Linux, and can be internally encoded in raw PCM data (high quality, at the expense of size) or IMA-ADPCM (compact, but rather low quality). Two different tools for that are detailed next. 
</p>

<p>
In both cases, we tend to favor 22 050 kHz (good balance) 16-bit (necessary) PCM (IMA ADPCM sounds quite bad) mono (stereo not that interesting on the DS) samples of short durations (up to ten seconds). Longer samples may be considered as musics.
</p>



<h5>Using wavToOSDLSound.exe (first method)</h5>
<p>
This executable (see <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/wavToOSDLSound.cc?view=markup" target="_blank">wavToOSDLSound.cc</a>) converts a WAVE file into an osdl.sound file:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
Usage: ./wavToOSDLSound.exe [ -f frequency ] [ -m mode ] [ -b bitdepth ] X.wav
Converts a WAVE file (*.wav) into a .osdl.sound file by replacing the WAVE
header by an OSDL header filled with informations specified from the
command-line.

         -f: specifies the output sampling frequency, in Hz, ex: -f 22050 (the default)
         -m: specifies the output mode, mono or stereo, ex: -m mono (the default)
         -b: specifies the sample (PCM) bit depth, in bits, ex: -b 16 (the default). 
		 A bit depth of 4 corresponds by convention to the IMA ADPCM sample format.
		 
One may use the sox command-line tool to retrieve the relevant audio settings
for the source sound.

Ex: 'sox -V YourSound.wav -n' converts the sound and outputs its metadata 
that can be used to fill the next command line.
		
Then 'wavToOSDLSound.exe -f 44100 -m stereo -b 8 YourSound.wav' results in 
the creation of 'YourSound.osdl.sound'. 

Alternatively, use the wavToOSDLSound.sh script: 
'wavToOSDLSound.sh YourSound.wav' takes care of everything and results in
the YourSound.osdl.sound file.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
For example:
</p>

<p>

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
&gt;./wavToOSDLSound.exe -f 22050 -m mono -b 16 test.wav
Converting 'test.wav' into 'test.osdl.sound', using frequency 22050 Hz, 
mode mono (1), bit depth 16 (format 32784).

Generation of 'test.osdl.sound' succeeded!
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>


<h5>Using <code>wavToOSDLSound.sh</code> (second method, recommended)</h4>

<p>
This script (see <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/wavToOSDLSound.sh?view=markup" target="_blank">wavToOSDLSound.sh</a>)
is still more automated, as it guesses the sound settings, thus only the source WAVE file and, possibly, the target format (if wanting IMA-ADPCM instead of PCM) have to be specified:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
Usage: wavToOSDLSound.sh [-h|--help] [-i|--ima-adpcm] SOURCE_WAVE_FILE
Converts specified wave file into an OSDL sound counterpart.

  Example: wavToOSDLSound.sh hello.wav uses hello.wav to generate its
  hello.osdl.sound counterpart (needs sox and wavToOSDLSound.exe).
  
    -h/--help: displays this help
    -i/--ima-adpcm: encode the wave samples into IMA-ADPCM 
	(about four times smaller but with poorer quality) [uses ffmpeg]
	
  Note that the wave file can contain usual PCM samples or IMA ADPCM samples:
  both will be managed automatically by this tool and by the OSDL player 
  on the Nintendo DS.
  
  To generate an IMA ADPCM-encoded wave file, one should better use ffmpeg 
  or audacity than sox, as the data produced by the latter is incorrectly
  decoded by the DS.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
For example:
</p>

<p> 
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
./wavToOSDLSound.sh test.wav
    test.osdl.sound produced, ready to be used!
-rw------- 1 sye sye 860926 2008-02-08 18:21 test.osdl.sound
-rw-rw-r-- 1 sye sye 860962 2008-02-08 18:19 test.wav
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h4>Step #2: using the osdl.sound file in your application</h4>
<p>
Once generated, the OSDL sound file can be put on the DS storage, and from the ARM9 the <code>OSDL::Audio::Sound</code> constructor will load specified osdl.sound automatically thanks to the Ceylan libfat-based layer. Then the sound instance may be loaded/unloaded, played at will (hardware channels are managed internally by OSDL), etc., thanks to the corresponding methods offered by the <code>OSDL::Audio::Sound</code> class, whose API is defined in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/audio/OSDLSound.h?view=markup" target="_blank">OSDLSound.h</a>.
</p>

<p>
See <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/test/cross-tests/testOSDLSound.arm9.cc?view=markup" target="_blank">testOSDLSound.arm9.cc</a> for an example of sound management. 
</p>





<h3>Music</h3>

<p>
Exactly like sounds, OSDL music files have to be generated before playback, using various tools.
</p>

<h4>Step #1: from WAVE to MP3</h4>
<p>
When for example creating a game, your audio source is usually a high-quality uncompressed WAVE file. As osdl.music files are MP3-based, the first step is to encode this WAVE file into a MP3 one, using here preferably the encoder named <a href="http://lame.sourceforge.net/" target="_blank">LAME</a>. As described in our <a href="http://osdl.sourceforge.net/main/documentation/misc/nintendo-DS/homebrew-guide/HomebrewForDS.html#audio-transformations" target="_blank">homebrew guide</a>, the MP3 encoding must be heavily tuned for the DS, resource-wise. The proper encoding can be done automatically by the <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/wavToMP3ForDS.sh?view=markup" target="_blank">wavToMP3ForDS.sh</a> script: 

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
Usage: wavToMP3ForDS.sh [-h|--help] SOURCE_WAVE_FILE
Converts specified WAVE file into a mp3 file appropriate for playback on the DS.

  Example: 'wavToMP3ForDS.sh hello.wav' uses hello.wav to generate its 
  hello.mp3 counterpart (needs the LAME encoder).
    -h/--help: displays this help
	
  One may use the audacity tool to preprocess the wave sound beforehand
  (cleaning, volume adjustment, correct export in format, etc.).
  
  Running this script is often the first step of a process: once having a mp3,
  one usually plays it on the Nintendo DS thanks to the getMP3Settings tool
  (copy the generated mp3 file to the root of your removable DS card, 
  under the name 'test.mp3'), which will return an upper bound to the size 
  of encoded frames for this mp3.
  
  Then this value can be used with the mp3ToOSDLMusic.exe tool (using 
  the -u parameter) to finally produce an OSDL music file ready to be 
  played back by the OSDL-Helix engine on the DS, with reduced resource needs.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
For example (LAME audio details skipped):
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
 ./wavToMP3ForDS.sh test.wav
    Encoding test.wav into test.mp3 for DS playback.
LAME 3.97 32bits (http://www.mp3dev.org/)
CPU features: MMX (ASM used), SSE, SSE2
polyphase lowpass filter disabled
Encoding test.wav to test.mp3
Encoding as 22.05 kHz VBR(q=5) single-ch MPEG-2 Layer III (ca. 11.9x) qval=0

misc:

        scaling: 1
        ch0 (left) scaling: 0
        ch1 (right) scaling: 0
        filter type: 0
        quantization: xr^3/4
        huffman search: best (outside loop)
        experimental Y=1
        ...

stream format:

        MPEG-2.5 Layer 3
        1 channel - mono
        padding: all
        variable bitrate - VBR mtrh
        ...

psychoacoustic:
[..]

    Frame          |  CPU time/estim | REAL time/estim | play/CPU |    ETA
   751/751   (100%)|    0:00/    0:00|    0:00/    0:00|   67.648x|    0:00
  8 [182] ***********************************************************************************
 16 [  4] **
 24 [  7] ****
 32 [ 14] *******
 40 [ 61] ****************************
 48 [206] *********************************************************************************************
 56 [133] *************************************************************
 64 [ 67] *******************************
 80 [ 46] *********************
 96 [ 31] **************
-------------------------------------------------------------------------------------------------------
   kbps       mono %     long switch short %
   43.7      100.0        61.0  19.4  19.6
    test.mp3 produced, ready to be used!
-rw-rw-r-- 1 sye sye 106859 2008-02-08 19:04 test.mp3
-rw-rw-r-- 1 sye sye 860962 2008-02-08 18:19 test.wav
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
For musics, we deem the most balanced settings are 22 050 kHz (higher frequencies not really needed), 16-bit (8-bit offers a too low quality), mono (stereo usually not noticed by DS users), VBR (variable bitrates more efficient than constant ones), with an average bitrate lower than 80 kbps and a peak bitrate not greater than 96 kbps (to avoid too big frame size for our upper-bound).
</p>


<h4>Step #2: determining the MP3 frame size upper bound</h4>
<p>
Once having the MP3 file, to further optimize the DS playback, a value has to be specified to the osdl.music generator: the upper bound of the size of a MP3 frame of this music. Knowing it, the OSDL-Helix playback module will be able to minimize transfers of chunks of encoded data at runtime. But how one can determine this upper bound? By using an intermediate tool (last one, promise!), <code>getMP3Settings</code> (see <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/test/cross-tests/getMP3Settings.arm9.cc?view=markup" target="_blank">getMP3Settings.arm9.cc</a> and <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/test/cross-tests/getMP3Settings.arm7.c?view=markup" target="_blank">getMP3Settings.arm7.c</a>), which will run on the DS, perform the full playback of the MP3 (rename your mp3 to <code>test.mp3</code> and put it at the root of your DS card), and finally output its framesize upper bound (a value of 1940 bytes could be used as a default value, but the actual value is often far below, like 314, so using <code>getMP3Settings</code> should really be encouraged).
</p>



<h4>Step #3: converting the MP3 file into an osdl.music file</h4>
<p> 
The objective then is, knowing the upper bound, to convert the MP3 file into a proper osdl.music file, suitable for direct playback on the DS using OSDL and Helix-OSDL.
</p>

<p>
This should be done using the <code>mp3ToOSDLMusic.exe</code> tool (see <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/mp3ToOSDLMusic.cc?view=markup" target="_blank">mp3ToOSDLMusic.cc</a>).
</p>

<p>
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
Usage: mp3ToOSDLMusic.exe [ -f frequency ] [ -m mode ] [ -t {CBR|VBR} ] -u BYTE_COUNT X.mp3
Converts a .mp3 file into a .osdl.music file by appending a header filled with
informations specified from the command-line.

         -f: specifies the output sampling frequency, in Hz, ex: -f 22050 (the default)
         -m: specifies the output mode, mono or stereo, ex: -m mono (the default)
         -t: specifies the bitrate type, either constant bit rate (CBR) 
		 or variable bitrate (VBR) (the default)
         -u: specifies the upper bound of the size of an encoded mp3 frame 
		 in this music, in bytes.
One may use the wavToMP3ForDS.sh script, or directly the lame command-line tool,
to convert beforehand a .wav into a .mp3.

        Ex: 'lame YourLongMusic.wav --verbose -m m --vbr-new -V 5 -q 0 
		-B 96 -t --resample 22.05 YourLongMusic.mp3' converts the music.
		
Then 'mp3ToOSDLMusic.exe -f 22050 -m mono -t vbr -u 314 YourLongMusic.mp3'
results in the creation of 'YourLongMusic.osdl.music'.

The upper bound of the size of an encoded mp3 frame can be determined thanks 
to the getMP3Settings OSDL media tool. It runs on the DS, plays the mp3 
and, once done, displays that upper bound.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
For example:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
&gt; ./mp3ToOSDLMusic.exe -u 314 test.mp3
Converting 'test.mp3' into 'test.osdl.music', using frequency 22050 Hz, 
mode mono (1), bitrate 2, upper bound 314 bytes.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>



<h4>Step #4: using the osdl.music file in your application</h4>

<p> 
Exactly like with sounds, one just has to use the proper constructor (<code>OSDL::Audio::Music</code>, whose API is defined in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/audio/OSDLMusic.h?view=markup" target="_blank">OSDLMusic.h</a>) from the ARM9 to specify an osdl.music file on the DS card, and then this instance allows to playback this music, fade it in, etc.: <code>load/unload</code>, <code>play</code>, <code>playWithFadeIn</code>, <code>pause/unpause</code>, <code>stop</code>, <code>fadeIn/fadeOut</code>, etc. Note that only a subset of the OSDL Music API has been ported to the DS, other methods may throw an exception when called, with an appropriate error message.
</p>



<p>
See <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/test/cross-tests/testOSDLMusic.arm9.cc?view=markup" target="_blank">testOSDLMusic.arm9.cc</a> for an example of music management.
</p>

<p>
Note that only one music at a time will be played, on the hardware channel 0.
</p>


<h3>Other helper tools</h3>

<p>
Regarding <code>*.osdl.*</code> files, the <code>identifyOSDLFile.exe</code> executable (see <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/identifyOSDLFile.cc?view=markup" target="_blank">identifyOSDLFile.cc</a>), can be used to output their metadata, for example:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>			
&gt; ./identifyOSDLFile.exe test.osdl.sound
File 'test.osdl.sound', according to its tag, is a sound (PCM or IMA ADPCM).
  + Sampling frequency: 22050 Hz.
  + Sample format: little-endian signed 16-bit (native).
  + Channel format: mono.
  + Size of all samples: 217104 bytes.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

and

<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
			
<code><pre>			
&gt; ./identifyOSDLFile.exe test.osdl.music
File 'test.osdl.music', according to its tag, is a music (MP3).
  + Sampling frequency: 22050 Hz.
  + Channel format: mono.
  + Bitrate type: VBR (variable bitrate).
  + Upper bound of encoded frame size: 313 bytes.
  + Size of actual mp3 content: 17665 bytes.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>






<h2>Inner workings</h2>

<p>
The ARM9 is the only CPU able to access the storage media (the linker), at least when using the libfat, since this library cannot fit in the ARM7 memory. Thus the music has to be loaded from the ARM9.
</p>

<p>
The ARM7 is the only CPU able to access the sound hardware (mixer), so the last part of the audio pipeline has to be located in the ARM7. Consequently:
<ul>

	<li>the actual <b>decoding</b> has to be performed somewhere in-between, either on the ARM9 or, preferably, on the otherwise often idle ARM7, to unload as much as possible the ARM9</li>
	
	<li>both <b>processors</b> have to be synchronized to exchange commands and data, here we chose to use the most appropriate solution, the hardware FIFO with interrupt-based management (no polling for more efficiency). As some lengthy I/O operations should not be performed from interrupt handlers, FIFO interrupts just notify (by setting appropriate booleans) the ARM9 main loop about the need to perform some action, notably to load chunks of encoded data</li>
	
	<li>the actual <b>data streaming</b> thus occurs from the ARM9 (libfat) to the ARM7, either for direct playback (RAW sounds) or for Helix decoding (MP3 musics). Loaded data has to be shared between the ARMs, so it has to be allocated on the ARM9 side and in the non-cacheable address space (see our <a href="../../../misc/nintendo-DS/homebrew-guide/HomebrewForDS.html#ipc" target="_blank">IPC</a> section for general details, see below for more specific ones)</li>
		
</ul>

</p>

<p>
The following constraints made us design the solution that way:

<center>
    <img src="audio-pipeline.png" alt="Audio Pipeline"></img>
</center>

</p>

<p>
The ARM9 drives the high-level process: it decides when a given music must be played, paused, stopped, faded-out, etc. and the ARM7 performs the actual decoding. Thus the user program just has to send requests to the ARM7 implementation and process incoming ones. OSDL on the ARM9 offers as well a C++ layer that communicates appropriately with the ARM7 C implementation and allows to use directly higher-level constructs, such as: <code>Music::playWithFadeIn</code>.
</p>

<p>
If the playback is triggered by the ARM9, as soon as initiated it becomes entirely focused on the hard real time need of feeding the output PCM buffers with samples, on the ARM7 side. Based on a series of cascading timers, the ARM7 has to trigger double-buffered MP3 decoding and sends to the ARM9 requests to refill asynchronously another double buffer, this time for encoded data.
</p>

<p>
All I/O operations are performed outside of IRQ handlers, and the safest/most reliable solutions have been implemented (ex: regarding IRQ management or cache-aligned buffers on the ARM9). Smallest memory footprint (no intermediate buffer) and lightest memory transfers (per-music optimized end-of-buffer moves thanks to the frame size upper bound) are used. This allows the full implementation on the ARM7 to fit in 32-bit in its private memory, even with devkitARM versions more recent than the devkitARM-20 release.
</p>

<p>
On the ARM7, most of the generic code comes from Ceylan core:
<ul>
	
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/system/CeylanARM7Codes.h?view=log" target="_blank">CeylanARM7Codes.h</a> and <a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/system/CeylanARM7Codes.c?view=markup" target="_blank">CeylanARM7Codes.c</a> for the ARM7 status words</li>
	
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/system/CeylanFIFO.h?view=markup" target="_blank">CeylanFIFO.h</a> and <a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/system/CeylanFIFO.cc?view=markup" target="_blank">CeylanFIFO.cc</a> for the hardware FIFO reliable encapsulation</li>

    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/system/CeylanARM7Base.h?view=markup" target="_blank">CeylanARM7Base.h</a> and <a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/system/CeylanARM7Base.c?view=markup" target="_blank">CeylanARM7Base.c</a>, notably for the FIFO-based IPC system</li>

    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/system/CeylanIPCCommands.h?view=markup" target="_blank">CeylanIPCCommands.h</a> and <a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/system/CeylanIPCCommands.c?view=markup" target="_blank">CeylanIPCCommands.c</a> for the supported IPC commands</li>
	

<!--
    <li><a href="" target="_blank"></a></li>
-->

</ul>

</p>

<p>
Audio-specific code on the ARM7 is provided by the Helix-OSDL library, built on top of the Ceylan library:

<ul>

    <li><a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/audio/OSDLSound.h?view=markup" target="_blank">OSDLSound.h</a> and <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/audio/OSDLSound.cc?view=markup" target="_blank">OSDLSound.cc</a>, for the sound management on the ARM9</li>

    <li><a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/audio/OSDLMusic.h?view=markup" target="_blank">OSDLMusic.h</a> and <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/audio/OSDLMusic.cc?view=markup" target="_blank">OSDLMusic.cc</a>, for the music management on the ARM9</li>

    <li><a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/basic/OSDLCommandManager.h?view=markup" target="_blank">OSDLCommandManager.h</a> and <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/basic/OSDLCommandManager.cc?view=markup" target="_blank">OSDLCommandManager.cc</a> for the OSDL specialization of Ceylan FIFO for IPC, whose commands are defined in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/basic/OSDLIPCCommands.h?view=markup" target="_blank">OSDLIPCCommands.h</a> and additional status codes  in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/basic/OSDLARM7Codes.h?view=markup" target="_blank">OSDLARM7Codes.h</a></li>
	
    <li><a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/basic/OSDLARM7Base.h?view=markup" target="_blank">OSDLARM7Base.h</a> and <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/basic/OSDLARM7Base.c?view=markup" target="_blank">OSDLARM7Base.c</a> for the actual ARM7 audio code</li>
	
<!--
    <li><a href="" target="_blank"></a></li>
-->

</ul>

</p>


<h3>Building Helix</h3>

<p>
Sources and build files are available in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/audio/helix/" target="_blank">Helix-OSDL SVN</a>.
</p>

<p>
To build Helix, one should read first the <a href="https://helixcommunity.org/viewcvs/datatype/mp3/codec/fixpt/readme.txt?view=markup" target="_blank">readme.txt</a> file which gives useful explanations. 
</p>

<p>
Before using the sources, one must agree with at least one of the three <a href="https://helixcommunity.org/licenses/" target="_blank">licences</a>. Even though Helix can be obtained from 
<a href="https://helixcommunity.org/developers/get_connected_to_cvs/quickstart.html" target="_blank">CVS</a>, probably the more convenient method is to download the <a href="https://helixcommunity.org/developers/getting_started/httpdownload.html" target="_blank">zip archive</a> (ex: select the stable version for GNU/Linux). 
Helix in itself is located in the <code>datatype/mp3/codec/fixpt</code> directory. One can obtain the sources from their <a href="https://helixcommunity.org/viewcvs/datatype/mp3/codec/fixpt/" target="_blank">ViewCVS</a> as well.
</p>


<p>
Obviously we want an ARM build, not a x86 one. We target the 32-bit ARM mode, not the (16-bit) Thumb one, as it is a 32-bit codec. Real (RealNetworks) code is what we want here, as IPP (<code>Intel Integrated Performance Primitives</code>) is not expected to be available here. So the library should gather, as mentioned, <code>mp3dec.c + mp3tabs.c + real/*.c + real/arm/[files].s</code>
</p>



<h3>Using Helix</h3>


<p>
Helix being quite feature-rich, if targeting stereo output then joint-stereo should be preferred to simple stereo, as it takes advantages of the correlation between the two channels. Use the <code>-m j</code> option with LAME to generate appropriate audio data.
</p>

<p>
The MPEG-2.5 extension is not useful here, as apparently it targets still lower sampling frequencies (less than 12 kHz).
</p>

<p>
Variable bitrates, as opposed to constant ones, are supported by Helix and may be preferred too, so that the bitrate can vary according to the audio needs and thus be more efficient. Use the <code>--vbr-new -V quality</code> option with LAME, with quality between 0 and 9.
</p>

<p>
The 
<a href="https://helixcommunity.org/viewcvs/datatype/mp3/codec/fixpt/testwrap/main.c?view=markup" target="_blank">sources</a> of a test program using Helix should help using it correctly.
</p>



<h2>Sources</h2>

<p>
A lot of information about Helix can be found directly in its dedicated website, including:

<ul>

    <li>the Helix MP3 decoder <a href="https://datatype.helixcommunity.org/mp3dec.html" target="_blank">main page</a></li>
	
    <li>the Helix <a href="https://helixcommunity.org/viewcvs/datatype/mp3/codec/fixpt/readme.txt?view=markup" target="_blank">README</a></li>
	
    <li>the Helix <a href="https://helixcommunity.org/viewcvs/datatype/mp3/codec/fixpt/testwrap/main.c?view=markup" target="_blank">test example</a></li>
	
    <li>the Helix <a href="https://helixcommunity.org/viewcvs/datatype/mp3/codec/fixpt/LICENSE.txt?view=markup" target="_blank">LICENSE.txt</a> file</li>
	

<!--
    <li><a href="" target="_blank"></a></li>
-->

</ul>
</p>


<p>
Integration of Helix and various issues are discussed in following threads of the <a href="http://forum.gbadev.org" target="_blank">gbadev</a> forums (chronological order):

<ul>

    <li><a href="http://forum.gbadev.org/viewtopic.php?t=13007" target="_blank">Proper sound streaming implementation</a>, about sound streaming</li>

    <li><a href="http://forum.gbadev.org/viewtopic.php?t=13299" target="_blank"> Helix MP3 decoder</a>, about Helix build and performances</li>
 
    <li><a href="http://forum.gbadev.org/viewtopic.php?t=13430" target="_blank">FIFO handler library</a>, to synchronize the two ARMs</li>

    <li><a href="http://forum.gbadev.org/viewtopic.php?t=13448" target="_blank">mp3 playback examples (was: Problems using the helix mp3dec)</a>, about integration of Helix and numerous hints and tricks</li>

    <li><a href="http://forum.gbadev.org/viewtopic.php?t=14204" target="_blank"> Sound Streaming</a>, again about sound streaming</li>

    <li><a href="http://forum.gbadev.org/viewtopic.php?t=14222" target="_blank">Multiple timer interrupts and sound corruption</a>, about timer issues</li>

    <li><a href="http://forum.gbadev.org/viewtopic.php?t=14287" target="_blank">About MP3 Decoding...</a>, about streaming for Helix</li>
		
	

<!--
    <li><a href="" target="_blank"></a></li>
-->

</ul>
</p>

<p>
Some more information can be found in this PAlib thread: <a href="http://www.palib.info/forum/modules/newbb/viewtopic.php?topic_id=3428" target="_blank">How to use helix mp3 decoder with PAlib?</a>
</p>

<p>
Most of the work has been done by <b>ThomasS</b>, <b>DekuTree64</b>, <b>Noda</b>, <b>DragonMinded</b>, <b>tepples</b>,  <b>simonjhall</b>, <b>Lazy1</b>, many thanks to them for sharing their knowledge.
</p>

  
<h3>Please react!</h3>

<p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, or if you would like to contribute and help us, even a little bit, <a href="mailto:olivier.boudeville@online.fr?subject=[OSDL]%20Helix-OSDL">drop us a line</a> !</p>

<br>
<br>

<hr>

<center>
  [<a href="#_top_">Top</a>]
  <br>
  <br>
  <em>Last update: Sunday, April 5, 2009</em>
</center>

</body>
</html>
