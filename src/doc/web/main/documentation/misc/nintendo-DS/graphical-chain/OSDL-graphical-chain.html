<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">

<!--    This document is part of the OSDL project.
		For any question, send a mail to homebrew@esperide.com
-->
<!--    
        Creation date: Sunday, February 17, 2008.
        Author: Olivier Boudeville (homebrew@esperide.com)
        Version: 0.1
-->

<html lang="EN">
<head>
  <title>OSDL - Graphical rendering &amp; asset pipeline for the Nintendo DS</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="description" content="OSDL">
  <meta name="keywords" content="OSDL, Nintendo, DS, GBA, homebrew, graphics">
  <link rel="stylesheet" type="text/css" href="../../../../../common/css/OSDL.css">
  <link href="../../../../../images/OSDL-icon.png" rel="OSDL icon">
</head>

<body>
  
  <div class="banner">
  
    <p><em>General</em> <a href="../../../../../common/black.html" onclick="parent.toolbar.location='../../../../MainMenu.html'">home page</a>
    <a href="../../../../Map.html">site map</a> <a href="mailto:homebrew@esperide.com?subject=[OSDL]%20Graphical%20rendering%20for%20the%20DS">mail us</a></p>
	
  </div><a name="_top_"></a>
  

<h1>Graphical rendering &amp; asset pipeline for the Nintendo DS</h1>


<a name="toc"></a>
<center>
	<table summary="Table of content" style="border: none">
        <tr>
          <td>
		<!--
		       <a href="#"></a><br>
		-->

		   <div class="box">
		       <a href="#overview">Overview</a><br>
		       <a href="#design-choices">Design choices</a><br>
		       <a href="#technical-architecture">Technical architecture</a><br>
		       <a href="#in-world-rendering">In-world rendering</a><br>
		       <a href="#graphic-pipeline">Graphic pipeline</a><br>
		       <a href="#user-interface">User interface</a><br>
			   <a href="#tools">Tools used here</a><br>
		       <a href="#reiner">Some more informations about Reiner Tilesets</a>

          </td>
        </tr>
    </table>
</center>
<!--
<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>
  -->




<!-- ###################################################################### -->

  
<a name="overview"></a>
<h2>Overview</h2>
<p>
Our goal here is to describe a way of managing graphical rendering on the Nintendo DS that may be relevant for some types of games, notably a lightweight isometric engine suitable for RPG-like games.
</p>

<p>
This consists on:
<ul>

	<li><b>designing the proper rendering layer</b> on the DS</li>
	<li><b>setting up the corresponding tools</b> on the PC to generate the relevant assets</li>

<!--
	<li><b></b>: </li>
-->

</ul>
</p>

<p>
We based most of the technical choices on our <a href="../homebrew-guide/HomebrewForDS.html" target="_blank">guide to homebrew development for the Nintendo DS</a>.
</p>

<p>
Heavy preprocessing of images is to be performed before being able to render them efficiently from the DS, notably for sprites. So we had to gather a dedicated transformation toolchain for graphics. The various generic tools we tried would have implied too many limitations. We thus developped our own tools, which rely directly on our <a href="http://osdl.sourceforge.net" target="_blank">OSDL</a> library: beyond being used for realtime game engines, it proved to be very helpful to develop tools as well.
</p>

<p>
We are discussing here only about the graphical rendering of the underlying game world, which is to be managed by the <a href="../game-engine/OSDL-game-engine.html" target="_blank">game engine</a>. Audio content in general is not discussed here, see <a href="../../../OSDL/OSDL-generic/Helix-OSDL/helix-osdl.html" target="_blank">Helix-OSDL</a> instead.


</p>


<a name="design-choices"></a> 
<h2>Design choices</h2>

<p>
The game will use a lot of 2D assets, including many animated sprites from various sources, including converted versions from <a href="http://reinerstileset.4players.de/" target="_blank">Reiner's Tilesets</a>. </p>

<p>
Even if most sprites will be scaled down and some animation frames may be removed due to space constraint, one of the main challenges will be to keep a lower enough memory footprint so that the graphical content fits in the scarce memory resources of the DS.
</p>

<p>
This will involve using fully all the VRAM banks of the DS, but also using a double-layered level of cache, as these banks will not suffice: first level of cache will be the DS main RAM, second one the DS cartridge.
</p>




<!-- ###################################################################### -->


<a name="technical-architecture"></a>
<h2>Technical architecture</h2>

<h3>Screen roles</h3>
<p>
We plan to have one screen (the top one) of the DS dedicated to the <a href="#in-world-rendering">in-world rendering</a> (top-down isometric view), whereas the bottom one will display the game <a href="#user-interface">user interface</a> (stats, input device as mouse-like pointer or virtual keyboard, textual descriptions, close-up views, etc.).
</p>

<h3>Rendering Cores</h3>
<p>
In-world rendering being the most intensive task, the main 2D core will be devoted to it (so it will be associated to the top screen). Thus the user interface will rely on the sub core, on the bottom screen. No 3D rendering is planned.
</p>


<h3>VRAM banks</h3>

<p>
Based on the bank <a href="http://www.dev-scene.com/NDS/NDS_Tutorials_VramTable" target="_blank">abilities</a>, the in-game bank layout we chose is:
<center>
  <table border="1" summary="VRAM Memory Banks">
    <caption>VRAM Memory Banks (total: 656 kilobytes)</caption>

    <tr>
        <th>Bank name</th>
        <th>Bank size (in Kilobytes)</th>
        <th>Bank owner</th>
        <th>Intended role</th>
    </tr>

    <tr>
        <td>VRAM_A</td>
        <td>128</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_B</td>
        <td>128</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_C</td>
        <td>128</td>
		<td>Sub engine</td>
		<td>Background</td>
   </tr>

    <tr>
        <td>VRAM_D</td>
        <td>128</td>
		<td>Main engine</td>
		<td>Background</td>
   </tr>

    <tr>
        <td>VRAM_E</td>
        <td>64</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_F</td>
        <td>16</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_G</td>
        <td>16</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_H</td>
        <td>32</td>
		<td>Sub engine</td>
		<td>Background</td>
   </tr>

    <tr>
        <td>VRAM_I</td>
        <td>16</td>
		<td>Main engine</td>
		<td>Extended palettes</td>
   </tr>

  </table>
</center>
</p>

<p>
Main reasons for that is that we want to dedicate as much as possible memory for the main core, notably to hold as much sprites as possible. Bank C is the only one of the four main banks to be able to hold the sub background, D cannot contain main sprite graphics, etc. The sub engine does not need any sprite.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>





<!-- ###################################################################### -->


<a name="in-world-rendering"></a> 
<h2>In-world rendering</h2>

<p>
The game scenes will be made of a static background for environment (grounds, stairs, walls, non-interactive elements, i.e. non-breakable non-movable) on top of which several layers of elements will exist (characters, monsters, furnitures, doors, carpets, objects, etc.).
</p>

<p>
Static backgrounds will be stored in background memory, whereas all other elements will be sprites.
</p>


<h3>Backgrounds</h3>
<p>
These tile-based (not framebuffer-based) static elements are not expected here to be scaled, shared or rotated, unless for some special effects. Thus text backgrounds will be mostly used. We prefer relying on the 8-bit color mode (256 colors), as rendering might be a bit poor with 4-bit color mode (16 colors).
</p>





<h3>Sprites</h3>



<a name="sprite-colors"></a>
<h4>Sprite color modes</h4>

<p>
There is no direct-color mode for sprites: a palette has to be used.
</p>


<h5>Palette depth &amp; number</h5>


<p>
Among the <a href="http://osdl.sourceforge.net/main/documentation/misc/nintendo-DS/HomebrewForDS.html#sprite-color" target="_blank">available sprite color schemes</a>, the mode usually chosen for games is the one with up to 16 palettes, each of up to 256 colors. It is a good trade-off indeed, better than using 16 palettes of 16 colors for example.
</p>



<h5>Master palette</h5>

<p>
Most implementations may cope with one general-purpose palette for all sprites (using an appropriate <a href="http://en.wikipedia.org/wiki/List_of_monochrome_and_RGB_palettes#15-bit_RGB" target="_blank">master palette</a>), whereas more complex ones could rely on multiple palettes and associate to a given set of sprites (usually, animated characters) a particular palette. The increased color fidelity might not be worth the trouble of generating a set of palettes and choosing for each sprite the most appropriate palette.
</p>

<p>
We keep in mind that a lot of our sprites will come from the aforementioned Reiner's Tilesets. If we take <a href="http://reinerstileset.4players.de/T_swordstan_shield.zip" target="_blank">Swordstan</a> as an example (most probably our main character, as having multiple animations with multiple outside appearances), the source image (BMP in 24 Bit TrueColor), could be (taken from <code>swordstan shield 96x  bitmaps/attack se0000.bmp</code>) :
<center>
    <img src="swordstan-original.png" alt="Original image"></img>
</center>
</p>

<p>
The same image (here in PNG) with a 256-color <em>dedicated</em> optimal palette (i.e. all its colors have been chosen specifically for this image) looks almost exactly the same:
<center>
    <img src="swordstan-optimal-palette.png" alt="With 256-color optimal palette"></img>
</center>
</p>

<p>
However we have to rely on a general-purpose palette here, that will be shared by <em>all</em> our sprites. As index #0 is reserved for transparency (colorkey), there are 255 colors to be chosen, in [1,255]. 
</p>



<h5>Generation of a logical master palette</h5>

<p>
We chose to create programmatically our own shared (master) palette, for a better control. This palette aims at representing any bitmap image (as opposed to a palette made for a specific set of graphics) with as little color error as possible, knowing that we will have thousands of varied frames that will have to be automatically color-reduced against it.
</p>

<p>
The base of this palette is a 240-color <a href="http://en.wikipedia.org/wiki/List_of_software_palettes#6-8-5_levels_RGB" target="_blank">6-8-5</a> palette: for each of the 6 levels of red regularly distributed in the range of this color component, there are 8 levels of green, and for each of these green levels there are 5 levels of blue. Therefore <code>6*8*5 = 240</code> different colors are listed. Component ranges have been chosen in function of the sensibility of the normal human eye to every primary color.
</p>

<p>
Out of the <code>255-240 = 15</code> remaining colors, 8 are used for pure greys (which were lacking from the base palette). The 7 last colors have been specifically selected in frames from various characters (notably Stan), to match them more closely, regarding flesh, hair, etc.
</p>



<h5>Generation of the corresponding actual master palettes</h5>


<p>
We defined two kinds of file formats for actual palettes: a high-level one, the <code>osdl.palette</code> generic format, and a DS-specific one, the <code>pal</code> format.
</p>



<h6>The <code>osdl.palette</code> format</h6>

<p>
With this format, also known as unencoded format, a palette is made of a header, storing:
<ol>

	<li>the OSDL tag identifying palettes (<code>PaletteTag</code>)</li>
	
	<li>in next byte, the colorkey indicator: 1 if a colorkey is defined, 0 otherwise</li>
	
	<li>if there is a color key, in next 16 bits the index of the color key is specified (otherwise the header contains only the first indicator byte)</li>

<!--
	<li><b></b>: </li>
-->
</ol>

After the header, the content of the palette itself is stored, with 8 bits per color component, in RGB order (thus 24 bits per color, and no alpha coordinate stored). The extension of files respecting this format is preferably
<em>.osdl.palette</em>.
</p>



<h6>The <code>pal</code> format</h6>

<p>
With this encoded format, quantized colors will be written, i.e. each color definition will be packed into 16 bits only (first bit set to 1, then 5 bits per quantized color component, in BGR order). The fact that a given index corresponds to a colorkey will not be stored in this encoded format, as a colorkey is expected to be always present, and set at palette index #0.
</p>

<p>
Therefore an actual palette describing <code>n</code> colors can be a simple file (ex: <code>myPalette.pal</code>) containing <code>n</code> 16-bit encoded colors (thus the file occupies <code>2.n</code> bytes). As colors will have to respect the <code>x555</code> BGR format, there will be only 5 bits for each color component, each component is thus quantized in <code>[0,31]</code>.
</p>

<p>
This encoded format is directly usable by the Nintendo GBA and DS consoles. The extension of files respecting this format is preferably <code>.pal</code>.
</p>


<h5>Results &amp; by-products of the palette generation</h5>

<p>
We had chosen initially to generate our shared (master) palette with a python script we called <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/scripts/python/generate_master_palette.py?view=markup" target="_blank">generate_master_palette.py</a>. As multiple palettes and multiple palette formats have to be supported, we had to develop a more complex program, <code>generateMasterPalette.exe</code>, whose source is <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/video/animation-management/generateMasterPalette.cc?view=markup" target="_blank">generateMasterPalette.cc</a> and which relies heavily on OSDL. The program generates three versions of this logical master palette, each saved according to both palette formats (<code>.osdl.palette/.pal</code>).
</p>

<p>
Indeed, once a base master palette has been defined, it has to be transformed for various needs. First one is to generate from the palette a 256-color panel that represents it. It is done thanks a Makefile (see <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/video/animation-management/Makefile.am?view=markup" target="_blank">Makefile.am</a>): <code>make master-palette-original.png</code> generates the corresponding panel:
<center>
    <img src="master-palette-original.png" alt="Original Palette Image"></img>
</center>

</p>

<p>
We can clearly see, from top-left to bottom-right, the magenta color key at first index, then the full 240-color gradient, then the set of grey colors, then the various hand-picked colors: three blue colors and some flesh-colored ones.
</p>

<p>
We can generate as well the same palette, but quantized like it would be when encoded in <code>.pal</code> format: each color component is scaled to the only 32 levels already mentioned, instead of the 256 levels of the original palette. The result, <code>master-palette-quantized.png</code>, looks however very similar to the original palette:
<center>
    <img src="master-palette-quantized.png" alt="Quantized Palette Image"></img>
</center>
</p>

<p>
Last generated palette starts too from the original one, but performs a gamma-correction on it before quantizing it. The reason for this is that the final output device, the DS screen, displays darker colors than requested. We thus have to pre-correct these colors by selecting lighter colors on purpose.
</p>

<p>
This transformation is called <a href="http://en.wikipedia.org/wiki/Gamma_correction" target="_blank">gamma-correction</a>, each normalized color component is to be set at the power <code>1/gamma</code> before being denormalized.
</p>

<p>
We retained a gamma of 2.3 for the average DS screen (intermediate way between DS Fat and DS Lite, see also <a href="http://forum.gbadev.org/viewtopic.php?t=6484" target="_blank">this discussion</a>).
</p>
	

<p>
We apply the gamma-correction to the original master palette as well, to gain a better accuracy when the color-reduction of the gamma-corrected images will take place. The final quantization of this palette adds to this gamma-correction the effect of the <code>.pal</code> encoding. As expected, this palette looks brighter than the original :
<center>
    <img src="master-palette-quantized-gamma-corrected.png" alt="Gamma-corrected Quantized Palette Image"></img>
</center>
</p>



<h5>Color-reduction of images</h5>

<p>
In the process of frame conversion (which is implemented by <code>pngToOSDLFrame.exe</code>, whose source is <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/video/animation-management/pngToOSDLFrame.cc?view=markup" target="_blank">pngToOSDLFrame.cc</a>), one operation is to color-reduce an input frame (with full colors) to obtain the same frame, but using this time the master palette we discussed.
</p>

<p>
To do so, each pixel of the input image is matched against all the colors of the master palette. A distance in RGB colorspace between this pixel color and each palette color is computed, based on a <a href="http://www.compuphase.com/cmetric.htm" target="_blank">combination of two weighted Euclidean distance functions</a>. The closest palette color is then chosen for the color-reduced image.
</p>

<p>
This is implemented by the <code>OSDL::Video::Palette::GetDistance</code> method, declared in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/video/OSDLPalette.h?view=markup" target="_blank">OSDLPalette.h</a> and defined in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/video/OSDLPalette.cc?view=markup" target="_blank">OSDLPalette.cc</a>. Note that the colorkey is skipped when scanning the master palette, otherwise the color-reduction algorithm could incorrectly use that color to approximate colors from the input image.
</p>


<p>
Now we can compare in a row:
<ol>

	<li>the original test image with full colors</li>
	<li>the one transformed to match the original 256-color master palette</li>
	<li>then the one using the quantized master palette</li>
	<li>then one using the quantized gamma-corrected palette (on a PC the latter should look too bright)</li>
	<li>then the original image transformed to match the original master palette with colorkey management (detection and setting) enabled</li>

<!--
	<li><b></b>: </li>
-->
</ol>
<center>
	<img src="swordstan-original.png" alt="Original image"></img>
	<img src="swordstan-master-original.png" alt="With original palette"></img>
	<img src="swordstan-master-quantized.png" alt="With quantized palette"></img>
	<img src="swordstan-master-gamma-corrected.png" alt="With quantized gamma-corrected palette"></img>
	<img src="swordstan-original-colorkeyed.png" alt="With colorkey managed"></img>
</center>
</p>

<p>
We disabled for the first four tests the colorkey transformation, and for the mapping to the gamma-corrected palette the input image was itself gamma-corrected beforehand, as it ought to be.
</p>


<p>
Finally the result seems very good indeed, colors are well preserved in non gamma-corrected images. Note that the colorkey changed a bit in each image, notably due to the quantization and to the gamma-correction, but it did not trouble its management in last image.	
</p>





<a name="sprite-size"></a>
<h4>Sprite sizes</h4>
<p>
Here is a screenshot of our <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/test/cross-tests/testOSDLVideoFramebuffer.arm9.cc?view=markup" target="_blank">testOSDLVideoFramebuffer.exe</a> test program taken with the NO$GBA emulator:

<center>
    <img src="sprite-sizes.png" alt="Sprite sizes"></img>
</center>

</p>

<p>
It allows to better figure out the <a href="http://osdl.sourceforge.net/main/documentation/misc/nintendo-DS/HomebrewForDS.html#sprite-size" target="_blank">available sprite sizes</a>: yellow is for height of 8 pixels, white for 16, blue of 32 and cyan for 64. 64x64 is the maximum size of a sprite. We deemed the most appropriate size of a character is in general the third blue shape, the 32x32 square: with its 4x4=16 tiles, its memory footprint should be bearable, and, compared to the rest of the screen, there is enough room to display the environment of the character (not too big, not too small).
</p>

<p>
Using Swordstan again as an example, knowing that Reiner's Tilesets offer bigger frames, the source image could be:
<center>
    <img src="swordstan-original.png" alt="Original image"></img>
</center>
This is 96x96. If we reduced the original directly to 32x32, it would result in:
<center>
    <img src="swordstan-direct-32x32.png" alt="Reduced image"></img>
</center>
which is too small. Instead if we first crop the frame (the actual original content could fit in a 75x85 rectangle):
<center>
    <img src="swordstan-cropped-original.png" alt="Original Cropped Image"></img>
</center>
then we reduce it to 20x32 (preserving the ratio), we have:
<center>
    <img src="swordstan-cropped-32.png" alt="Image"></img>
</center>
which is better.
</p>

<p>
Resizing is preferably performed thanks to the Lanczos filter: <img src="swordstan-IM-Lanczos.png"></img>, resulting in sharper images than (bi)linear: <img src="swordstan-IM-Bilinear.png"></img> or (bi)cubic: <img src="swordstan-IM-Bicubic.png"></img>
</p>

<p>
These resized images have been obtained thanks to <a href="http://www.imagemagick.org" target="_blank">ImageMagick</a> with following commands:
<ul>

	<li><b>Lanczos</b>: <code>convert swordstan-original.png -filter Lanczos -resize 50x50 swordstan-IM-Lanczos.png</code></li>
	
	<li><b>Linear</b>: <code>convert swordstan-original.png -filter triangle  -resize 50x50 swordstan-IM-Bilinear.png</code></li>
	
	<li><b>Cubic</b>: <code>convert swordstan-original.png -filter Cubic  -resize 50x50 swordstan-IM-Bicubic.png</code></li>

<!--
	<li><b></b>: <code></code></li>
-->

</ul>

</p>


<a name="sprite-tiling"></a>

<h4>Sprite tiling</h4>

<p>
Once we have an image ready for animation (notably scaled-down, color-reduced gamma-corrected, etc.), we have to prepare it specifically so that it can be rendered directly by the Nintendo DS, whose 2D engines are tile-based.  
</p>

<p>
First step is to extract the actual content of the frame from the original one: using a similar process as the one described <a href="http://reinerstileset.4players.de/readmeE.html#g" target="_blank">here</a> by Reiner, the creator of these tilesets, we want to get rid of all the useless sprite borders, while still being able to re-center the trimmed frame relatively to the other frames of the animation.
</p>

<p>
To do so, first we find the smallest upright rectangle which encloses the frame content, colorkey excluded:
<center>
    <img src="swordstan-content-extracted.png" alt="Trimmed frame"></img>
</center>
We want to manage the inside of the yellow rectangle as a DS sprite.
</p>

<p>
Our home-made rendering engine will have to render a given frame (whose original version is shown here as a magenta rectangle) centered at a given screen location <code>[x;y]</code> (expressed in pixels) corresponding here to the character position, thus the frame will have to store an offset (signed) vector <code>[x_offset;y_offset])</code> (shown as the red arrow) so that, when the trimmed-down sprite (shown here as a gold rectangle) will be rendered from its upper-left corner at <code>[x+x_offset;y+y_offset])</code> it will be correctly be re-centered:
<center>
    <img src="frame-offset.png" alt="Frame offset"></img>
</center>
</p>

<p>
The offset vector corresponds simply to the coordinates of the upper-left corner of the trimmed rectangle (<code>trimmedRect</code>, whose coordinates are initially defined relatively to the upper-left corner of the original rectangle) expressed relatively to the center of the original frame (<code>frame</code>):
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
x_offset = trimmedRect.getUpperLeftAbscissa() - ( frame.getWidth() / 2 )
y_offset = trimmedRect.getUpperLeftOrdinate() - ( frame.getHeight() / 2 )
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
Thus each frame file will store <code>x_offset</code> and <code>y_offset</code> in its metadata.
</p>

<p>
Then we have to prepare the tiling of the trimmed content. It has to be copied to an image of its own, whose size will:
<ol>

	<li>be aligned to next multiple of 8 pixels (abscissa-wise and ordinate-wise), since the tiles will be 8x8</li>

	<li>have to correspond to one of the <a href="../homebrew-guide/HomebrewForDS.html#sprite-size" target="_blank">allowed sprite shapes</a>, as all tile layouts are not permitted</li>

<!--
	<li><b></b>: </li>
-->
</ol>

In our case, the actual content of the frame character (not scaled down here) is <code>39x62</code>, it leads our algorithm to select, as smallest enclosing shape, the <code>64x64</code> one:

<center>
    <img src="frame-tiled.png" alt="Frame tiled"></img>
</center>

We can see on the right of the frame full tiles being unused (filled only with the colorkey). These special tiles will not be duplicated in a given frame or even between frames: only one copy of these full-colorkey tiles will be maintained in tile list, to save some memory.
</p>



<a name="sprite-animation"></a>
<h4>Sprite animations</h4>
<p>
Let's take the character that is most probably the most complex one that will have to render: Stan.
</p>


<h5>Outside looks for a given character</h5>
<p>
First of all Stan has 8 different outside looks, sorted roughly according to the order in which they might appear in a story (example images are in low quality):
<ol>
<!--
	<li><b></b> : </li>
-->

	<li><b>Unarmed</b> Stan (<a href="http://reinerstileset.4players.de/Tstanunarmed.zip" target="_blank">stanunarmed</a>): 
<center>
    <img src="Stan-unarmed.png" alt="Unarmed"></img>
</center>
</li>

	<li>Stan with <b>a club</b> (<a href="http://reinerstileset.4players.de/Tclubstan.zip" target="_blank">clubstan</a>): 
<center>
    <img src="Stan-club.png" alt="Club"></img>
</center>
</li>

	<li>Stan with <b>a sword (and no shield)</b> (<a href="http://reinerstileset.4players.de/Tswordstan.zip" target="_blank">swordstan</a>)
<center>
    <img src="Stan-sword.png" alt="Sword"></img>
</center>
</li>

	<li>Stan with <b>a bow</b> (<a href="http:///http://reinerstileset.4players.de/T_bowstan.zip" target="_blank">bowstan</a>): 
<center>
    <img src="Stan-bow.png" alt="Bow"></img>
</center>
</li>

	<li>Stan with <b>an axe (and no shield)</b> (<a href="http://reinerstileset.4players.de/Taxestan.zip" target="_blank">axestan</a>): 
<center>
    <img src="Stan-axe.png" alt="Axe"></img>
</center>
</li>

	<li>Stan with <b>a sword and a shield</b> (<a href="http://reinerstileset.4players.de/T_swordstan_shield.zip" target="_blank">swordstan shield</a>)
<center>
    <img src="Stan-sword-shield.png" alt="Sword and Shield"></img>
</center>
</li>

	<li>Stan with <b>an axe and a shield</b> (<a href="http://reinerstileset.4players.de/T_axestan_shield.zip" target="_blank">axestan shield</a>): 
<center>
    <img src="Stan-axe-shield.png" alt="Axe and Shield"></img>
</center>
</li>

	<li>Stan with <b>a staff</b> (<a href="http://reinerstileset.4players.de/Tstaffstan%20.zip" target="_blank">staffstan</a>): 
<center>
    <img src="Stan-staff.png" alt="Staff"></img>
</center>
</li>

</ol>

</p>


<h5>Attitudes</h5>
<p>
To each of these different outside looks correspond a set of attitudes (behaviours in action). Different looks have often different sets of attitudes. 
</p>

<p>
For example, the unarmed Stan can:
<ul>

	<li>be still</li>
	<li>walk</li>
	<li>run</li>
	<li>attack (high kick)</li>
	<li>tip over (fall on the ground)</li>
	<li>been hit by a blow</li>
	<li>talk</li>
	<li>knit (most probably after having be idle for too long)</li>


<!--
	<li></li>
-->

</ul>
whereas Stan with a sword and a shield cannot knit, Stan with a staff has two attacks (regular and magical one), etc.
</p>


<h5>Directions</h5>
<p>
For each attitude, eight directions have always to be taken into account : character facing north, south, west, east, and the four related diagonals.
</p>

<p>
As characters are usually asymmetric, one cannot deduce for example eastward animations from westward ones (showing the character rotate clockwise):
<center>
    <img src="staffstan-north.png" alt="North"></img>
    <img src="staffstan-north-east.png" alt="North-East"></img>
    <img src="staffstan-east.png" alt="East"></img>
    <img src="staffstan-south-east.png" alt="South-East"></img>
    <img src="staffstan-south.png" alt="South"></img>
    <img src="staffstan-south-west.png" alt="South-West"></img>
    <img src="staffstan-west.png" alt="West"></img>
    <img src="staffstan-north-west.png" alt="North-West"></img>
</center>
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<h5>Frames</h5>
<p>
Finally, for each direction a given character attitude can be decomposed into a series of frames.
</p>

<p>
For example a Stan with sword and shield walking eastward uses following 8 frames in a cycle:
<center>
    <img src="swordstanshield-w-e-0.png" alt="0"></img>
    <img src="swordstanshield-w-e-1.png" alt="1"></img>
    <img src="swordstanshield-w-e-2.png" alt="2"></img>
    <img src="swordstanshield-w-e-3.png" alt="3"></img>
    <img src="swordstanshield-w-e-4.png" alt="4"></img>
    <img src="swordstanshield-w-e-5.png" alt="5"></img>
    <img src="swordstanshield-w-e-6.png" alt="6"></img>
    <img src="swordstanshield-w-e-7.png" alt="7"></img>
</center>

</p>

<p>
The number of frames depends on the attitude, but not on the direction: talking uses 7 frames, whereas walking 8.
</p>


<h5>Synthesis about animations</h5>

<p>
Animations must be rendered for various game elements: characters (player character(s), NPC, monsters, etc.), special effects (explosions, fountains, etc.), animated objects (drawing bridge, door, etc.).
</p>

<p>
A given element (say, a character) can have multiple outside looks (unarmed, or with different weapons, clothing, injuries, etc.).
</p>

<p>
For a given outside look, various attitudes might be available (walking, running, fighting, etc.).
</p>

<p>
An attitude has usually to be defined according to 8 directions.
</p>

<p>
For each direction, a number of frames makes the effective animation.
</p>

<p>
Thus one has to plan <code>NanimatedElements x Nlooks x Nattitudes x Ndirections x Nframes</code>. Most games, just counting the characters (friend, foe, monsters, etc.), have to have at least a dozen of them.
</p>

<p>
Considering the worst case, the main character Stan (who is the most detailed one), we count roughly <code>8 looks x 7 attitudes on average x 8 directions x 7 frames on average = 3136</code> frames. This is quite huge.
</p>

<p>
Considering the average 27-kilobyte original image might be trimmed and reduced for the DS to 1 kilobyte (1024 = 32x32 pixels, as discussed in the <a href="#sprite-size">sprite size section</a> and 8 bits per pixel, as discussed in the <a href="#sprite-colors">sprite color section</a>), the footprint might be, only for the characters, roughly equal to <code>12 characters x 3136 frames x 1024 bytes = 36 megabytes</code>. We chose not to remove frames from animations, as fluidity is important. Moreover it would be a shame not to take advantage of assets of such quality.
</p>

<p>
Compared to the overall 656 kilobytes of VRAM memory, to the 4 megabytes of RAM available for code, sounds, other graphical elements, and to the up to 128 megabytes of storage provided by a commercial cartridge, this is a challenge that may be met if using appropriate streaming and caching.
</p>



<!-- ###################################################################### -->

<a name="graphic-pipeline"></a> 
<h2>Graphic pipeline</h2>
<p>
After having taken into account all previous constraints (size, formats, colors, etc.), we chose the following process, that should led from the raw assets (coming for Reiner or other sources) to the precomputed content ready and optimized for the DS.
</p>

<h3>Step A: determining the target palette</h3>

<p>

	<ol>
	
		<li><b>choice</b> of the target DS palette, a master palette shared by most if not all animations, thus made so that all colors possibly used can be approximated with minimal mean error. Maybe later: creation of a palette dedicated to a given animated object, instead of a global palette
		</li>

		<li><b>gamma correction</b> of this palette, according to the gamut of DS screens
		</li>

	</ol>

</p>


<h3>Step B: transformation of a given animated object</h3>

<p>
First step: <b>per-animated object content sorting</b>, to create a frame hierarchy based on: outside looks, then attitudes, then directions, then ordered frames.
</p>


<p>
Then, for each frame:

	<ol>

		<li><b>resizing</b>, from original size to target DS planned size, based on a global and a per-asset ratio, determined so that the resized sprite complies with the in-game chosen scale
		</li>
	
		<li><b>color best-effort quantification</b>, from the original colors of the frame (per-pixel or indexed) to the optimal mapping according to the aforementioned target DS palette, with color key set for the sprite borders
		</li>

		<li><b>cropping</b>, to determine the vector offset (hot-spot) to recenter the resulting sprite into the frame stream, and to determine the smallest rectangle enclosing the actual frame content. For the generation of backgrounds, as tiles cannot be positioned on a per-pixel basis, a specific tile-aligned cropping is to be performed
		</li>

		<li><b>tiling</b>, to cut the sprite into (8x8 here) tiles, with padding so that the corresponding tile map matches the smallest possible shape of DS sprites
		</li>

		<li><b>meta-tiling</b> (optional), to support bigger sprites or to use more optimal sprite shapes
		</li>

		<li><b>RLE encoding</b> (optional), to save some space in the storage media with repeated colorkeyed pixels
		</li>
			
		<li><b>generation of the frame file</b> (see below)
		</li>
			
	</ol>

</p>

<p>
Finally, creation of:
<ol>

<!--
	<li><b></b> : </li>
-->

	<li>a <b>per-frame file</b>: for a given animated object, outside look, attitude, direction and animation step, it stores a given frame, with a somewhat self-describing filename (see naming conventions below). The file contains an header, specifying the frame metadata (notably the offset vector, the size and type of the frame map, the reference of the palette), and then the ordered set of tiles
	</li>
	
	<li>a <b>per-direction file</b>: for a given animated object, outside look, attitude and direction, stores the corresponding series of frames. The file contains an header, specifying the per-direction animation metadata (notably the number of frames involved, and their offset in this file), and then the ordered series of frames. Such a file is made from a generated header followed by the concatenated per-frame files
	</li>

	<li>a <b>per-attitude file</b>: for a given animated object, outside look and attitude, stores the corresponding directions (generally, 8). The file contains an header, specifying the attitude metadata (notably the number directions, and their offset in this file, but also any sound that should be output unconditionally during this animation), and then the associate set of per-direction files
	</li>

	<li>a <b>per-outside look file</b>: for a given animated object and outside look, stores the corresponding attitudes. The file contains an header, specifying the outside look metadata (notably the number of attitudes, their identifier and their offset in this file), and then the associated set of per-attitude files
	</li>
	
	<li>a <b>per-animated object file</b>: for a given animated object , stores the corresponding outside looks. The file contains an header, specifying the  metadata of the animated object (notably the number of outside looks, their identifier and their offset in this file), and then the associated set of per-outside look files
	</li>
		
</ol>




<h3>Naming conventions</h3>

<p>
To avoid to store too many informations in index files, filenames should respect the following conventions, so that they can be deduced rather than stored in an associative map.
</p>

<p>
The filename for a <b>frame</b> is made of a set of alphanumerical fields and a suffix: <code>F1-F2-F3-F4-F5.osdl.frame</code>.
</p>

<p>
Fields are:

<ol>
<!--
	<li><b></b> : </li>
-->
	<li><b>animated object identifier</b> (F1)</li>

	<li><b>outside look identifier</b> (F2)</li>

	<li><b>attitude identifier</b> (F3)</li>

	<li><b>direction identifier</b> (F4)</li>

	<li><b>frame identifier</b> (F5)</li>
	
</ol>
</p>

<p>
A given field is not specific to the previous one. For example, the outside look (F2) <code>ArmedWithASword</code> may apply to multiple characters (F1) : Stan, but also all characters whose outside look can be described as "<code>ArmedWithASword</code>".
</p>

<p>
Each field is described by a look-up associative table (identifier repository), a key being a human-friendly unique symbol (ex: <code>ArmedWithASword</code>), each value being the numerical identifier of this key (positive integer starting at 1, ex: <code>27</code>), to be interpreted in the context of the type they are associated with (here it is an outside look, we may have for example an attitude identifier of <code>27</code>, which would be totally unrelated to the previous <code>27</code>).
</p>

<p>
The table layout is a set of ASCII lines, each line specifying a key/value pair, the key being made of one word in CamelCase, the value being deduced from of the number of the line in the file. Thus, if the <code>NorthEast</code> key is at line 2, <code>NorthEast  = 2</code>. Keys are sorted in alphabetical order (the one of the <code>sort</code> command).
</p>

<p>
The repository of:
<ul>

	<li>animated object identifiers (F1) is defined in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/video/asset-repository/animated-object-identifiers.txt?view=markup" target="_blank">animated-object-identifiers.txt</a></li>
	
	<li>outside look identifiers (F2) is defined in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/video/asset-repository/outside-looks-identifiers.txt?view=markup" target="_blank">outside-look-identifiers.txt</a></li>
	
	<li>attitude identifiers (F3) is defined in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/video/asset-repository/attitude-identifiers.txt?view=markup" target="_blank">attitude-identifiers.txt</a></li>
	
	<li>direction identifiers (F4) is defined in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/video/asset-repository/direction-identifiers.txt?view=markup" target="_blank">direction-identifiers.txt</a>. It is composed of the 8 main directions</li>

<!--
	<li></li>
-->

</ul>

</p>

<p>
Frame identifiers start from 1 onward, and go typically to 6.
</p>

<p>
All the assets which we transformed like described are referenced in our <a href="../../../../../../../../tools/media/video/asset-repository/OSDL-asset-map.html">Asset Map</a> (see notice below).
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code>
 <b>Note</b>: this is currently an intentional broken link when searched from the Internet (non-local use). It is to comply with the will of the author of <a href="http://reinerstileset.4players.de/englisch.html" target="_blank">Reiner's Tilesets</a>, whose only rule is not to have concurrent web pages to his, so that he can present his work as wanted. That's fair, and thanks again Reiner for your beautiful artwork !
</code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>





<!-- ###################################################################### -->

<a name="user-interface"></a> 
<h2>User interface</h2>

<h3></h3>
<p>

</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="tools"></a> 
<h2>Tools used here</h2>

<p>
All of them are free and open source. They have been used on GNU/Linux, but many of them are cross-platform.
</p>


<p>
<ul>

    <li><a href="http://www.gimp.org/" target="_blank">The Gimp</a> (<em>GNU Image Manipulation Program</em>), for most image exploratory manipulations</li>

	<li><a href="http://www.imagemagick.org" target="_blank">ImageMagick</a>,
for powerful command-line bitmap manipulations, allowing to automate them
through scripts that can handle the hundred of sprite frames to be
transformed</li>
	
    <li><a href="http://www.coranac.com/category/proj/grit/" target="_blank">grit</a> (<em>GBA Raster Image Transmogrifier</em>), for test conversion to the DS hardware formats and for testing tiling</li>
 
    <li><a href="http://osdl.sourceforge.net" target="_blank">OSDL</a>, our game library, to ease the development of our home-made converting tools, notably for palette generation (including quantization and gamma correction) and frame preprocessing (colorkey fixing, tiling, encoding, etc.)</li>
 
<!--
    <li><a href="" target="_blank"></a></li>
-->

</ul>
</p>
<p>
All of them are free and open source. They have been used on GNU/Linux, but many of them are cross-platform.
</p>

<p>
<a href="http://www.coranac.com/tonc/text/toc.htm" target="_blank">TONC</a> has been a powerful documentary source to better target the Nintendo DS hardware and understand the various subtleties of tiled graphics.
</p>


<a name="reiner"></a> 
<h2>Some more informations about Reiner Tilesets</h2>
<p>
As many of our graphical assets come from the splendid work available in <a href="http://reinerstileset.4players.de/" target="_blank">Reiner's Tilesets</a>, some specific informations are gathered here.
</p>

<p>
Orginal images are BMP, usually with a kaki (greenish) colorkey: <code>6a4c30</code> in hexadecimal.
</p>



  <br>
  <br>

 <h3>Please react !</h3>

  <p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, <a href="mailto:homebrew@esperide.com?subject=[OSDL]%20Graphical%20rendering%20for%20the%20DS">drop us a line</a>!</p><br>
  <br>
  <hr>
  <br>
 
  <center>
    [<a href="#_top_">Top</a>]
	<br>
    <br>
    <em>Last update: Friday, April 4, 2008</em>
  </center>
</body>
</html>
