<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">

<!--    This document is part of the OSDL project.
		For any question, send a mail to homebrew@esperide.com
-->
<!--    
        Creation date: Sunday, February 17, 2008.
        Author: Olivier Boudeville (homebrew@esperide.com)
        Version: 0.1
-->

<html lang="EN">
<head>
  <title>OSDL - Graphical rendering &amp; asset pipeline for the Nintendo DS</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="description" content="OSDL">
  <meta name="keywords" content="OSDL, Nintendo, DS, GBA, homebrew, graphics">
  <link rel="stylesheet" type="text/css" href="../../../../../common/css/OSDL.css">
  <link href="../../../../../images/OSDL-icon.png" rel="OSDL icon">
</head>

<body>
  
  <div class="banner">
  
    <p><em>General</em> <a href="../../../../../common/black.html" onclick="parent.toolbar.location='../../../../MainMenu.html'">home page</a>
    <a href="../../../../Map.html">site map</a> <a href="mailto:homebrew@esperide.com?subject=[OSDL]%20Graphical%20rendering%20for%20the%20DS">mail us</a></p>
	
  </div><a name="_top_"></a>
  

<h1>Graphical rendering &amp; asset pipeline for the Nintendo DS</h1>


<a name="toc"></a>
<center>
	<table summary="Table of content" style="border: none">
        <tr>
          <td>
		<!--
		       <a href="#"></a><br>
		-->

		   <div class="box">
		       <a href="#overview">Overview</a><br>
		       <a href="#design-choices">Design choices</a><br>
		       <a href="#technical-architecture">Technical architecture</a><br>
		       <a href="#in-world-rendering">In-world rendering</a><br>
		       <a href="#graphic-pipeline">Graphic pipeline</a><br>
		       <a href="#user-interface">User interface</a><br>
			   <a href="#tools">Tools used here</a><br>
		       <a href="#reiner">Some more informations about Reiner Tilesets</a>

          </td>
        </tr>
    </table>
</center>
<!--
<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>
  -->




<!-- ###################################################################### -->

  
<a name="overview"></a>
<h2>Overview</h2>
<p>
Our goal here is to describe a way of managing graphical rendering on the Nintendo DS that may be relevant for some types of games, notably a lightweight isometric engine suitable for RPG-like games.
</p>

<p>
This consists on:
<ul>

	<li><b>designing the proper rendering layer</b> on the DS</li>
	<li><b>setting up the corresponding tools</b> on the PC to generate the relevant assets</li>

<!--
	<li><b></b>: </li>
-->

</ul>
</p>

<p>
We based most of the technical choices on our <a href="../homebrew-guide/HomebrewForDS.html" target="_blank">guide to homebrew development for the Nintendo DS</a>.
</p>

<p>
We are discussing here only about the graphical rendering of the underlying game world, which is to be managed by the <a href="../game-engine/OSDL-game-engine.html" target="_blank">game engine</a>. Audio content in general is not discussed here, see <a href="../../../OSDL/OSDL-generic/Helix-OSDL/helix-osdl.html" target="_blank">Helix-OSDL</a> instead.


</p>


<a name="design-choices"></a> 
<h2>Design choices</h2>

<p>
The game will use a lot of 2D assets, including many animated sprites from various sources, including converted versions from <a href="http://reinerstileset.4players.de/" target="_blank">Reiner's Tilesets</a>. </p>

<p>
Even if most sprites will be scaled down and some animation frames may be removed due to space constraint, one of the main challenges will be to keep a lower enough memory footprint so that the graphical content fits in the scarce memory resources of the DS.
</p>

<p>
This will involve using fully all the VRAM banks of the DS, but also using a double-layered level of cache, as these banks will not suffice: first level of cache will be the DS main RAM, second one the DS cartridge.
</p>




<!-- ###################################################################### -->


<a name="technical-architecture"></a>
<h2>Technical architecture</h2>

<h3>Screen roles</h3>
<p>
We plan to have one screen (the top one) of the DS dedicated to the <a href="#in-world-rendering">in-world rendering</a> (top-down isometric view), whereas the bottom one will display the game <a href="#user-interface">user interface</a> (stats, input device as mouse-like pointer or virtual keyboard, textual descriptions, close-up views, etc.).
</p>

<h3>Rendering Cores</h3>
<p>
In-world rendering being the most intensive task, the main 2D core will be devoted to it (so it will be associated to the top screen). Thus the user interface will rely on the sub core, on the bottom screen. No 3D rendering is planned.
</p>


<h3>VRAM banks</h3>

<p>
Based on the bank <a href="http://www.dev-scene.com/NDS/NDS_Tutorials_VramTable" target="_blank">abilities</a>, the in-game bank layout we chose is:
<center>
  <table border="1" summary="VRAM Memory Banks">
    <caption>VRAM Memory Banks (total: 656 kilobytes)</caption>

    <tr>
        <th>Bank name</th>
        <th>Bank size (in Kilobytes)</th>
        <th>Bank owner</th>
        <th>Intended role</th>
    </tr>

    <tr>
        <td>VRAM_A</td>
        <td>128</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_B</td>
        <td>128</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_C</td>
        <td>128</td>
		<td>Sub engine</td>
		<td>Background</td>
   </tr>

    <tr>
        <td>VRAM_D</td>
        <td>128</td>
		<td>Main engine</td>
		<td>Background</td>
   </tr>

    <tr>
        <td>VRAM_E</td>
        <td>64</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_F</td>
        <td>16</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_G</td>
        <td>16</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_H</td>
        <td>32</td>
		<td>Sub engine</td>
		<td>Background</td>
   </tr>

    <tr>
        <td>VRAM_I</td>
        <td>16</td>
		<td>Main engine</td>
		<td>Extended palettes</td>
   </tr>

  </table>
</center>
</p>

<p>
Main reasons for that is that we want to dedicate as much as possible memory for the main core, notably to hold as much sprites as possible. Bank C is the only one of the four main banks to be able to hold the sub background, D cannot contain main sprite graphics, etc. The sub engine does not need any sprite.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>





<!-- ###################################################################### -->


<a name="in-world-rendering"></a> 
<h2>In-world rendering</h2>

<p>
The game scenes will be made of a static background for environment (grounds, stairs, walls, non-interactive elements, i.e. non-breakable non-movable) on top of which several layers of elements will exist (characters, monsters, furnitures, doors, carpets, objects, etc.).
</p>

<p>
Static backgrounds will be stored in background memory, whereas all other elements will be sprites.
</p>


<h3>Backgrounds</h3>
<p>
These tile-based (not framebuffer-based) static elements are not expected here to be scaled, shared or rotated, unless for some special effects. Thus text backgrounds will be mostly used. We prefer relying on the 8-bit color mode (256 colors), as rendering might be a bit poor with 4-bit color mode (16 colors).
</p>


<h3>Sprites</h3>



<a name="sprite-colors"></a>
<h4>Sprite color modes</h4>
<p>
Among the <a href="http://osdl.sourceforge.net/main/documentation/misc/nintendo-DS/HomebrewForDS.html#sprite-color" target="_blank">available sprite color schemes</a>, the mode usually chosen for games is the one with 16 palettes, each of 256 colors. It is a good trade-off indeed. Simple implementations could cope with one general-purpose palette for all sprites (using an appropriate <a href="http://en.wikipedia.org/wiki/List_of_monochrome_and_RGB_palettes#15-bit_RGB" target="_blank">master palette</a>), whereas more complex ones could associate a palette to a given sprite (usually, animated character). The problem is that it would imply that no more than 16 types of sprites could be displayed simultaneously in the in-world view, which would be a considerable limitation.  
</p>

<p>
We keep in mind most of our sprites will come from the aforementioned Reiner's Tilesets. If we take <a href="http://reinerstileset.4players.de/T_swordstan_shield.zip" target="_blank">Swordstan</a> as an example (most probably our main character, as having multiple animations with multiple outside appearances), the source image (BMP in 24 Bit TrueColor), could be (taken from <code>swordstan shield 96x  bitmaps/attack se0000.bmp</code>) :
<center>
    <img src="swordstan-original.png" alt="Original image"></img>
</center>
</p>

<p>
The same image (in PNG) with a 256-color dedicated optimal palette (i.e. all its colors have been chosen specifically for this image) looks very similar:
<center>
    <img src="swordstan-optimal-palette.png" alt="With 256-color optimal palette"></img>
</center>
</p>

<p>
A palette shared by all graphics can be enforced. As index #0 is reserved for transparency (colorkey), there are 255 colors to be chosen, in [1,255]. Colors have to respect the <code>x555</code> BGR format (5 bits for each color component, they are thus in [0,31]).
</p>

<p>
Thus a palette describing n colors is a simple file (whose extension is preferably <code>pal</code>, ex: <code>myPalette.pal</code>) containing <code>n</code> 16-bit encoded colors (thus the file occupies <code>2.n</code> bytes).
</p>

<p>
We had chosen initially to generate our shared (master) palette with a python script we called <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/src/code/scripts/python/generate_master_palette.py?view=markup" target="_blank">generate_master_palette.py</a>.
</p>

<p>
This palette aims at representing any bitmap image (as opposed to a palette made for a specific set of graphics), as we will have thousands of frames that will have to rely on it.
</p>

<p>
The base of this palette is a 240-color <a href="http://en.wikipedia.org/wiki/List_of_software_palettes#6-8-5_levels_RGB" target="_blank">6-8-5</a> palette: for each of 6 levels of red regularly distributed in the range of color component, there are 8 levels of green, and for each of these there are 5 levels of blue. Therefore <code>6*8*5 = 240</code> different colors are listed. Ranges have been chosen in function of the sensibility of the normal human eye to every primary color.
</p>

<p>
On the 15 remaining colors (255-240), 8 are used for pure greys (which were lacking from the base palette). The 7 last colors have been specifically selected in frames from various characters (notably Stan), to match them more closely.
</p>

<p>
When running the <code>generate_master_palette.py</code> script, following lines are output:
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
Generating a master palette of 240 base colors (for index in [1..240]), 
with 6 levels of red, 8 of green and 5 of blue. Index #0 is reserved 
for the colorkey, which is (106, 76, 48). The 15 remaining index are 
used to add 8 true grays and 7 specific recurrent colors in target images.

  + color index #0: (106, 76, 48)
  + color index #1: (0, 0, 0)
  + color index #2: (0, 0, 63)
  + color index #3: (0, 0, 127)
  + color index #4: (0, 0, 191)
  + color index #5: (0, 0, 255)
  + color index #6: (0, 36, 0)
  + color index #7: (0, 36, 63)
  [..]
  + color index #254: (255, 255, 111)
  + color index #255: (28, 95, 139)
Palette has 256 color index.
 * Writing original master palette to 'master-palette-original.rgb'.
 * Writing gamma-corrected master palette to
  'master-palette-gamma-corrected.rgb'.
 * Writing quantized master palette (non gamma-corrected) to
  'master-palette-quantized.rgb'.
 * Writing final master palette (gamma-corrected, then quantized, then
  encoded for the DS) to 'master-palette.pal'.
Master palette successfully generated.
Use 'master-palette-quantized.rgb' for color-reduction of assets, 
and 'master-palette.pal' as the actual DS palette.     
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
Three palette files have been generated:
<ol>

<!--
	<li></li>
-->

	<li><a href="master-palette-original.rgb">master-palette-original.rgb</a>, storing the color coordinates previously output, each RGB information being stored in a row, in that order, with three bytes per color. This palette looks like that: <img src="master-palette-original.png"></img>, once transformed thanks to
	<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
convert -depth 8 -size 16x16 master-palette-original.rgb -scale 800%
	master-palette-original.png 
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
We can see, from top-left to bottom-right, the color key, then the numetous gradients, then the greys, then the various hand-picked colors.
	</li>
	
	<li>
	
	<p>
	<a href="master-palette-quantized.rgb">master-palette-quantized.rgb</a> is the same palette, but each color component is quantized to the only 32 levels already mentioned, instead of the 256 levels of the original palette. This quantized palette seems not too different from the original one: <img src="master-palette-quantized.png"></img>.
	</p>
	
	<p>
	Note however that the colorkey had to be skipped for this palette, otherwise the color-reduction algorithm could use that color to approximate other colors, which is not wanted.
	</p>
	
	</li>
	
	<li>
	<p>
	finally, <a href="master-palette.pal">master-palette.pal</a> corresponds to the quantized palette in a format suitable for the DS, i.e. each color being defined in a 16-bit x555 BGR format (most significant bit set to 1, then blue, green and red, each component on 5 bits). 
	</p>
	
	<p>
	There is a catch though: the DS screens display colors darker than they are requested. To compensate that, we have to transform the palette that will be used by the DS so that its colors will be brighter: once dark-displayed on the DS they should look like expected from the PC. This transformation is called <a href="http://en.wikipedia.org/wiki/Gamma_correction" target="_blank">gamma-correction</a>, each normalized color component is to be set at the power <code>1/gamma</code> before being denormalized.
	</p>
	
	<p>	
	This operation is automatically done by our script on the actual DS palette (<code>master-palette.pal</code>). We retained a gamma of 2.3 for the average DS screen (intermediate way between DS Fat and DS Lite, see also <a href="http://forum.gbadev.org/viewtopic.php?t=6484" target="_blank">this discussion</a>). The gamma-corrected palette looks brighter than the original, as expected: <img src="master-palette-gamma-corrected.png"></img>
	</p>
	
	<p>	
	Note that pre-processed images have to be be color-reduced against the same palette, but with no gamma correction (<code>master-palette-quantized.rgb</code>), so that their display is correct.
	</p>
	
	</li>
	
	
</ol>

</p>

<p>
Now we can compare in a row:
<ol>

	<li>the original test image with full colors</li>
	<li>the one transformed to match the original master palette</li>
	<li>then the one using the quantized master palette</li>
	<li>the one using the quantized gamma-corrected palette (on a PC the latter should look too bright)</li>

<!--
	<li><b></b>: </li>
-->
</ol>
<center>
	<img src="swordstan-original.png" alt="Original image"></img>
	<img src="swordstan-master-original.png" alt="With original palette"></img>
	<img src="swordstan-master-quantized.png" alt="With quantized palette"></img>
	<img src="swordstan-master-gamma-corrected.png" alt="With quantized gamma-corrected palette"></img>
</center>
</p>

<p>
The result seems very good indeed, colors are well preserved in non gamma-corrected images. Note however that the colorkey changed a bit in the third and fourth images, due to the quantization and to the gamma-correction.	
</p>

<p>
The three transformed images have been obtained thanks to:
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
convert swordstan-original.png +dither -map master-palette-original.png swordstan-master-original.png

convert swordstan-original.png +dither -map master-palette-quantized.png swordstan-master-quantized.png

convert swordstan-master-quantized.png -gamma 2.3 swordstan-master-gamma-corrected.png
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>


<p>
Note that, for this explanation, the gamma-corrected image was obtained directly with ImageMagick, not using:
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
convert swordstan-original.png +dither -map master-palette-gamma-corrected.png
	swordstan-master-against-gamma-corrected.png
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
as otherwise it would generate an image referencing colors from the right gamma-corrected palette, but with the original colors reduced against that same (too bright) palette, whereas we need to have them matched against the non gamma-corrected one.
</p>


<a name="sprite-size"></a>
<h4>Sprite sizes</h4>
<p>
Here is a screenshot of our <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/test/cross-tests/testOSDLVideoFramebuffer.arm9.cc?view=markup" target="_blank">testOSDLVideoFramebuffer</a> test program taken with the NO$GBA emulator:

<center>
    <img src="sprite-sizes.png" alt="Sprite sizes"></img>
</center>

</p>

<p>
It allows to better figure out the <a href="http://osdl.sourceforge.net/main/documentation/misc/nintendo-DS/HomebrewForDS.html#sprite-size" target="_blank">available sprite sizes</a>: yellow is for height of 8 pixels, white for 16, blue of 32 and cyan for 64. We deemed the most appropriate size of a character is in general the third blue shape, the 32x32 square: with its 4x4=16 tiles, its memory footprint should be bearable, and, compared to the rest of the screen, there is enough room to display the environment of the character (not too big, not too small).
</p>

<p>
Using Swordstan again as an example, knowing that Reiner's Tilesets offer bigger frames, the source image could be:
<center>
    <img src="swordstan-original.png" alt="Original image"></img>
</center>
This is 96x96. If we reduced the original directly to 32x32, it would result in:
<center>
    <img src="swordstan-direct-32x32.png" alt="Original image"></img>
</center>
which is too small. Instead if we first crop the frame (the actual original content could fit in a 75x85 rectangle):
<center>
    <img src="swordstan-cropped-original.png" alt="Original Cropped Image"></img>
</center>
then we reduce it to 20x32 (preserving the ratio), we have:
<center>
    <img src="swordstan-cropped-32.png" alt="Image"></img>
</center>
which is better.
</p>

<p>
Resizing is preferably performed thanks to the Lanczos filter: <img src="swordstan-IM-Lanczos.png"></img>, resulting in sharper images than (bi)linear: <img src="swordstan-IM-Bilinear.png"></img> or (bi)cubic: <img src="swordstan-IM-Bicubic.png"></img>
</p>

<p>
These resized images have been obtained thanks to <a href="http://www.imagemagick.org" target="_blank">ImageMagick</a> with following commands:
<ul>

	<li><b>Lanczos</b>: <code>convert swordstan-original.png -filter Lanczos -resize 50x50 swordstan-IM-Lanczos.png</code></li>
	
	<li><b>Linear</b>: <code>convert swordstan-original.png -filter triangle  -resize 50x50 swordstan-IM-Bilinear.png</code></li>
	
	<li><b>Cubic</b>: <code>convert swordstan-original.png -filter Cubic  -resize 50x50 swordstan-IM-Bicubic.png</code></li>

<!--
	<li><b></b>: <code></code></li>
-->

</ul>

</p>


<h4>Sprite animations</h4>
<p>
Let's take the character that is most probably the most complex one that will have to render: Stan.
</p>


<h5>Outside looks for a given character</h5>
<p>
First of all Stan has 8 different outside looks, sorted roughly according to the order in which they might appear in a story (example images are in low quality):
<ol>
<!--
	<li><b></b> : </li>
-->

	<li><b>Unarmed</b> Stan (<a href="http://reinerstileset.4players.de/Tstanunarmed.zip" target="_blank">stanunarmed</a>): 
<center>
    <img src="Stan-unarmed.png" alt="Unarmed"></img>
</center>
</li>

	<li>Stan with <b>a club</b> (<a href="http://reinerstileset.4players.de/Tclubstan.zip" target="_blank">clubstan</a>): 
<center>
    <img src="Stan-club.png" alt="Club"></img>
</center>
</li>

	<li>Stan with <b>a sword (and no shield)</b> (<a href="http://reinerstileset.4players.de/Tswordstan.zip" target="_blank">swordstan</a>)
<center>
    <img src="Stan-sword.png" alt="Sword"></img>
</center>
</li>

	<li>Stan with <b>a bow</b> (<a href="http:///http://reinerstileset.4players.de/T_bowstan.zip" target="_blank">bowstan</a>): 
<center>
    <img src="Stan-bow.png" alt="Bow"></img>
</center>
</li>

	<li>Stan with <b>an axe (and no shield)</b> (<a href="http://reinerstileset.4players.de/Taxestan.zip" target="_blank">axestan</a>): 
<center>
    <img src="Stan-axe.png" alt="Axe"></img>
</center>
</li>

	<li>Stan with <b>a sword and a shield</b> (<a href="http://reinerstileset.4players.de/T_swordstan_shield.zip" target="_blank">swordstan shield</a>)
<center>
    <img src="Stan-sword-shield.png" alt="Sword and Shield"></img>
</center>
</li>

	<li>Stan with <b>an axe and a shield</b> (<a href="http://reinerstileset.4players.de/T_axestan_shield.zip" target="_blank">axestan shield</a>): 
<center>
    <img src="Stan-axe-shield.png" alt="Axe and Shield"></img>
</center>
</li>

	<li>Stan with <b>a staff</b> (<a href="http://reinerstileset.4players.de/Tstaffstan%20.zip" target="_blank">staffstan</a>): 
<center>
    <img src="Stan-staff.png" alt="Staff"></img>
</center>
</li>

</ol>

</p>


<h5>Attitudes</h5>
<p>
To each of these different outside looks correspond a set of attitudes (behaviours in action). Different looks have often different sets of attitudes. 
</p>

<p>
For example, the unarmed Stan can:
<ul>

	<li>be still</li>
	<li>walk</li>
	<li>run</li>
	<li>attack (high kick)</li>
	<li>tip over (fall on the ground)</li>
	<li>been hit by a blow</li>
	<li>talk</li>
	<li>knit (most probably after having be idle for too long)</li>


<!--
	<li></li>
-->

</ul>
whereas Stan with a sword and a shield cannot knit, Stan with a staff has two attacks (regular and magical one), etc.
</p>


<h5>Directions</h5>
<p>
For each attitude, eight directions have always to be taken into account : character facing north, south, west, east, and the four related diagonals.
</p>

<p>
As characters are usually asymmetric, one cannot deduce for example eastward animations from westward ones (showing the character rotate clockwise):
<center>
    <img src="staffstan-north.png" alt="North"></img>
    <img src="staffstan-north-east.png" alt="North-East"></img>
    <img src="staffstan-east.png" alt="East"></img>
    <img src="staffstan-south-east.png" alt="South-East"></img>
    <img src="staffstan-south.png" alt="South"></img>
    <img src="staffstan-south-west.png" alt="South-West"></img>
    <img src="staffstan-west.png" alt="West"></img>
    <img src="staffstan-north-west.png" alt="North-West"></img>
</center>
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<h5>Frames</h5>
<p>
Finally, for each direction a given character attitude can be decomposed into a series of frames.
</p>

<p>
For example a Stan with sword and shield walking eastward uses following 8 frames in a cycle:
<center>
    <img src="swordstanshield-w-e-0.png" alt="0"></img>
    <img src="swordstanshield-w-e-1.png" alt="1"></img>
    <img src="swordstanshield-w-e-2.png" alt="2"></img>
    <img src="swordstanshield-w-e-3.png" alt="3"></img>
    <img src="swordstanshield-w-e-4.png" alt="4"></img>
    <img src="swordstanshield-w-e-5.png" alt="5"></img>
    <img src="swordstanshield-w-e-6.png" alt="6"></img>
    <img src="swordstanshield-w-e-7.png" alt="7"></img>
</center>

</p>

<p>
The number of frames depends on the attitude, but not on the direction: talking uses 7 frames, whereas walking 8.
</p>


<h5>Synthesis about animations</h5>

<p>
Animations must be rendered for various game elements: characters (player character(s), NPC, monsters, etc.), special effects (explosions, fountains, etc.), animated objects (drawing bridge, door, etc.).
</p>

<p>
A given element (say, a character) can have multiple outside looks (unarmed, or with different weapons, clothing, injuries, etc.).
</p>

<p>
For a given outside look, various attitudes might be available (walking, running, fighting, etc.).
</p>

<p>
An attitude has usually to be defined according to 8 directions.
</p>

<p>
For each direction, a number of frames makes the effective animation.
</p>

<p>
Thus one has to plan <code>NanimatedElements x Nlooks x Nattitudes x Ndirections x Nframes</code>. Most games, just counting the characters (friend, foe, monsters, etc.), have to have at least a dozen of them.
</p>

<p>
Considering the worst case, the main character Stan (who is the most detailed one), we count roughly <code>8 looks x 7 attitudes on average x 8 directions x 7 frames on average = 3136</code> frames. This is quite huge.
</p>

<p>
Considering the average 27-kilobyte original image might be trimmed and reduced for the DS to 1 kilobyte (1024 = 32x32 pixels, as discussed in the <a href="#sprite-size">sprite size section</a> and 8 bits per pixel, as discussed in the <a href="#sprite-colors">sprite color section</a>), the footprint might be, only for the characters, roughly equal to <code>12 characters x 3136 frames x 1024 bytes = 36 megabytes</code>. We chose not to remove frames from animations, as fluidity is important. Moreover it would be a shame not to take advantage of assets of such quality.
</p>

<p>
Compared to the overall 656 kilobytes of VRAM memory, to the 4 megabytes of RAM available for code, sounds, other graphical elements, and to the up to 128 megabytes of storage provided by a commercial cartridge, this is a challenge that may be met if using appropriate streaming and caching.
</p>



<!-- ###################################################################### -->

<a name="graphic-pipeline"></a> 
<h2>Graphic pipeline</h2>
<p>
After having taken into account all previous constraints (size, formats, colors, etc.), we chose the following process, that should led from the raw assets (coming for Reiner or other sources) to the precomputed content ready and optimized for the DS.
</p>

<h3>Step A: determining the target palette</h3>

<p>

	<ol>
	
		<li><b>choice</b> of the target DS palette, a master palette shared by most if not all animations, thus made so that all colors possibly used can be approximated with minimal mean error. Maybe later: creation of a palette dedicated to a given animated object, instead of a global palette
		</li>

		<li><b>gamma correction</b> of this palette, according to the gamut of DS screens
		</li>

	</ol>

</p>


<h3>Step B: transformation of a given animated object</h3>

<p>
First step: <b>per-animated object content sorting</b>, to create a frame hierarchy based on: outside looks, then attitudes, then directions, then ordered frames.
</p>


<p>
Then, for each frame:

	<ol>

		<li><b>resizing</b>, from original size to target DS planned size, based on a global and a per-asset ratio, determined so that the resized sprite complies with the in-game chosen scale
		</li>
	
		<li><b>color best-effort quantification</b>, from the original colors of the frame (per-pixel or indexed) to the optimal mapping according to the aforementioned target DS palette, with color key set for the sprite borders
		</li>

		<li><b>cropping</b>, to determine for sprites the smallest rectangle enclosing the actual image and to determine the vector offset (hot-spot) to recenter the resulting sprite into the frame stream. For the generation of backgrounds, as tiles cannot be positioned on a per-pixel basis, a specific tile-aligned cropping is to be performed
		</li>

		<li><b>tiling</b>, to cut the sprite into (8x8 here) tiles, with padding so that the corresponding tile map matches the smallest possible shape of DS sprites
		</li>

		<li><b>meta-tiling</b> (optional), to support bigger sprites or to use more optimal sprite shapes
		</li>

		<li><b>RLE encoding</b> (optional), to save some space in the storage media with repeated colorkeyed pixels
		</li>
			
		<li><b>generation of the frame file</b> (see below)
		</li>
			
	</ol>

</p>

<p>
Finally, creation of:
<ol>

<!--
	<li><b></b> : </li>
-->

	<li>a <b>per-frame file</b>: for a given animated object, outside look, attitude, direction and animation step, it stores a given frame, with a somewhat self-describing filename (see naming conventions below). The file contains an header, specifying the frame metadata (notably the offset vector, the size and type of the frame map, the reference of the palette), and then the ordered set of tiles
	</li>
	
	<li>a <b>per-direction file</b>: for a given animated object, outside look, attitude and direction, stores the corresponding series of frames. The file contains an header, specifying the per-direction animation metadata (notably the number of frames involved, and their offset in this file), and then the ordered series of frames. Such a file is made from a generated header followed by the concatenated per-frame files
	</li>

	<li>a <b>per-attitude file</b>: for a given animated object, outside look and attitude, stores the corresponding directions (generally, 8). The file contains an header, specifying the attitude metadata (notably the number directions, and their offset in this file, but also any sound that should be output unconditionally during this animation), and then the associate set of per-direction files
	</li>

	<li>a <b>per-outside look file</b>: for a given animated object and outside look, stores the corresponding attitudes. The file contains an header, specifying the outside look metadata (notably the number of attitudes, their identifier and their offset in this file), and then the associated set of per-attitude files
	</li>
	
	<li>a <b>per-animated object file</b>: for a given animated object , stores the corresponding outside looks. The file contains an header, specifying the  metadata of the animated object (notably the number of outside looks, their identifier and their offset in this file), and then the associated set of per-outside look files
	</li>
		
</ol>




<h3>Naming conventions</h3>

<p>
To avoid to store too many informations in index files, filenames should respect the following conventions, so that they can be deduced rather than stored in an associative map.
</p>

<p>
The filename for a <b>frame</b> is made of a set of alphanumerical fields and a suffix: <code>F1-F2-F3-F4-F5.osdl.frame</code>.
</p>

<p>
Fields are:

<ol>
<!--
	<li><b></b> : </li>
-->
	<li><b>animated object identifier</b> (F1)</li>

	<li><b>outside look identifier</b> (F2)</li>

	<li><b>attitude identifier</b> (F3)</li>

	<li><b>direction identifier</b> (F4)</li>

	<li><b>frame identifier</b> (F5)</li>
	
</ol>
</p>

<p>
A given field is not specific to the previous one. For example, the outside look (F2) <code>ArmedWithASword</code> may apply to multiple characters (F1) : Stan, but also all characters whose outside look can be described as "<code>ArmedWithASword</code>".
</p>

<p>
Each field is described by a look-up associative table (identifier repository), a key being a human-friendly unique symbol (ex: <code>ArmedWithASword</code>), each value being the numerical identifier of this key (positive integer starting at 1, ex: <code>27</code>), to be interpreted in the context of the type they are associated with (here it is an outside look, we may have for example an attitude identifier of <code>27</code>, which would be totally unrelated to the previous <code>27</code>).
</p>

<p>
The table layout is a set of ASCII lines, each line specifying a key/value pair, the key being made of one word in CamelCase, the value being deduced from of the number of the line in the file. Thus, if the <code>NorthEast</code> key is at line 2, <code>NorthEast  = 2</code>. Keys are sorted in alphabetical order (the one of the <code>sort</code> command).
</p>

<p>
The repository of:
<ul>

	<li>animated object identifiers (F1) is defined in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/video/asset-repository/animated-object-identifiers.txt?view=markup" target="_blank">animated-object-identifiers.txt</a></li>
	
	<li>outside look identifiers (F2) is defined in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/video/asset-repository/outside-looks-identifiers.txt?view=markup" target="_blank">outside-look-identifiers.txt</a></li>
	
	<li>attitude identifiers (F3) is defined in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/video/asset-repository/attitude-identifiers.txt?view=markup" target="_blank">attitude-identifiers.txt</a></li>
	
	<li>direction identifiers (F4) is defined in <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/tools/media/video/asset-repository/direction-identifiers.txt?view=markup" target="_blank">direction-identifiers.txt</a>. It is composed of the 8 main directions</li>

<!--
	<li></li>
-->

</ul>

</p>

<p>
Frame identifiers start from 1 onward, and go typically to 6.
</p>

<p>
All the assets which we transformed like described are referenced in our <a href="../../../../../../../../tools/media/video/asset-repository/OSDL-asset-map.html">Asset Map</a> (see notice below).
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code>
 <b>Note</b>: this is currently an intentional broken link when searched from the Internet (non-local use). It is to comply with the will of the author of <a href="http://reinerstileset.4players.de/englisch.html" target="_blank">Reiner's Tilesets</a>, whose only rule is not to have concurrent web pages to his, so that he can present his work as wanted. That's fair, and thanks again Reiner for your beautiful artwork !
</code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>





<!-- ###################################################################### -->

<a name="user-interface"></a> 
<h2>User interface</h2>

<h3></h3>
<p>

</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="tools"></a> 
<h2>Tools used here</h2>

<p>
All of them are free and open source. They have been used on GNU/Linux, but many of them are cross-platform.
</p>


<p>
<ul>

    <li><a href="http://www.gimp.org/" target="_blank">The Gimp</a> (<em>GNU Image Manipulation Program</em>), for most image exploratory manipulations</li>

	<li><a href="http://www.imagemagick.org" target="_blank">ImageMagick</a>,
for powerful command-line bitmap manipulations, allowing to automate them
through scripts that can handle the hundred of sprite frames to be
transformed</li>
	
    <li><a href="http://www.coranac.com/category/proj/grit/" target="_blank">grit</a> (<em>GBA Raster Image Transmogrifier</em>), for test conversion to the DS hardware formats and for testing tiling</li>
 
    <li><a href="http://osdl.sourceforge.net" target="_blank">OSDL</a>, our game library, to ease the development of our home-made converting tools, notably for palette generation (including quantization and gamma correction) and frame preprocessing (colorkey fixing, tiling, encoding, etc.)</li>
 
<!--
    <li><a href="" target="_blank"></a></li>
-->

</ul>
</p>
<p>
All of them are free and open source. They have been used on GNU/Linux, but many of them are cross-platform.
</p>

<p>
<a href="http://www.coranac.com/tonc/text/toc.htm" target="_blank">TONC</a> has been a powerful documentary source to better target the Nintendo DS hardware and understand the various subtleties of tiled graphics.
</p>


<a name="reiner"></a> 
<h2>Some more informations about Reiner Tilesets</h2>
<p>
As many of our graphical assets come from the splendid work available in <a href="http://reinerstileset.4players.de/" target="_blank">Reiner's Tilesets</a>, some specific informations are gathered here.
</p>

<p>
Orginal images are BMP, usually with a kaki (greenish) colorkey: <code>6a4c30</code> in hexadecimal.
</p>



  <br>
  <br>

 <h3>Please react !</h3>

  <p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, <a href="mailto:homebrew@esperide.com?subject=[OSDL]%20Graphical%20rendering%20for%20the%20DS">drop us a line</a>!</p><br>
  <br>
  <hr>
  <br>
 
  <center>
    [<a href="#_top_">Top</a>]
	<br>
    <br>
    <em>Last update: Saturday, March 29, 2008</em>
  </center>
</body>
</html>
