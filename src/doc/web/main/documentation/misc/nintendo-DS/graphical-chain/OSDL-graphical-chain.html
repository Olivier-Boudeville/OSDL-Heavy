<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">

<!--    This document is part of the OSDL project.
		For any question, send a mail to homebrew@esperide.com
-->
<!--    
        Creation date: Sunday, February 17, 2008.
        Author: Olivier Boudeville (homebrew@esperide.com)
        Version: 0.1
-->

<html lang="EN">
<head>
  <title>OSDL - Graphical rendering &amp; asset pipeline for the Nintendo DS</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="description" content="OSDL">
  <meta name="keywords" content="OSDL, Nintendo, DS, GBA, homebrew, graphics">
  <link rel="stylesheet" type="text/css" href="../../../../../common/css/OSDL.css">
  <link href="../../../../../images/OSDL-icon.png" rel="OSDL icon">
</head>

<body>
  
  <div class="banner">
  
    <p><em>General</em> <a href="../../../../../common/black.html" onclick="parent.toolbar.location='../../../../MainMenu.html'">home page</a>
    <a href="../../../../Map.html">site map</a> <a href="mailto:homebrew@esperide.com?subject=[OSDL]%20Graphical%20rendering%20for%20the%20DS">mail us</a></p>
	
  </div><a name="_top_"></a>
  

<h1>Graphical rendering &amp; asset pipeline for the Nintendo DS</h1>


<a name="toc"></a>
<center>
	<table summary="Table of content" style="border: none">
        <tr>
          <td>
		<!--
		       <a href="#"></a><br>
		-->

		   <div class="box">
		       <a href="#overview">Overview</a><br>
		       <a href="#design-choices">Design choices</a><br>
		       <a href="#technical-architecture">Technical architecture</a><br>
		       <a href="#in-world-rendering">In-world rendering</a><br>
		       <a href="#graphic-pipeline">Graphic pipeline</a><br>
		       <a href="#user-interface">User interface</a><br>
		       <a href="#tools">Tools used here</a><br>

          </td>
        </tr>
    </table>
</center>
<!--
<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>
  -->




<!-- ###################################################################### -->

  
<a name="overview"></a>
<h2>Overview</h2>
<p>
Our goal here is to describe a way of managing graphical rendering on the Nintendo DS that may be relevant for some types of games, notably a lightweight isometric engine suitable for RPG-like games.
</p>

<p>
This consists on:
<ul>

	<li><b>designing the proper rendering layer</b> on the DS</li>
	<li><b>setting up the corresponding tools</b> on the PC to generate the relevant assets</li>

<!--
	<li><b></b>: </li>
-->

</ul>
</p>

<p>
We based most of the technical choices on our <a href="../homebrew-guide/HomebrewForDS.html" target="_blank">guide to homebrew development for the Nintendo DS</a>.
</p>

<p>
We are discussing here only about the graphical rendering of the underlying game world, which is to be managed by the <a href="../game-engine/OSDL-game-engine.html" target="_blank">game engine</a>.

</p>


<a name="design-choices"></a> 
<h2>Design choices</h2>

<p>
The game will use a lot of 2D assets, including many animated sprites from various sources, including converted versions from <a href="http://reinerstileset.4players.de/" target="_blank">Reiner's Tilesets</a>. </p>

<p>
Even if most sprites will be scaled down and some animation frames may be removed due to space constraint, one of the main challenges will be to keep a lower enough memory footprint so that the graphical content fits in the scarce memory resources of the DS.
</p>

<p>
This will involve using fully all the VRAM banks of the DS, but also using a double-layered level of cache, as these banks will not suffice: first level of cache will be the DS main RAM, second one the DS cartridge.
</p>




<!-- ###################################################################### -->


<a name="technical-architecture"></a>
<h2>Technical architecture</h2>

<h3>Screen roles</h3>
<p>
We plan to have one screen (the top one) of the DS dedicated to the <a href="#in-world-rendering">in-world rendering</a> (top-down isometric view), whereas the bottom one will display the game <a href="#user-interface">user interface</a> (stats, input device as mouse-like pointer or virtual keyboard, textual descriptions, close-up views, etc.).
</p>

<h3>Rendering Cores</h3>
<p>
In-world rendering being the most intensive task, the main 2D core will be devoted to it (so it will be associated to the top screen). Thus the user interface will rely on the sub core, on the bottom screen. No 3D rendering is planned.
</p>


<h3>VRAM banks</h3>

<p>
Based on the bank <a href="http://www.dev-scene.com/NDS/NDS_Tutorials_VramTable" target="_blank">abilities</a>, the in-game bank layout we chose is:
<center>
  <table border="1" summary="VRAM Memory Banks">
    <caption>VRAM Memory Banks (total: 656 kilobytes)</caption>

    <tr>
        <th>Bank name</th>
        <th>Bank size (in Kilobytes)</th>
        <th>Bank owner</th>
        <th>Intended role</th>
    </tr>

    <tr>
        <td>VRAM_A</td>
        <td>128</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_B</td>
        <td>128</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_C</td>
        <td>128</td>
		<td>Sub engine</td>
		<td>Background</td>
   </tr>

    <tr>
        <td>VRAM_D</td>
        <td>128</td>
		<td>Main engine</td>
		<td>Background</td>
   </tr>

    <tr>
        <td>VRAM_E</td>
        <td>64</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_F</td>
        <td>16</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_G</td>
        <td>16</td>
		<td>Main engine</td>
		<td>Sprite Graphics</td>
   </tr>

    <tr>
        <td>VRAM_H</td>
        <td>32</td>
		<td>Sub engine</td>
		<td>Background</td>
   </tr>

    <tr>
        <td>VRAM_I</td>
        <td>16</td>
		<td>Main engine</td>
		<td>Extended palettes</td>
   </tr>

  </table>
</center>
</p>

<p>
Main reasons for that is that we want to dedicate as much as possible memory for the main core, notably to hold as much sprites as possible. Bank C is the only one of the four main banks to be able to hold the sub background, D cannot contain main sprite graphics, etc. The sub engine does not need any sprite.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>





<!-- ###################################################################### -->


<a name="in-world-rendering"></a> 
<h2>In-world rendering</h2>

<p>
The game scenes will be made of a static background for environment (grounds, stairs, walls, non-interactive elements, i.e. non-breakable non-movable) on top of which several layers of elements will exist (characters, monsters, furnitures, doors, carpets, objects, etc.).
</p>

<p>
Static backgrounds will be stored in background memory, whereas all other elements will be sprites.
</p>


<h3>Backgrounds</h3>
<p>
These tile-based (not framebuffer-based) static elements are not expected here to be scaled, shared or rotated, unless for some special effects. Thus text backgrounds will be mostly used. We prefer relying on the 8-bit color mode (256 colors), as rendering might be a bit poor with 4-bit color mode (16 colors).
</p>


<h3>Sprites</h3>



<a name="sprite-colors"></a>
<h4>Sprite color modes</h4>
<p>
Among the <a href="http://osdl.sourceforge.net/main/documentation/misc/nintendo-DS/HomebrewForDS.html#sprite-color" target="_blank">available sprite color schemes</a>, the mode usually chosen for games is the one with 16 palettes, each of 256 colors. It is a good trade-off indeed. Simple implementations could cope with one general-purpose palette for all sprites (using an appropriate <a href="http://en.wikipedia.org/wiki/List_of_monochrome_and_RGB_palettes#15-bit_RGB" target="_blank">master palette</a>), whereas more complex ones could associate a palette to a given sprite (usually, animated character). The problem is that it would imply that no more than 16 types of sprites could be displayed simultaneously in the in-world view.  
</p>

<p>
We keep in mind most of our sprites will come from the aforementioned Reiner's Tilesets. If we take <a href="http://reinerstileset.4players.de/T_swordstan_shield.zip" target="_blank">Swordstan</a> as an example (most probably our main character, as having multiple animations with multiple outside appearances), the source image (BMP in 24 Bit TrueColor), could be (taken from <code>swordstan shield 96x  bitmaps/attack se0000.bmp</code> :
<center>
    <img src="swordstan-original.bmp" alt="Original image"></img>
</center>
</p>

<p>
The same image (in PNG) with a 256-color dedicated optimal palette (i.e. all its colors have been chosen specifically for this image) :
<center>
    <img src="swordstan-optimal-palette.png" alt="With 256-color optimal palette"></img>
</center>
</p>

</p>


http://en.wikipedia.org/wiki/List_of_software_palettes#6-7-6_levels_RGB

http://en.wikipedia.org/wiki/List_of_software_palettes#RGB_arrangements

1 palette pour stan
1 pour tout le reste


<a name="sprite-size"></a>
<h4>Sprite sizes</h4>
<p>
Here is a screenshot of our <a href="http://osdl.svn.sourceforge.net/viewvc/osdl/OSDL/trunk/test/cross-tests/testOSDLVideoFramebuffer.arm9.cc?view=markup" target="_blank">testOSDLVideoFramebuffer</a> test program taken with NO$GBA:

<center>
    <img src="sprite-sizes.png" alt="Sprite sizes"></img>
</center>

</p>

<p>
It allows to better figure out the <a href="http://osdl.sourceforge.net/main/documentation/misc/nintendo-DS/HomebrewForDS.html#sprite-size" target="_blank">available sprite sizes</a>: yellow is for height of 8 pixels, white for 16, blue of 32 and cyan for 64. We deemed the most appropriate size of a character is in general the third blue shape, the 32x32 square: with its 4x4=16 tiles, its memory footprint should be bearable, and, compared to the rest of the screen, there is enough room to display the environment of the character (not too big, not too small).
</p>

<p>
Using Swordstan again as an example, knowing that Reiner's Tilesets offer bigger frames, the source image could be:
<center>
    <img src="swordstan-original.png" alt="Original image"></img>
</center>
This is 96x96. If we reduced the original directly to 32x32, it would result in:
<center>
    <img src="swordstan-direct-32x32.png" alt="Original image"></img>
</center>
which is too small. Instead if we first crop the frame (the actual original content could fit in a 75x85 rectangle):
<center>
    <img src="swordstan-cropped-original.png" alt="Original Cropped Image"></img>
</center>
then we reduce it to 20x32 (preserving the ratio), we have:
<center>
    <img src="swordstan-cropped-32.png" alt="Image"></img>
</center>
which is better.
</p>


<h4>Sprite animations</h4>
<p>
Let's take the character that is most probably the most complex one that will have to render: Stan.
</p>


<h5>Outside looks for a given character</h5>
<p>
First of all Stan has 8 different outside looks (sorted roughly according to the order in which they might appear in a story):
<ol>
<!--
	<li><b></b> : </li>
-->

	<li><b>Unarmed</b> Stan (<a href="http://reinerstileset.4players.de/Tstanunarmed.zip" target="_blank">stanunarmed</a>): 
<center>
    <img src="stanunarmed.jpg" alt="Unarmed"></img>
</center>
</li>

	<li>Stan with <b>a club</b> (<a href="http://reinerstileset.4players.de/Tclubstan.zip" target="_blank">clubstan</a>): 
<center>
    <img src="clubstan.jpg" alt="Club"></img>
</center>
</li>

	<li>Stan with <b>a sword (and no shield)</b> (<a href="http://reinerstileset.4players.de/Tswordstan.zip" target="_blank">swordstan</a>)
<center>
    <img src="swordstan.jpg" alt="Sword"></img>
</center>
</li>

	<li>Stan with <b>a bow</b> (<a href="http:///http://reinerstileset.4players.de/T_bowstan.zip" target="_blank">bowstan</a>): 
<center>
    <img src="bowstan.jpg" alt="Bow"></img>
</center>
</li>

	<li>Stan with <b>an axe (and no shield)</b> (<a href="http://reinerstileset.4players.de/Taxestan.zip" target="_blank">axestan</a>): 
<center>
    <img src="axestan.jpg" alt="Axe"></img>
</center>
</li>

	<li>Stan with <b>a sword and a shield</b> (<a href="http://reinerstileset.4players.de/T_swordstan_shield.zip" target="_blank">swordstan shield</a>)
<center>
    <img src="swordstanshield.jpg" alt="Sword and Shield"></img>
</center>
</li>


	<li>Stan with <b>an axe and a shield</b> (<a href="http://reinerstileset.4players.de/T_axestan_shield.zip" target="_blank">axestan shield</a>): 
<center>
    <img src="axestanshield.jpg" alt="Axe and Shield"></img>
</center>
</li>



	<li>Stan with <b>a staff</b> (<a href="http://reinerstileset.4players.de/Tstaffstan%20.zip" target="_blank">staffstan</a>): 
<center>
    <img src="staffstan.jpg" alt="Staff"></img>
</center>
</li>

</ol>

</p>


<h5>Attitudes</h5>
<p>
To each of these different outside looks correspond a set of attitudes (behaviours in action). Different looks have often different sets of attitudes. 
</p>

<p>
For example, the unarmed Stan can:
<ul>

	<li>be still</li>
	<li>walk</li>
	<li>run</li>
	<li>attack (high kick)</li>
	<li>tip over (fall on the ground)</li>
	<li>been hit by a blow</li>
	<li>talk</li>
	<li>knit (most probably having rest for too long)</li>


<!--
	<li></li>
-->

</ul>
whereas Stan with a sword and a shield cannot knit, Stan with a staff has two attacks (regular and magical one), etc.
</p>


<h5>Directions</h5>
<p>
For each attitude, eight directions have always to be taken into account : character facing north, south, west, east, and the four related diagonals.
</p>

<p>
As characters are usually asymmetric, one cannot deduce for example eastward animations from westward ones (showing the character rotate clockwise):
<center>
    <img src="staffstan-north.bmp" alt="North"></img>
    <img src="staffstan-north-east.bmp" alt="North-East"></img>
    <img src="staffstan-east.bmp" alt="East"></img>
    <img src="staffstan-south-east.bmp" alt="South-East"></img>
    <img src="staffstan-south.bmp" alt="South"></img>
    <img src="staffstan-south-west.bmp" alt="South-West"></img>
    <img src="staffstan-west.bmp" alt="West"></img>
    <img src="staffstan-north-west.bmp" alt="North-West"></img>
</center>
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<h5>Frames</h5>
<p>
Finally, for each direction a given character attitude can be decomposed into a series of frames.
</p>

<p>
For example a Stan with sword and shield walking eastward uses following 8 frames in a cycle:
<center>
    <img src="swordstanshield-w-e-0.bmp" alt="0"></img>
    <img src="swordstanshield-w-e-1.bmp" alt="1"></img>
    <img src="swordstanshield-w-e-2.bmp" alt="2"></img>
    <img src="swordstanshield-w-e-3.bmp" alt="3"></img>
    <img src="swordstanshield-w-e-4.bmp" alt="4"></img>
    <img src="swordstanshield-w-e-5.bmp" alt="5"></img>
    <img src="swordstanshield-w-e-6.bmp" alt="6"></img>
    <img src="swordstanshield-w-e-7.bmp" alt="7"></img>
</center>

</p>

<p>
The number of frames depends on the attitude, but not on the direction: talking uses 7 frames, whereas walking 8.
</p>


<h5>Synthesis about animations</h5>

<p>
Animations must be rendered for various game elements: characters (player character(s), NPC, monsters, etc.), special effects (explosions, fountains, etc.), animated objects (drawing bridge, door, etc.).
</p>

<p>
A given element (say, a character) can have multiple outside looks (unarmed, or with different weapons, clothing, injuries, etc.).
</p>

<p>
For a given outside look, various attitudes might be available (walking, running, fighting, etc.).
</p>

<p>
An attitude has usually to be defined according to 8 directions.
</p>

<p>
For each direction, a number of frames makes the effective animation.
</p>

<p>
Thus one has to plan <code>NanimatedElements x Nlooks x Nattitudes x Ndirections x Nframes</code>. Most games, just counting the characters (friend, foe, monsters, etc.), have to have at least a dozen of them.
</p>

<p>
Considering the worst case, the main character Stan (who is the most detailed one), we count roughly <code>8 looks x 7 attitudes on average x 8 directions x 7 frames on average = 3136</code> frames. This is quite huge.
</p>

<p>
Considering the average 27-kilobyte original image might be trimmed and reduced for the DS to 1 kilobyte (1024 = 32x32 pixels, as discussed in the <a href="#sprite-size">sprite size section</a> and 8 bits per pixel, as discussed in the <a href="#sprite-colors">sprite color section</a>), and that only one frame out of two may be kept, the footprint might be, only for the characters, roughly equal to <code>12 characters x 1568 frames x 1024 bytes = 18 megabytes</code>.
</p>

<p>
Compared to the overall 656 kilobytes of VRAM memory, to the 4 megabytes of RAM available for code, sounds, other graphical elements, and to the up to 128 megabytes of storage provided by a commercial cartridge, this is a challenge that may be met if using appropriate streaming and caching.
</p>





<!-- ###################################################################### -->

<a name="graphic-pipeline"></a> 
<h2>Graphic pipeline</h2>
<p>
After having taken into account all previous constraints (size, formats, colors, etc.), we chose the following steps that should led from the raw assets (coming for Reiner or other sources) to the precomputed content ready and optimized for the DS:
<ol>
<!--
	<li><b></b> : </li>
-->
	<li><b></b> : </li>
	<li><b></b> : </li>
	<li><b></b> : </li>
	<li><b></b> : </li>
	<li><b></b> : </li>
	<li><b></b> : </li>
	<li><b></b> : </li>
	<li><b></b> : </li>
	<li><b></b> : </li>
</ol>

</p>

<h3></h3>
<p>

</p>






<!-- ###################################################################### -->

<a name="user-interface"></a> 
<h2>User interface</h2>

<h3></h3>
<p>

</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="tools"></a> 
<h2>Tools used here</h2>

<p>
All of them are free and open source. They have been used on GNU/Linux, but many of them are cross-platform.
</p>


<p>
<ul>

    <li><a href="http://www.gimp.org/" target="_blank">The Gimp</a> (<em>GNU Image Manipulation Program</em>), for most image exploratory manipulations</li>

    <li><a href="http://www.imagemagick.org" target="_blank">ImageMagick</a>, for powerful command-line bitmap manipulations, allowing to automate them through scripts that can handle the hundred of sprite frames to be transformed</li>
	
    <li><a href="http://www.coranac.com/category/proj/grit/" target="_blank">grit</a> (<em>GBA Raster Image Transmogrifier</em>), for conversion to the DS hardware formats and for tiling</li>
 
    <li><a href="http://osdl.sourceforge.net" target="_blank">OSDL</a>, our game library, to ease the develompent of our home-made converting tools</li>
 
<!--
    <li><a href="" target="_blank"></a></li>
-->

</ul>
</p>


<p>
<a href="http://www.coranac.com/tonc/text/toc.htm" target="_blank">TONC</a> has been a powerful documentary source to better target the Nintendo DS hardware and understand the various subtleties of tiled graphics.
</p>


  <br>
  <br>
  <br>
  <br>

 <h3>Please react !</h3>

  <p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, <a href="mailto:homebrew@esperide.com?subject=[OSDL]%20Graphical%20rendering%20for%20the%20DS">drop us a line</a>!</p><br>
  <br>
  <hr>
  <br>
 
  <center>
    [<a href="#_top_">Top</a>]
	<br>
    <br>
    <em>Last update: Friday, February 29, 2008</em>
  </center>
</body>
</html>
