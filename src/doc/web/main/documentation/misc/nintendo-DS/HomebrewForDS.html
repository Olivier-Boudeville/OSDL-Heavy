<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">

<!--    Ce document fait partie du projet OSDL.
		Pour toute remarque, envoyer un courriel à homebrew@esperide.com
-->
<!--    
        Date de création: Saturday, June 2, 2007.
        Auteur: Olivier Boudeville (homebrew@esperide.com)
        Version: 0.1
-->

<html lang="EN">
<head>
  <title>OSDL - A guide to homebrew development for the Nintendo DS</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="description" content="OSDL">
  <meta name="keywords" content="OSDL, installation, laptop, multiboot">
  <link rel="stylesheet" type="text/css" href="../../../../common/css/OSDL.css">
  <link href="../../../../images/OSDL-icon.png" rel="OSDL icon">
</head>

<body>
  
  <div class="banner">
  
    <p><em>General</em> <a href="../../../../common/black.html" onclick="parent.toolbar.location='../../../MainMenu.html'">home page</a>
    <a href="../../../Map.html">site map</a> <a href="mailto:homebrew@esperide.com?subject=[OSDL]%20Homebrew%20for%20Nintendo%20DS">mail us</a></p>
	
  </div><a name="_top_"></a>
  

<h1>A guide to homebrew development for the Nintendo DS</h1>


<a name="toc"></a>
<center>
	<table summary="Table of content" style="border: none">
        <tr>
          <td>
		<!--
		       <a href="#"></a><br>
		-->

		   <div class="box">
		       <a href="#overview">Overview</a><br>
		       <a href="#tobuy">What should be bought</a><br>
			   <ul>

		<!--
			<li><b></b>: </li>
		-->

					<li>The <a href="#buytheconsole">console</a></li>
					<li>Some recommended <a href="#accessories">accessories</a></li>
					<li>the <a href="#addons">add-ons</a> for homebrew development</li>
					
				</ul>
		       <a href="#inaction">The console in action, with and without its add-ons</a><br>
			   
		       <a href="#hardware">Hardware resources</a><br>
			   <ul>	   
					<li>The console <a href="#innerconsole">inner workings</a></li>
					<li>The <a href="#cartridges">cartridges</a></li>
				</ul>	
					   
		       <a href="#thirdparty">Using some third-party software</a><br>
			   <ul>
					<li>Understanding the various <a href="#romformats">ROM formats</a></li>
					<li><a href="#linkerstorage">Linker storage &amp; DLDI</a></li>
					<li>An example: <a href="#linuxonds">Linux on DS</a>
				</ul>		   
			   
		       <a href="#programmingDS">Programming the DS</a><br>
			   <ul>

					<li><a href="#understandinghardware">Using effectively the hardware</a><br>
			   		  <ul>
						<li><a href="#twocpu">Two</a> general-purpose CPU to handle</li>
						<ul>
							<li><a href="#intendeduse">Intended use &amp; performance</a></li>
							<li><a href="#registers">Registers</a></li>
							<li><a href="#cpuandmem">CPU &amp; Memory</a></li>
							<li><a href="#interrupts">Interrupts</a></li>
							<li><a href="#arm7role">ARM7 role</a></li>
							<li><a href="#arm9role">ARM9 role</a></li>
							<li><a href="#ipc">Inter-CPU communications</a></li>
						</ul>
											
						<li>Activating only the relevant <a href="#subsystems">subsystems</a></li>			
						<li><a href="#rendering">Rendering</li>
						<ul>
							<li><a href="#ingeneral">Rendering in general</a></li>
							<li><a href="#2D">2D Rendering</a></li>
							<li><a href="#3D">3D Rendering</a></li>
						</ul>
						<li><a href="#sound">Sound</a> input and output</li>
						<li><a href="#datastorage">Data storage</a> &amp; application ressources</li>
						<li><a href="#inputdevice">Input device</a> management</li>
						<li><a href="#wireless">Wireless</a> networking</li>	
						<li><a href="#miscellaneous">Miscellaneous</a></li>
					  </ul>	
					</li>

			   		<li>Gathering the <a href="#tools">adequate tools</a> for homebrew</li> 
					<ul>
						<li>the compiler toolchain, with <a href="#devkitarm">devkitARM</a>
						<li>the low-level library, <a href="#libnds">libnds</a>
						<li>a recommended FAT library, <a href="#libfat">libfat</a> 
						<li>a library to manage ROM-embedded filesystems, <a href="#libefs">libefs</a></li>
						<li>a useful library to manage Wifi, <a href="#dswifi">dswifi</a> 
						<li>an (optional) higher level library, <a href="#palib">PAlib</a></li>
					</ul>					
			   		<li><a href="#building">Building</a> your first DS program</li>
					<li><a href="#testing">Testing</a> your first DS program</li>
			   </ul>		   

		       <a href="#andnow">And now ?</a><br>		   
		       <a href="#otherinfos">Some other information sources</a><br>
		       <a href="#appendices">Appendices</a>
          </div>

          </td>
        </tr>
      </table>
</center>
<!--
<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>
  -->


  
<a name="overview"></a>
<h2>Overview</h2>

<p>
The goal here is to develop applications, mostly games, to be run on the <a href="http://en.wikipedia.org/wiki/Nintendo_DS" target="_blank">Nintendo DS</a>, from the hobbyist point of view, as opposed to a software/game production company. This kind of development is called <a href="http://en.wikipedia.org/wiki/Homebrew_(video_games)" target="_blank">homebrew</a>. 
</p>

<p>
We do not support piracy or the illegal use of the copyrighted Nintendo SDK by non-licensed developers. We use here unofficial development kits, such as <a href="http://www.devkitpro.org/" target="_blank">devkitPro</a>. These coding efforts are to remain free and legal.
</p>

<p>
This document is a guide rather than a tutorial or a reference book: somewhat in between these two kinds of writing, informations are thematically organized (instead of being introduced incrementally like in a tutorial) without aiming at the exhaustiveness of a reference source (such sources already exist, and links to them are provided). Only DS-specific knowledge is gathered here, the reader is expected to be already familiar with at least some form of programming.
</p>

<p>
Portable development will be kept in mind, as having one's game working both on a DS and on a PC is quite enjoyable. In this guide the C/C++ language will be favored. The development platform will be a standard PC, preferably using GNU/Linux.
</p>

<p>
Most of the informations here came from several homebrew websites (many thanks to Cearn for <a href="http://www.coranac.com/tonc/text/" target="_blank">TONC</a>, to <a href="http://www.dev-scene.com/NDS/Tutorials" target="_blank">Dovoto</a>, <a href="http://www.double.co.nz/nintendo_ds/" target="_blank">Chris Double</a> and <a href="http://www.palib.info/wiki/doku.php" target="_blank">Mollusk</a> for their respective tutorials) and from IRC discussions (notably, thanks to Wintermute [Dave Murphy] and <a href="http://www.akkit.org/sgstair/" target="_blank">sgstair</a> [Stephen Stair]). More generally, many thanks to the fearless homebrewers !
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="tobuy"></a> 
<h2>What should be bought</h2>


<a name="buytheconsole"></a> 
<h3>The console</h3>

<p>
First of course is the Nintendo DS itself (see a video <a href="http://www.youtube.com/watch?v=Xp7Be1qsblI" target="_blank">presentation</a>). It should be a DS <a href="http://en.wikipedia.org/wiki/Nintendo_DS_Lite" target="_blank">Lite</a>, which is quite superior to the previous "<a href="http://en.wikipedia.org/wiki/Nintendo_DS" target="_blank">fat</a>" version: better screens, thiner, lighter, better autonomy, more beautiful, etc. The color does not matter, but we found the black version quite sober, which opens it the possibility of somewhat faking a classical PDA. This is one of the intended uses in my case, besides game programming.
</p>

<p>
The main competitor for the DS would be Sony's <em>PlayStation Portable</em>, PSP, although they are quite different in price, capabilities and market shares. The lack of input device other than the gamepad, the quite low autonomy, the price and Sony policies make a lot of people favour DS over PSP, at least for the usage intended here (PDA and homebrew).
</p>

<p>
As most console manufacturers enforce a unique pricing for all vendors, choose the one with the better conditions (guarantee, return policy, etc.), preferably not online: dealing with real shops is convenient, especially to have one's DS replaced whenever there are dead pixels. This happens quite often apparently, and not all vendors accept easily to replace it. 
</p>

<p>
As for me, I bought my DS Lite in France, in a FNAC shop (I could cancel my buying during a 15-day period), in may 2007, for 150 euros, and had no dead pixel.
</p>

<p>
Here is the content of the Nintendo box:
<center>
    <a href="content.jpeg" target="_blank"><img src="content-small.jpeg" alt="Image" width="40%"></img><br>(click to enlarge)</a>
</center>

</p>

<p>This box includes only:
<ul>

<!--
	<li><b></b>: </li>
-->

	<li>the <b>DS Lite</b></li>
	<li>the <b>power supply</b> to charge the batteries</li>
	<li>some (rather useless) <b>documentation</b></li>
</ul>
</p>

<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>




<a name="accessories"></a>
<h3>Some recommended accessories</h3>

<p>
You can make a better use of your DS potential thanks to them.
</p>

<center>
    <a href="accessories.jpeg" target="_blank"><img src="accessories-small.jpeg" alt="Image" width="40%"></img><br>(click to enlarge)</a>
</center>
</p>

<p>
From the most useful to the least:

<ul>

<!--
	<li><b></b>: </li>
-->

	<li><b>screen protectors</b>, necessary at least for the touch screen, whose life duration would be quite low otherwise (note: beware to the way they should be applied, I screwed up the first protection, and the second, for the touch screen, trapped nasty micro-bubbles of air; no, the screens do not have the same exact dimensions !). A kind of fabric could help cleaning the screens and the console itself: finger prints are quite visible on it, especially on the black DS</li>
	
	<li>a <b>case</b> for transporting safely your DS. Mine is made of leather on purpose: wanting to look like a casual PDA</li>
	
	<li><b>replacement stylus</b>, in case you loose the only one provided (the smaller ones are for the "fat" DS)</li>

	<li><b>car power supply</b>: well, why not...</li>

	<li>specific <b>headphones</b> are quite useless, as the DS uses standard 3.5 jack. Would be interesting only if they included a microphone (seems to be a proprietary plug for audio input)</li>

	<li><b>game stylus</b>, to be placed on the user thumb. Not helpful here, they are mostly for gaming usage</li>
	
	<li><b>boxes for game cartridges</b>. Useless here since the DS is bought only to program it. The "razor and blades" business model (some consoles being sold at loss) does not work well with homebrewers</li>

</ul>

</p>

<p>
I bought a Bigben Interactive pack of 5 accessories (6 euros) and a (black) Subsonic Premium Pack (mostly for the leather case; 15 euros), both of course for DS Lite. Hence one can have all these recommended accessories for quite a low price.
</p>

<p>
See also the Wikipedia <a href="http://en.wikipedia.org/wiki/Nintendo_DS_accessories" target="_blank">article</a> about DS accessories.
</p>

<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>



<a name="addons"></a>
<h3>The necessary add-ons for homebrew development</h3>

<h4>Needing a console that can be programmed</h4>
<p>
Having a basic console is not enough to be able to program it: Nintendo, probably due to the fear of piracy, preferred to make the life of homebrewers more difficult than technically needed, notably thanks to hardened firmwares preventing modifications or execution of non-acknowledged code. For example, Wifi demos are apparently protected by a RSA check (at least parts of them are encrypted with a private key from Nintendo), and the DS uses the embedded public key to decipher these demos before running them.
</p>

<p>
Hence, to have access to a DS that can be programmed, one has to circumvent these protections. One of the simplest ways of doing so is to use special game-like cards, at least once. This is a vast subject and many cases have to be taken into account, see <a href="http://en.wikipedia.org/wiki/Nintendo_DS_booting_tools" target="_blank">Booting Tools</a> on Wikipedia for details.
</p>
  
  
<h4>A rather cheap and easy solution</h4>

<p>
As the DS is not sold with a rewritable storage medium or anything like it (no standard card reader, no USB port, etc.), some specific device is required so that the DS can load homebrew applications. Though one could instead use <a href="http://en.wikipedia.org/wiki/Wireless_Multiboot" target="_blank">WMB</a> (<em>Wireless Multiboot</em>), which is a method to send programs to be run on the DS using a PC with specific Wi-Fi adaptors, this method would not be convenient enough: transferred content would be lost on the DS as soon as it is powered off, a Ralink-compatible Wifi adaptor would be required, the sent applications could not occupy more than 4 megabytes, a hacked firmware would be needed, etc.
</p>

<p>
As for me, I intended to have Linux working on my DS, and for that the native 4 megabytes of RAM where quite small, so I wanted to have both 32 megabytes of additional RAM (the maximum size that can be addressed by the related DS bus) and access to <a href="http://en.wikipedia.org/wiki/Nintendo_DS_storage_devices" target="_blank">mass storage</a> on removable media. 
</p>

<p>
The best and simplest bet for me was to use, in the slot-1 (the DS-specific one, small and at the top of the console, a.k.a the DS card), a <a href="http://eng.supercard.cn/products.htm" target="_blank">SuperKey</a> (a kind of <a href="http://en.wikipedia.org/wiki/NoPass" target="_blank">NoPass</a>) as a fake game used to enable the execution of code from the slot-2 (the big one at the bottom, used for <em>Game Boy Advance</em> compatibility, a.k.a. the GBA cartridge). This slot-2 would host a <a href="http://eng.supercard.cn/products.htm" target="_blank">SuperCard Lite</a> (note: avoid the rumble series, it does not provide more RAM) which, besides the 32 megabytes of RAM, offers a <b>microSD</b> port. It is micro indeed (not mini), and SD stands for <em>Secure Digital</em>.</p>

<p>
Homebrewers not interested in running Linux on their DS and searching a cheap and well-supported solution may choose the <a href="http://en.wikipedia.org/wiki/Nintendo_DS_storage_devices#R4DS_.26_M3_DS_Simply" target="_blank">R4DS</a>, a slot-1 linker, using also microSD cards. 
</p>

<p>
I bought both the SuperKey and the SuperCard Lite (black version) from <a href="http://www.fl-games.com/" target="_blank">FL-games</a> for 65 euros (shipping included) and was quite happy of the cards (no compatibility issue between the two cards to be afraid of) and of the store. I would not say the same of another french store I tried.
</p>


<a name="electrobee"></a>
<p>
On this subject, although we are not affiliated in any way with them and (for the moment) we never bought from them (we heard of them too late), we would recommend nevertheless <a href="http://www.electrobee.com/" target="_blank">electrobee</a>, a small Canadian store run by <a href="http://www.natrium42.com/" target="_blank">Natrium42</a>, as their prices and reputation are good, and also because Natrium42 contributed a lot to the DS homebrew community, especially regarding hardware add-ons.
</p>


<p>
Here are the three boxes, for the Nintendo DS Lite, for the SuperKey and for the SuperCard. Note the two-euro coin: they are quite small indeed.

<center>
    <a href="boxes.jpeg" target="_blank"><img src="boxes-small.jpeg" alt="Image" width="40%"></img><br>(click to enlarge)</a>
</center>
</p>
 
<p>
Here is a view of a bare DS running the default firmware (hence the mandatory health and safety warning) and, below, the quite tiny SuperKey and SuperCarde Lite themselves:

<center>
    <a href="warning.jpeg" target="_blank"><img src="warning-small.jpeg" alt="Image" width="40%"></img><br>(click to enlarge)</a>
</center>
</p>

 
<p>
Last but not least, one should have one micro-SD card at least, I bought a 2 gigabytes Kingston one from <a href="http://www.pc-look.com/" target="_blank">PC-look</a> for 28 euros, shipping included. My laptop had a SD reader/writer (well, Ubuntu could not use it properly but it is another story), so there was no real need to buy anything else. Separate USB reader/writer are quite inexpensive anyway, and it is hard to buy a R4DS with no such card reader/writer included. Check that your micro-SD card is sold with a SD adapter, so that the actual tiny micro-card can fit in a basic SD reader. 
</p>

<p>
To use your micro-SD, you should first format it in <b>FAT</b> (i.e. FAT16, not FAT32), as factory settings are not reliable in all cases, or are not the expected ones. Formatting can be done both from Windows or from Linux (see our <a href="#fatformatting">FAT-dedicated section</a>).
</p>

<p>
FAT is for the moment favored over other filesystems by most homebrewers, mainly because it is adequate for small size storage media, and for the sake of simplicity: there already exists a library for it on the DS, <a href="#libfat">libfat</a>.
</p>

<p>
Finally, in my case, the full equipment cost only 265 euros.
</p>

<p>
An alternative setup to the SuperKey/SuperCard is to use the <a href="http://en.wikipedia.org/wiki/R4_D" target="_blank">R4DS</a> linker:

<center>
    <a href="R4DS.jpeg" target="_blank"><img src="R4DS-small.jpeg" alt="Image" width="40%"></img><br>(click to enlarge)</a>
</center>

The package is composed of a mini-CD, the R4DS itself in a kind of blueish key ring, and a very nifty USB 2.0 microSD card reader (no need for SD adaptor). This package costs about 35 euros (cheaper than the SuperKey+SuperCard pair) and is very useful when having problems with the SD support on Linux, thanks to the USB interface. A drawback is that the R4DS, being slot-1, will not provide additional RAM to applications such as DSLinux, whereas the SuperCard does.
</p>




<a name="limitations"></a>
<h4>Some limitations for the seasoned homebrewer though: transferring files to the DS</h4>

<p>
Such removable media (as microSD) are not the magic bullet for the frantic homebrewer: to anticipate a bit on further subjects, when generating programs for the DS from your PC, to test them you may either execute them "in place", directly on your PC thanks to <a href="#emulators">DS emulators</a> (but they do not behave always as a DS would behave) or you have to send them to the DS, one way or another. This can be done thanks to the aforementioned microSD card, but it soon becomes tedious to swap again and again the card and its adapter. 
</p>

<p>
An alternate way would be to use a Wifi access point or a Wifi router, preferably not a mere Wifi adapter, which would have to embedded a specific chip etc. in order to work with the DS. Such devices could be for example the famous <a href="http://en.wikipedia.org/wiki/WRT54G" target="_blank">Linksys WRT54G routers</a> (55 euros approximately) or <a href="http://en.wikipedia.org/wiki/Fonera" target="_blank">La Fonera</a>, both of which are inexpensive and, on a side node, run Linux, whose firmware and software can be programmed, etc., in a very similar way to the one we are to program applications for the DS. Note this may involve running specific software on the DS (ex: DSLinux) to transfer ROM wirelessly, which may or may not be more convenient than the basic card swap.
</p>

<p>
Other still less usual methods would be to rely on:
<ul>

<!--
	<li><b></b>: </li>
-->

	<li>a <b>parallel-port cable</b>:  you can open your DS, solder about 10 points to the motherboard, and get a parallel-port cable. But that's quite a lot of work</li>

	<li>the <a href="http://natrium42.com/blog/?p=38" target="_blank">dserial</a> ($45+shipping)</li>

	<li>the <b>DS-Xtreme</b>, although the device is often considered overpriced and subject to reliability issues, or the <b>DS Linker 8G / 16G</b>, released by the Supercard team. Note it is unclear whether the USB cable has to be unplugged so that either the PC or the DS gains access to the card memory (in that case it would remove the main advantage of these cards over the microSD-based ones).</li>
	
</ul>

<p>
Finally, using a USB reader/writer like the one provided with the R4DS is probably one of the best solutions.
</p>


<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>


 
<a name="inaction"></a>
<h2>The console in action, with and without its add-ons</h2>

<p>
The snapshot below shows the official main screen:  
<center>
    <a href="pictochat.jpeg" target="_blank"><img src="pictochat-small.jpeg" alt="Image" width="40%"></img><br>(click to enlarge)</a>
</center>
</p>

<p>
What happens when the cards are inserted ? Both ought to be used: if only the slot-1 one (SuperKey) is inserted, you will have two white screens, and if only the slot-2 one (SuperCard) is active, then your DS will run in backward compatibility mode for the GBA. 
</p>

<p>
When both cards are inserted, you can see the SuperCard splash screen, but here one could not go further, as the microSD card was not inserted. See it in its case, on the right, the SD adapter being on the left. The SuperCard-like black object below the DS is just the default plastic filler to protect the console from dust.
<center>
    <a href="supercard-run.jpeg" target="_blank"><img src="supercard-run-small.jpeg" alt="Image" width="40%"></img><br>(click to enlarge)</a>
</center>
</p>

<p>
Inserting the microSD card and rebooting is not really interesting, as this card  is still empty.
</p>

<p>
We see nevertheless that our customized console works well and is almost ready to be used. Last step may be to upgrade the Supercard firmware, to benefit from improvements whose interest should be evaluated beforehand (beware to regressions though, check the assessment of other users first). To upgrade the firmware, download its targeted version from the <a href="http://eng.supercard.cn/soft_scl.htm" target="_blank">official site</a> (ex: <code>microsd_eng_181.rar</code>, for the 1.81 version), extract it with <code>unrar</code> (installed with <code>apt-get install unrar</code>) thanks to <code>unrar e microsd_eng_181.rar</code>. Put the result (<code>my_micro_eng_181.bin</code>) at the root of, here, your microSD card, before booting the DS with it. Then the firmware should be upgraded by selecting this file in the Supercard menu, and pressing the A key. 
</p>

 <p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>

 
 
 
 
<a name="hardware"></a> 
<h2>Hardware resources</h2>

<p>
Buying things was quite easy. Now, let's try to use them ! First of all, let's learn what is available for our developments.
</p>


<a name="innerconsole"></a>
<h3>The console inner workings</h3>
<p>
Even though Nintendo designed a low-cost handheld, the DS offers quite a lot of features:
<ul>

<!--
	<li><b></b>: </li>
-->

	<li><b>two TFT back-lighted screens</b> (hence the DS meaning <em>Dual Screen</em>, although <em>Developer System</em> is mentioned sometimes), whose maximal resolution is 256x192 each, with up to 260 000 colors (5 bit for each channel). These are 3-inch screens (61x46 mm), with a dot pitch of 0,24 mm (contrast is 162:1). Screens are separated by about 21 mm. The DS Lite ones are far brighter and more enduring than the DS "fat" ones, and support four levels of brightness</li>
	
	<li>a resistive <b>touchpad</b> integrated with the bottom screen. The resulting touchscreen can be used with a stylus, the user's finger, wrist strap, etc. It can measure at most one press at a time, so it will average multiple presses, by reporting only a single one at their barycenter</li>
	
	<li>
	<p>

	<b>two all-purpose processors (CPU)</b>:
	  <ul>
		<li>an <b>ARM9</b>: <a href="http://en.wikipedia.org/wiki/ARM9E" target="_blank">ARM946E-S</a>, the main CPU, 67 MHz, between 200 and 300 MIPS (<em>Million Instructions Per Second</em>), RISC 32 bit</li>
		<li>an <b>ARM7</b>: <a href="http://en.wikipedia.org/wiki/ARM7TDMI" target="_blank">ARM7TDMI</a>, a co-processor, 33 MHz, about 20 MIPS, 16-bit/32-bit RISC</li>
	  </ul>
	</p>

	<p>
	Both can be running code at the same time. 
	</p>

	<p>
	The ARM (<em>Arcos Risc Machine</em>) family is quite widespread on embedded devices, and is known to be small, cheap and power-savvy. The Nintendo 64 offered roughly 100 MIPS, PlayStation 2 and PSP (PlayStation Portable) roughly 560 MIPS, GameCube 980 MIPS. According to some sources, the DS processors are under-clocked to save some power. Some people <a href="http://youtube.com/watch?v=PYIvASbELkw" target="_blank">overclocked</a> them, which involves quite some electronical skills and risks</p>
	</li>
	
	<li>several <b>memory banks</b>, notably 4 megabytes (4096 kilobytes) of built-in RAM, whose layout is somewhat complex but for the most part is shared by the two processors. There is an additional 656 kilobytes of video RAM, and some non-volatile memory dedicated to user preferences. See the excellent <a href="http://www.dev-scene.com/NDS/Tutorials_Day_2#Memory_Layout" target="_blank">memory layout</a> diagram from Dev-Scene website</li>
	
	<li>one GPU (<em>Graphical Processing Unit</em>) made of two <b>advanced 2D rendering systems</b> (one for each screen) and a <b>3D rendering system</b>, able to offer various <a href="#3D">3D features</a>. It can render up to 120 000 triangles per second at 60 frames per second, a fill rate of about 30 million pixels per second. This is a completely custom chip integrated in the same chip as both ARM. It is <b>not</b>, sadly, the PowerVR MBX that was announced by some <a href="http://portables.p-nintendo.com/articles/D-232-1.html" target="_blank">sources</a></li>

	<li>A <b>flashable</b> <a href="http://en.wikipedia.org/wiki/Firmware" target="_blank">firmware</a>, on NVRAM (<em>Non-Volatile RAM</em>). Alternative custom firmwares allow to run homebrew executables sent thanks to Wifi, as if they were officially signed. Upgrading the firmware is an easy and relatively safe process now</li>
	
	<li>A <b>gamepad</b> (four-direction keys), with <b>6 bigger buttons</b> (X, Y, A, B in a cross layout; L and R on the far side of the DS) and <b>two smaller</b> (Start and Select)</li>
	
	<li>integrated <b>wireless networking</b>, able to offer proprietary protocol (called <em>NiFi</em>, for Nintendo Wifi) and 802.11b Wifi connectivity, respectively for local exchanges between DS and communications through the Internet (range between 10 and 30 meters)</li>
	
	<li>a <b>16 hardware channel sound output</b> with stereo speakers (whose quality is rather good) and standard headphone plug (3.5 mm jack). A sliding button allows to set the volume. DAC runs at 10-bit 32768 Hz, stereo</li>
	
	<li>a <b>microphone</b> for sound input, which allows (application-specific) speech-recognition</li>
	
	<li>two <b>slots for FLASH cards</b>: the Slot-1 (DS specific, looking a bit like a small Compact Flash card, currently up to 256 MB of internal storage) and the Slot-2 (legacy GBA port, used by several add-ons, including so-called Pak, flash carts, etc.)</li>
	
	<li><b>lithium-ion battery</b> (1000 mAh battery, whereas the DS "fat" has 850 mAh): with a DS Lite in DS mode, depending on the screen brightness, at least 6 to 10 hours of play, in GBA mode up to 12 hours, in sleep mode at least a few days, all when starting from a fully charge battery (4 hours of charge). Of course autonomy decreases with slot-1/slot-2 cards being added. After five hundred charges, the battery capacity drops to about seventy percent and should be replaced</li>
	
	<li><b>small form factor</b>: the (closed) DS Lite is 133 mm × 73.9 mm × 21.5 mm (versus 148,6 x 84,6 x 28,7 mm for the DS "fat"), for 218g (275g for the DS "fat")</li>

	<li><b>built-in realtime 33 MHz clock</b>, maintaining time and date even when the DS has been switched off</li>

	<li><b>two green/orange/red LEDs</b> are available, they can be seen both when the console is open or closed. By default they inform about the Wifi and the battery status</li>
		
</ul>
</p>

<p>
The overall architecture (including the ARM, the rendering engine, the keys, etc.) took as a starting point the one of the <em>GameBoy Advance</em>. Both have an ARM7 (but the DS one is running at 33 MHz instead of 17 MHz), explaining partly the very good retrocompatibility of DS for GBA. More generally the DS hardware is quite close to the one of PocketPC devices. The performances are expected to be somewhat near the Nintendo 64 ones.
</p>


<a name="detailedhardware"></a>
<p>
More low-level informations about the DS hardware: 

<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->
	
	<li><a href="http://neimod.com/dstek/" target="_blank">DS Tek</a></li>
	<li><a href="http://nocash.emubase.de/gbatek.htm" target="_blank">GBATEK</a></li>
	<li><a href="http://auia.net/ds/" target="_blank">NDSTech</a></li>
	<li><a href="http://www.dev-scene.com/NDS/Tutorials_Day_2" target="_blank">Dev-Scene tutorial</a></li>
	<li><a href="http://dualis.1emu.net/dsti.html" target="_blank">Dualis</a> hardware section</li>

</ul>
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br>



<a name="cartridges"></a>
<h3>The cartridges</h3>
<p>
There are two different ports in which cards can be inserted: Slot-1 and Slot-2. In both cases, cards are mostly <a href="p://en.wikipedia.org/wiki/Read-only_memory" target="_blank">ROM</a>, but some of them have a small amount of non-volatile memory, usually <a href="http://en.wikipedia.org/wiki/EEPROM" target="_blank">EEPROM</a> (notably <a href="http://en.wikipedia.org/wiki/Flash_memory" target="_blank">Flash</a> memory), to save some data (highscores, game saved, etc.).
</p>

<h4>The Slot-1 port (a.k.a. DS port)</h4>

<p>
Usual DS game cards are 33.0 × 35.0 × 3.8 mm, and weigh around 3,5 g. They can contain up to 128 megabytes, but in this case their transfer rates are smaller than the ones of 64-megabyte cards. 
</p>

<p>
SuperKey and the other Slot-1 <a href="http://en.wikipedia.org/wiki/NoPass" target="_blank">NoPass</a> counterparts, apart from allowing the use of the Slot-2 devices, do not add any memory or feature. They just set the program counter so that it points to a memory location in the GBA slot, allowing programs to be run from storage there. They consume some power that reduces the console autonomy. A <a href="http://en.wikipedia.org/wiki/Flashme" target="_blank">flashed</a> firmware can be used instead, for the most daring.
</p>


<h4>The Slot-2 port (a.k.a. GBA cart, or Flash Cart)</h4>

<p>
There are several slot-2 add-ons (called <em>linkers</em>), which all provide their own set of features. From the ARM9 point of view, they can offer up to 32 megabytes of additional ROM (which can be actually RAM) and up to 64 kilobytes of <a href="http://en.wikipedia.org/wiki/Static_random_access_memory" target="_blank">SRAM</a>, intended for game saves, preferences, etc.. Any other storage these cards may include cannot be seen directly by the ARMs.
</p>

<p>
Therefore these slot-2 linkers use their built-in RAM as a mock flash cartridge, i.e. as a cache fed from their hidden mass storage. There are various systems that upload in the ARM-visible 32-megabyte address space any desired chunk from any hidden mass storage. Some DS homebrew (ex: DSLinux) also use this additional RAM, though bus and speed issues make it less useful than the DS built-in memory.
</p>

<p>
More precisely, the GBA slot bus only supports 16-bit writes, which leads to issues when needing to perform 8-bit only write operations. As for speed, some people complained about Supercard's built-in RAM or some versions of microSD cards being too slow for some GBA games.
</p>

<p>
The SuperCard Lite is one of the most interesting linkers, as it fits well in the GBA port (it does not protrude when inserted in a DS Lite) and provides both the optimal 32 megabytes of RAM and an access to removable storage, here a microSD card.
</p>


<a name="fatformatting"></a>
<p>
Most of these removable cards are formatted in <a href="http://en.wikipedia.org/wiki/File_Allocation_Table" target="_blank">FAT</a> (i.e. FAT16, not FAT32), which implies that no more than 2 gigabytes can be managed. Some linkers, like the R4DS / M3 Simply, may use FAT32 and take advantage of 4-gigabyte cards. Some other linkers are discussed in this <a href="http://www.palib.info/wiki/doku.php?id=day1#putting_the_homebrew_on_the_ds" target="_blank">PAlib</a> tutorial 
</p>

<p>
Note that a supposed work-around for a DSLinux bug would require making partitions strictly smaller than 2 gigabytes. This can be done from a PC running GNU/Linux thanks to, for example, <code>fdisk /dev/mmcblk0</code>, then deleting previous partition (<code>d</code>), creating two new primary partitions (1 and 2), first with only 1020 megabytes, the second with the rest of the space, then setting them to FAT16 (<code>t</code> option, with value <code>6</code> for filesystem type). You should then have partitions like:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
Disk /dev/mmcblk0: 2000 MB, 2000683008 bytes
10 heads, 9 sectors/track, 43417 cylinders
Units = cylinders of 90 * 512 = 46080 bytes

        Device Boot      Start         End      Blocks   Id  System
/dev/mmcblk0p1               1       22136      996115+   6  FAT16
/dev/mmcblk0p2           22137       43417      957645    6  FAT16
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
Finally both filesystems have to be created, thanks to, for example, <code>mkdosfs -c -F 16 -n DS-homebrew -v /dev/mmcblk0p1</code> and <code>mkdosfs -c -F 16 -n DS-storage -v /dev/mmcblk0p2</code>. Using <code>pmount</code> and <code>udev</code> allows to mount these filesystems without needing a root access.
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>






<a name="thirdparty"></a>
<h2>Using some third-party software</h2>

<p>
Software distribution on the DS is mostly based on ROM images, which can be downloaded on a PC as unique files. These files are read by the DS system, which see them as a kind of archive (a filesystem actually) containing possibly numerous files and directories.
</p>

<p>
Note that there are often more than one filesystem involved here: 
<ul>
        <li>first there is the filesystem used by the <b>linker</b>, which allows to manage as individual files the various ROM transferred in the linker mass storage</li>
        <li>then there are the filesystems potentially used internally by these <b>ROM</b>: each ROM may organize its data in a set of files, in its own inner file hierarchy</li>
</ul>
Different ROM may use different filesystem types, depending on various choices including the ROM format, as stated below.
</p>



<a name="romformats"></a>
<h3>Understanding the various ROM formats</h3>

<p>
There are several file extensions for Nintendo ROM. Each extension has a <a href="http://www.ndshb.com/modules.php?name=Content&pa=showpage&pid=27" target="_blank">specific meaning</a>, is associated to a specific executable format, and must be chosen adequately.
</p>

<p>
The sole purpose of ROM is to contain binaries (i.e. executables) for the two ARMs and, most often, application-specific data (icons, bitmaps, sounds, etc.), stored either as a unique flat file or as full filesystems, in one or more files, each filesystem containing in turn files and directories. Usually there is at most one filesystem. To be run from the GBA cart (slot-2), these ROM should include a loader that transfers them to the RAM.
</p>


<h4>Known formats &amp; extensions</h4>

<p>
The most frequent extensions are:
<ul>

<!--
	<li><b></b>: </li>
-->

	<li>
	<p><b>.nds</b> (ex: <code>myGame.nds</code>): 
	
	this binary for the DS (slot-1) is used by official game cards and most emulators. It embeds a small header referring to a logo, a short description of the ROM content in several languages, followed eventually by the two executable binaries needed (a region dedicated to the ARM7, then a region dedicated to the ARM9), and optionally some appended data, for example a filesystem. The logo and description texts are used when booting a game card from the firmware, or when starting to download one over wireless multiboot: GBA Movie Player and the FlashMe + WMB method support .nds files.
	</p>

	<p>	
	This file format was primarily designed to be run from RAM filled from the slot-1 (ex: M3 and DS-X), hence it did not need any specific loader. Therefore old generation .nds do not have a loader at all, and an external one must be used when run from the GBA port. This loader is generally provided by the menu loader of the flash cart device.</p>
	
	<p>Some newer .nds to be run from the GBA cart put nevertheless a loader (often <code>ndsloader.bin</code>, see our dedicated <a href="#loader">section</a>), which they store into some unused space of the header. Sadly, many GBA flashers mess up the NDS header, thinking it is a corrupted GBA header. An external loader is then needed again
	</p>
	
	</li>
	
	<li><b>.ds.gba</b> (ex: <code>myGame.ds.gba</code>): this binary for the DS is designed to run from GBA ROM. It is usually made of a small loader (to transfer thanks to the ARM7 the ROM content from the GBA card to the main RAM) contained in a 512-byte (GBA) header, then a .nds file, and zero or more appended data files. The code from the .nds accesses the appended data files thanks to reads from GBA ROM space. GBA flash carts, M3, and SuperCard support this. Some linkers may require the ROM to be renamed to .ds.nds</li>
	
	<li><b>.gba.nds</b>: the SuperCard firmware seems to believe that the .ds.gba format is indicated by the .nds extension. Hence to run a .ds.gba program on a SuperCard, one has to rename it first so that its extension becomes .nds. However by doing so one could mix it up with real .nds. One work-around is then to rename that program with, for example, a .gba.nds extension, instead of a mere .nds. However for a SuperCard, an original <code>myGame.ds.gba</code> could be renamed preferably to <code>myGame.sc.nds</code> (see below)</li>

	<li><b>.sc.nds</b>: extension to be used with SuperCard (sc) and, in some cases, G6 lite and M3. This is a renamed .ds.gba, and maybe it is DLDI-patched too, see below. The .sc.nds extension is a better (since clearer) alternative to the ds.gba one</li>
	
</ul>
</p>

	
<p>
Some quite uncommon formats and extensions are:
<ul>

<!--
	<li><b></b>: </li>
-->
	
	
	<li><b>.srl</b>: also called <em>clean dump</em>, it is a dump of commercial ROM, made of a .nds file and an appended file system, usually in Nitro-FAT format. The code in the .nds file reads from the appended file system, using block transfers, through the DS game card access registers. Homebrew tools do not generate .srl, and WMB does not support them. These clean dumps are sometimes distributed as .nds ROM, because they use the same header</li>
	
	<li><b>_BOOT_MP.nds</b>: the GBAMP (<em>GBA Movie Player</em>) will boot automatically on this file</li> 
	 
</ul>
</p>


<h4>Conversions between ROM formats</h4>

<a name="loader"></a>
<p>
.nds programs can be converted into ds.gba programs, i.e. ROM designed to run from slot-1 may run from slot-2. It involves prepending a loader, which may load the first appended .nds file, or allow selection of one of the .nds files.
</p>

<p>The loader can be <a href="http://l33t.spod.org/ratx/DS/dslazy/dslazy.zip" target="_blank">ndsloader.bin</a>, which could be prepended that way:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
On <b>Windows</b>:
copy /b ndsloader.bin &lt;the .nds file to convert&gt; &lt;the resulting merged file&gt; 

For example:
copy /b ndsloader.bin myGame.nds myGame.ds.gba

On <b>Linux</b>:
cat ndsloader.bin &lt;the .nds file to convert&gt; &gt; &lt;the resulting merged file&gt; 

For example:
cat ndsloader.bin myGame.nds > myGame.ds.gba
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
The other way round (from ds.gba to .nds, i.e. from slot-2 to slot-1) usually cannot be performed if not already done by the author, because most often the application relies on specific data meant to be embedded, which is not supported with a .nds file.
</p>

<p>
There are some tools, such as the <a href="http://l33t.spod.org/ratx/DS/SC/scmhbp/" target="_blank">Supercard Magic Homebrew Patcher</a>, that turns your .nds / .ds.gba files into a fixed supercard .sc.nds file. 
</p>

<p>Finally, most of the recent FAT-based homebrew applications need to be patched according to the relevant DLDI script, before being run. See next section.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="linkerstorage"></a>
<h3>Linker storage and DLDI</h3>

<p>
Before rushing for the numerous homebrew softwares available on the Internet, one must understand the problem encountered with the various linkers, be them slot-1 or slot-2. This section therefore applies mostly to the ROM using the .ds.gba format, including .gba.nds and .sc.nds. 
</p>

<p>
As each linker offers its own memory interface (the way it writes to its Flash memory), as soon as an application has to access to a memory provided by the linker, the homebrew has to be aware of the specific linker it will run with. Several solutions exist: the developer may build as many versions of his software as there are supported linkers (it becomes soon tedious and messy), or the end-user may use Chishm's DLDI, for FAT-based applications.
</p>

<p>
<a href="http://dldi.drunkencoders.com/" target="_blank">DLDI</a> stands for <em>Dynamically Linked Device Interface for libfat</em>. The DLDI-aware software can be storage-agnostic. It has just to be built once, and patched according to the target linker it is to run with, before being transferred to the DS.
</p>

<p>
The point is that it is quite easy for the user to patch the software, and it frees the developer from having to take into account each and every linker variation on the market. Even linkers released years after one's software will be supported thanks to DLDI, with no additional efforts from the original author.
</p>

<p>
DLDI is needed whenever libfat versions more recent than Christmas 2006 are being used.
</p>


<a name="dldiexample"></a>
<p>
In practice, the user will need:
<ul>

<!--
	<li><b></b>: </li>
-->

	<li>the target <b>DLDI-enabled software (ROM) to patch</b> (of course)</li>
	<li>a <b>patching tool</b>: the command-line or GUI <a href="http://dldi.drunkencoders.com/index.php?title=Category:Tools" target="_blank">dlditool</a>, available for Windows, <a href="http://dldi.drunkencoders.com/uploads/a/ab/Dlditool-linux-x86.zip" target="_blank">Linux</a> and Mac OS X</li>
	<li>the <b>device-specific patch file</b> which corresponds to his linker (see <a href="http://dldi.drunkencoders.com/index.php?title=Category:Devices" target="_blank">DLDI Device patches</a>, including the one for <a href="http://dldi.drunkencoders.com/index.php?title=SuperCard_Lite_%28SD_Card%29" target="_blank">SuperCard Lite (SD Card)</a>)</li>
</ul>

</p>

<p>
Our LOANI script can take in charge everything needed to use directly the DLDI tool on a Linux platform, see <a href="#loani">below</a>. Otherwise Linux users just have to put the dlditool archive (here <code>dlditool-belowlinux-x86.zip</code>) and the device-specific patch file (here <code>sclt.dldi</code>) in a new directory and prepare them. For example:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
mkdir ~/dldi
mv ~/dlditool-linux-x86.zip ~/sclt.dldi ~/dldi
cd ~/dldi
unzip dlditool-linux-x86.zip
chmod +x dlditool
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
One just has then to use the DLDI tool to patch the software (here <code> myGame.nds</code>) according to its linker-specific patching specification: <code>./dlditool sclt.dldi myGame.nds</code> for example. Check that the tools returned that the operation was successfully performed. The patched ROM can then be used at once.
</p>

<p>
Another option for Windows users is to install <a href="http://psychowood.altervista.org/getDLDIrc.html" target="_blank">DLDIrc</a>, which is configured once for all with a target linker and adds to the contextual menus for each selected DS ROM (the menu obtained with the right-click) the possibility to patch it.
</p>

<p>
More information about DLDI: read this <a href="http://www.dev-scene.com/NDS/Libfat_DLDI" target="_blank">section</a> on Dev-Scene.
</p>

<p>
Finally, some homebrew make use of the SRAM (actually, a non-volatile RAM) that may be provided by a flash cartridge.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="linuxonds"></a> 
<h3>An example: Linux on DS</h3>

<p>
Even though most DS applications are to be run standalone (i.e. by themselves, not using any other specific operating system), one can nonetheless have its DS run a dedicated <a href="http://en.wikipedia.org/wiki/Operating_system" target="_blank">operating system</a> (OS). Beyond the fun experience, it may allow for multitasking, or may just provide an environment familiar to the user, with useful tools and interfaces.
</p>

<p>
Should an OS be used, it will have to be executed as any other DS application. This OS will then be able itself to run the applications it is hosting. They may even run simultaneously, if the OS supports multitasking and if it does not monopolize for its own purpose too much the DS resources, not letting enough CPU or RAM for the hosted applications.  
</p>

<p>
Among all other operating systems, homebrewers often favor <a href="http://en.wikipedia.org/wiki/Linux" target="_blank">Linux</a>.
</p>

<p>
On the DS, this OS is provided thanks to <a href="http://en.wikipedia.org/wiki/DSLinux" target="_blank">DSLinux</a>, based on <a href="http://en.wikipedia.org/wiki/UClinux" target="_blank">uClinux</a>.
</p>

<p>
It can be <a href="http://kineox.free.fr/DS/" target="_blank">installed</a> quite easily:
<ol>
<!--
	<li><b></b>: </li>
-->
	<li><b>download</b> <a href="http://kineox.free.fr/DS/dslinux-dldi.tgz" target="_blank">dslinux-dldi.tgz</a> on your computer
 </li>
	<li><b>extract</b> it in a new directory</li>
	<li><b>patch</b> the extracted <code>dslinux.nds</code> with the adequate DLDI device patch (refer to our DLDI <a href="#dldiexample">nano-guide</a>)</li>
	<li><b>copy</b> the full directory content (i.e. <code>dslinux.nds</code> and the <code>linux</code> directory extracted from the archive, including its own content) at the root of your SD card</li>
	<li><b>reboot your DS</b>, select Linux and enjoy</li>
</ol>
 
</p>

<p>
See DSLinux running, with the virtual stylus-based keyboard on the bottom screen:
<center>
    <a href="linux-global.jpeg" target="_blank"><img src="linux-global-small.jpeg" alt="Image" width="40%"></img><br>(click to enlarge)</a>
</center>
</p>

<p>
The terminal output is on the top screen:
<center>
    <a href="linux-zoom.jpeg" target="_blank"><img src="linux-zoom-small.jpeg" alt="Image" width="40%"></img><br>(click to enlarge)</a>
</center>

</p>

<p>
See also:
<ul>
<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://dslinux.org/" target="_blank">DS Linux Official WebSite</a>, including its <a href="http://dslinux.org/?page=faq" target="_blank">FAQ</a></li>
	
    <li><a href="http://en.wikipedia.org/wiki/DSLinux" target="_blank">DS Linux on Wikipedia</a></li>
	
    <li><a href="http://www.debian.org/ports/arm/" target="_blank">ARM-dedicated Debian build</a></li>
	
    <li><a href="http://popcon.debian.org/" target="_blank">Popularity contest</a> for architectures supported by Debian (see ARM)</li>

</ul>
 
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>





<a name="programmingDS"></a>
<h2>Programming the DS</h2>

<p>
Programming the DS is quite fun because it is rather down to the metal: being that close to the hardware, with no operating system, no drivers, no hardware incompatibilities (well, until we look at the flash carts) to take into account is a good pretext indeed to struggle against low level details. It is probably a very good way to practise embedded developments as well. Not to mention that having one's own programs working on a console is quite satisfactory.
</p>


<a name="understandinghardware"></a>
<h3>Understanding the hardware</h3>

<a name="twocpu"></a>
<h4>Two general-purpose CPU to handle</h4>

<p>
ARM CPU are RISC (<em>Reduced Instruction Set Computer</em>) processors, as opposed to CISC processors (<em>Complex Instruction Set Computer</em>). Most ARM instructions are expected to be executed in one clock cycle, thanks to a simpler and constant structure. 
</p>


<a name="intendeduse"></a>
<h5>Intended use &amp; performance</h5>

<p>
For newcomers, one of the most disturbing specificities of the DS is its having multiple processors. They are expected to share the load: even if both ARM are rather general-purpose, the ARM9 should take care of most computation-intensive tasks, including graphic-related operations (it is the only one that can interact with the 3D rendering engine), whereas the ARM7 should concentrate on input management (touchscreen, most keys), wireless communications, audio output and any GameBoy emulation. As for the 2D/3D engines, they are dedicated as expected to visual rendering.
</p>

<p>
Roughly speaking, the ARM9 can be somewhere between 1.5 and about 4 times faster than the ARM7, depending on what task is involved.
</p>

<p>
ARM7 and ARM9 are often configured to use Thumb mode (16 bit mode), instead of the ARM mode (32 bit mode). The reason for this, in both cases, is memory space: ARM7 has limited program space, whereas ARM9 has limited instruction cache space. As for the 16bit-wide bus accesses (there are <a href="http://www.dev-scene.com/NDS/Tutorials_Day_2#Memory_Layout" target="_blank">several</a> buses), ARM (32-bit) instructions would saturate the bandwidth and seriously decrease overall performance.
</p>

<p>
Some applications manage to rely on very tight 32-bit loops that fit in the ARM9 instruction cache (ITCM) or in the ARM7 dedicated fast RAM (IWRAM), so that they can benefit from a more "powerful" instruction set, for critical parts. Apart from the 32-bit memory regions fed by 32-bit buses, one should prefer Thumb (16-bit) instructions.
</p>

<p>
Neither CPU of the DS has a <em>Floating Point Unit</em> (FPU), so all floating-point operations must be emulated (not hardware support, they have to be done in software), which is very slow (so avoid by all means <code>float</code> and <code>double</code> variables). Most computations use therefore:
<ul>
        <li><b>fixed-point (integer) arithmetics</b> for basic operations (addition, substraction, multiplication and division), see these sections in <a href="http://www.coranac.com/tonc/text/fixed.htm" target="_blank">TONC</a> and in <a href="http://en.wikipedia.org/wiki/Fixed-point_arithmetic" target="_blank">Wikipedia</a> for further informations</li>

       <li><b>(precomputed) Look-Up Tables</b> (LUT) for other computations, such as trigonometric ones (<code>cos</code>, <code>sin</code>, etc.). See this TONC <a href="http://www.coranac.com/tonc/text/fixed.htm#sec-lut" target="_blank">section</a> for more details</li>

</ul>
</p>

<p>
As a consequence of having two CPU, a DS ROM has to include at least two executables, one for each of the ARM (not mentioning application-specific data). At runtime the executables will have to work simultaneously, which involves often having to be synchronized and to share data. 
</p>


<p>
Monitoring the ARM loads is not easy, even when using emulators. Profiling can be done via <a href="#timers">timers</a>: one can start some hardware timers when a task starts, and then stop and read them when the task is done. That information is rather precise, and you can use it to provide a lot of information about how much of the CPU power is being used, even though setting it up is a bit tedious.
</p>

<p>
Some <a href="http://www.coranac.com/tonc/text/first.htm#sec-notes" target="_blank">guidelines</a> should be applied to write effective code for the DS. They include favoring when possible bit shifts (&lt;&lt; and &gt;&gt;), avoiding branching (<code>if</code> and <code>switch</code> replaced by arithmetic operations) and using  &amp; instead of % whenever possible. See also TONC section about <a href="http://www.coranac.com/tonc/text/asm.htm" target="_blank">ARM assembly</a>.
</p>

<p>
Both ARM use the Little-Endian convention.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="registers"></a>
<h5>Registers</h5>
<p>
Hardware memory-mapped <a href="http://www.dev-scene.com/NDS/Tutorials_Day_3#What_is_a_register" target="_blank">registers</a> are a way for the CPUs to interact with other components of the DS, such as the sound or video hardware.
</p>

<p>
These registers behave like special memory addresses that can be read and/or written by the CPU, but the associated bits, instead of being actual memory, are in fact I/O ports of the chips the CPU is interacting with. These registers can be used for example so that the CPU sets the playback frequency of the sound hardware, or so that it reads which keys are pressed.
</p>

<p>
Most useful registers are defined by the low level library named <a href="#libnds">libnds</a>, to manipule abstract plain names (ex: <code>DISPLAY_CR</code>) instead of raw addresses (ex: <code>0x4000000</code>).
</p>

<p>
Such addresses must be declared <em>volatile</em>, as the compiler cannot rely their value remaining constant between two accesses: registers are directly controlled by other chips that can modify them at any time, hence their value should not be cached as are usual bytes in memory.
</p>

<p>
Finally, in this case, using the preprocessor to set these adresses as immediate values (<code>#define DISPLAY_CR XXXX .... DISPLAY_CR = aValue ;</code>) instead of using constants (<code>const unsigned int DisplayCR = XXXX ; *DisplayCR = aValue ;</code>) might involve less operations (stored directly in the instruction opcode instead of being retrieved from memory), depending on the compiler optimization.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="cpuandmem"></a>
<h5>CPU &amp; Memory</h5>
<p>
The main DS built-in memory, consisting of one big 4-megabyte block (sometimes named EWRAM, for <em>External Working RAM</em>) can be accessed by both ARM's, but one at a time. When both CPUs are trying to read main memory, one will have priority over the other (by default, the ARM7 has priority over the ARM9), leading the other to wait until the first has finished its operation.
</p>

<p>
Regarding the ARM9, in the main memory there is generally  its corresponding executable as well as most game data. Everything except its stack (placed in DTCM, see below) and the data declared to be read-only (placed in ROM space) is stored by default in these 4 megabytes of main memory, including application-specific code, non-const variables, global data, C++ constructors and destructors, etc. This memory is rather slow, at least compared to the ARM9 caches.
</p>

<p>
The ARM7 executable can be as well in main memory, but for performance reasons its code, together with its data, are often placed into the IWRAM (64 kilobytes of fast RAM, 32-bit wide, that only the ARM7 can access). This is the case with devkitARM. Code has to be small enough to fit in this IWRAM.
</p>

<p>
From the point of view of the ARMs, the GBA cartridges are expected to be a ROM area of up to 32 megabytes. Linkers making use of removable media fake a 32-megabytes only memory by loading dynamically the relevant memory chunks from their mass storage media. 
</p>

<p>
The DTCM, for <em>Data Tightly Coupled Memory</em>, is a special 16-kilobyte memory area in the ARM9 which can be mapped to reside at various actual physical addresses. It is a lot faster than the main RAM, therefore the standard ARM9 linkscript places its stack in DTCM. Due to the small size of this memory region, local variables should be used carefully. One should avoid for example declaring too many of them (ex: local arrays) or having too deep recursions.
</p>

<p>
As for the ITCM, for <em>Instruction Tightly Coupled Memory</em>, it is a special 32-kilobyte memory area in the ARM9 which can be mapped to reside at various actual physical addresses. It is a lot faster than the main RAM, so it should be used for small (preferably 32-bit) functions that are computation-intensive and/or frequently called. For example, libdns uses that region to store the interrupt dispatcher.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="interrupts"></a>
<h5>Interrupts</h5>

<h6>Interrupts in general</h6>

<p>
An interrupt (or IRQ, for <em>Interrupt Request</em>) is a way for a CPU to stop immediately the current execution path in order to run another function, called an interrupt handler, instead. Hence when a hardware or software interrupt occurs, the processor saves first some information so that it knows where to go back and in which state, then the handler associated to this interrupt for that CPU is called at once and, when that function returns, this CPU continues executing the piece of code it was executing before it was interrupted, as if nothing had happened.
</p>

<p>
Therefore interrupts allow to perform tasks that should not wait, either because otherwise they might be missed (ex: a keypress described in a hardware register) or because the application must react directly to them (ex: a Vertical Blank Interrupt that would trigger rendering, see below).
</p>

<p>
Interrupts allow also to use the CPU sleep mode, since they provide a way of waking it up as soon as it becomes needed again, thanks to a BIOS routine. In this low power mode, the ARM9 stops processing instructions and powers down some memory banks to save battery charge. There is an ARM instruction named SWI (for <em>SoftWare Interrupt</em>) with one numerical parameter that means: enter the SWI handler and pass that value in order to know which interrupt or combination of interrupts the CPU should be waiting for, from now on.
</p>

<p>
Helper libraries, including libnds, offer higher-level interrupt management. If most of the program is in interrupt handlers, then the CPU may sleep most of the time, preserving the charge of the DS batteries. Note that interrupt handlers are meant to be executed in a short time though, as otherwise they might be interrupted themselves. Too many cascading long interrupts might prevent the DS from ever returning to the main interrupted code.
</p>

<p>
By default when an interrupt is triggered, the CPU jumps to the standard <a href="http://www.coranac.com/tonc/text/swi.htm" target="_blank">BIOS</a> interrupt routine, a function which is stored in a special memory address that we can write to. By storing here a pointer to one of our own functions, we can cause the interrupt to be processed by an user-specified function, i.e. we can define our custom interrupt (IRQ) handler.
</p>

<p>
The ARM7 stores the addresses of its interrupt handlers in a hardcoded memory location, whereas the ARM9 defines these addresses relativey to the DTCM.
</p>

<p>
Both CPU can trigger interrupts to each other (if the ARM9 allows it). It is convenient to send a notification to the other CPU when, for example, there is data for it waiting to be read on a shared area in RAM, once the calling CPU has finished filling it.
</p>


<h6>Screen-related interrupts: Horizontal &amp; Vertical Blank Interrupts</h6>

<p>
The DS screens are updated neither as a whole nor permanently: the graphics hardware draws pixels one by one, from the top left to the bottom right of each screen, line by line. It then waits for a while (a fixed duration) before starting to draw again. 
</p>

<p>
If the framebuffer (the place in memory where the pixels are stored) is modified during the redrawing process, the user may see visual artefacts in the form of partly-updated images, the top-left part being rendered according to the previous state of the framebuffer, bottom-right with the current one.
</p>

<p>
During a short duration after a line is drawn, during a longer one once a full screen is rendered, the hardware remains idle. These moments can be used to perform safe rendering: no partial redraw is to be feared then. 
</p>

<p>
Two special interrupts are regularly fired, so that the programs can use these two favorable periods: one, the <em>Horizontal Blank Interrupt</em>, occurs whenever a line has been rendered. Your program can use this first idle duration to perform rendering operations. The other one, more famous, is the <em>Vertical Blank Interrupt</em> (VBI), that is fired once a full screen has been redrawn. Your program should use this longer duration to perform at least framebuffer-related operations, while the hardware moves from the last line back up to the first line. This idle stage is called <em>Vblank</em>, as opposed to <em>Vdraw</em>, the screen refresh time.
</p>

<p>
 At both screens are refreshed at 60 Hz, the period between two VBI is 16,7 ms long. See more <a href="http://www.coranac.com/tonc/text/video.htm#sec-blanks" target="_blank">information</a> about the GBA, which still applies here. The VBI is called also <em>vsync</em>, since it allows for <em>vertical synchronisation</em>.
</p>

<p>
Note that all other operations (input reading, sound output, application logic, etc.) can be performed regardless of these two interrupts. But the VBI, beyond its use to avoid visual artefacts, provides too a hard real-time 60Hz time-base. This time base can be used to schedule operations on a regular basis. <a href="#timers">Timers</a> are useful for that task too.
</p>


<h6>Key Interrupts</h6>

<p>
Keys can be read thanks to <a href="#keys">several methods</a>, including the interrupt-based one. In this case a specific IRQ handler is registered. This handler will be triggered indeed when a key is pressed, but it will not be called when the key is released, which reduces quite a lot the interest of this method for key handling.
</p>

<p>
Beyond screens and sometimes keys, FIFO, IPC and <a href="#timers">timers</a> make heavy use of interrupts.
</p>

<p>
More information on interrupts can be found in this TONC <a href="http://www.coranac.com/tonc/text/interrupts.htm" target="_blank">section</a>.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="arm7role"></a>
<h5>ARM7 role</h5>

<p>
The full name of this processor is <code>ARM7TDMI</code>, meaning it is an ARM 7 core (a.k.a. ARM v4), which can read Thumb (16-bit) code, has a Debug mode and a fast Multiplier. On the DS it has neither an instruction cache nor a data cache, but it is a bit compensated by the fast memory it owns, the 64-kilobyte IWRAM linked with a 32-bit wide bus.
</p>

<p>
There are also two 16-kilobyte WRAM banks that can be assigned independently to the ARM7 or ARM9, with a 32-bit wide bus in both cases. The two ARMs cannot access these banks at the same time. Commonly, both banks will be mapped to the ARM7: as they form then a continuous block with the ARM7 IWRAM, this processor is effectively given 96 kilobytes of fast memory.
</p>

<p>
The ARM7 is the only CPU that can be used for controlling the touchscreen. Most applications use boilerplate code that sets up an interrupt handler for the already mentioned <em>Vertical Blank Interrupt</em> (VBI). Not for rendering purpose here, but for synchronization, so that the interrupt handler dedicated to ARM7 input reporting can be scheduled regularly. The ARM7 boilerplate code gets the value of the touchscreen parameters and stores them in a data structure the ARM9 can access to.
</p>

<p>
The ARM7 is also the only CPU that can make use of the microphone, the sound playback, the wireless communications and the real-time clock. 
</p>

<p>
Depending on a data being const or not, the linker will place that variable respectively either on an average memory rather unconstrained or in IWRAM, which is the fastest but one of the smallest. Therefore each time one forgets to specify the <code>const</code> qualifier for an actual constant, it may use unnecessarily the most researched IWRAM instead of low-end memory.
</p>

<p>
The free toolchain <a href="#devkitarm">devkitPro</a> includes a default ARM7 program to handle basic tasks like managing interrupts, reading the touchscreen, the microphone and the realtime clock, performing very simple sound playback, etc. It is the <code>arm7.bin</code> file discussed in our <a href="#building">building</a> section. Usually there is no need to write custom ARM7 code. The standard Makefiles include this default ARM7 program.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="arm9role"></a>
<h5>ARM9 role</h5>

<p>
Due to its superior power compared to the ARM7, the ARM9 is the main processor and as such will take in charge most of the work. Most of application-specific code is expected to run on it.
</p>

<p>
The ARM9 uses two built-in caches, one for the instructions (ITCM, 32 kilobytes), the other for the data (DTCM, 16 kilobytes). Each is accessed thanks to a dedicated 32-bit wide bus. Both are caching accesses to the main memory and increase the ARM9 performances a lot, at the expense of a small additional level of complexity: as neither the ARM7 nor the DMA circuits are aware of these two caches, care must be taken not to create inconsistencies with their view and the one of the ARM9. To make a better use of these caches, various primitives are provided to ensure they stay in sync with the main memory. This includes a mirror of main memory that is not cacheable, and a way of flushing the data cache.
</p>

<p>
A single ARM9 <code>main()</code> function defines usually:
<ol>

	<li>an <b>initialization</b> stage, to set screen modes, memory banks, interrupt handlers, to initialize various libraries (ex: PAlib, libfat, dswifi, etc.) and to perform as many tasks as possible (ex: loading the resources from mass storage, setting up Wifi connections, etc.)</li>

	<li>a <b>main loop</b>, in charge of: 
		<ul>

		<!--
		        <li><b></b>: </li>
		-->

  		     <li><b>game logic</b>, including any AI algorithms</li>
  		     <li><b>input management</b>, partly read from the ARM7 (touchscreen, some keys)</li>
  		     <li><b>audio and video rendering</b>, partly managed by the 2D/3D engines too</li>
  		     <li><b>I/O exchanges</b> with a mass storage device, if any</li>
		</ul>
	</li>

	<li>a <b>shutdown</b> stage, to stop all subsystems properly, including flushing write buffers (closing files, unmounting mass storage, etc.), stopping the Wifi connections, etc.</li>
</ol>
</p>

<p>
In GBA mode the ARM9 is not powered, only the ARM7 can be used.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="ipc"></a>
<h5>Inter-CPU communications</h5>

<p>
As each ARM has specific abilities (ex: the ARM7 is the only one that can access the hardware for sound and wireless), they have to communicate to send to the other ARM commands to be executed on the sender behalf.
</p>

<p>
The ARM CPU can communicate thanks to <a href="http://en.wikipedia.org/wiki/Inter-process_communication" target="_blank">IPC</a> (<em>Inter-Process Communications</em>) based on a set of registers managed thanks to a <a href="http://en.wikipedia.org/wiki/FIFO" target="_blank">FIFO</a> (<em>First In, First Out</em>) data structure. It corresponds actually to a <a href="http://en.wikipedia.org/wiki/Message_queue" target="_blank">message queue</a> with an asynchronous communication protocol. Communication between ARMs can be tricky: beyond the classical issues of synchronization of the concurrent accesses, one has to keep in mind the ARM7 is not aware of the ARM9 caches, which may lead to inconsistencies if using the main memory to share data.
</p>



<h6>Custom-made IPC (not recommended)</h6>
<p>
Commands can be described by the ARM9 in a data structure for the ARM7, for example a C union or a non-abstract C++ class inheriting from an abstract command class. These commands should specify the requested action (ex: play sound) and its associated data (ex: a pointer to the samples stored in main memory). A set of commands can then be kept in shared memory, accessible by the ARM7 and ARM9.
</p>

<p>
The command set can be implemented thanks to a circular C array or a C++ (FIFO) std::queue that would be instanciated into the shared memory area, after the libnds IPC region, i.e. after the libnds-defined IPC starting address at the <code>IPC</code> symbol incremented of an offset equal to the length of <code>TransferRegion</code>.
</p>

<p>
So the ARM9, after having initalized the queue, is expected to place a command in it whenever needed, whereas the ARM7 is expected to poll regularly the queue (ex: thanks to the VBI) in order to gather and execute commands.
</p>

<p>
This IPC method has two drawbacks. First it is only one-way: the ARM7 cannot send commands or results to the ARM9, as no protection against concurrent accesses is available here. Second it requires the ARM7 to perform polling, at the expense of uselessly burnt CPU cycles.
</p>


<p>
See <a href="http://www.double.co.nz/nintendo_ds/nds_develop6.html" target="_blank">Chris Double tutorial #6</a> for more details about custom-made IPC. 
</p>


<h6>Harware-based IPC (recommended)</h6>

<p>
The DS provides a built-in interrupt-based FIFO queue. Therefore the ARM7 can receive immediately interrupt notifications, instead of having to poll, which would be rather inefficient. The FIFO handles concurrent accesses in hardware, which allows fast reliable bidirectional communications. This queue can only hold 16 items (<code>int</code>, that can be taken as integers or as pointers to user-defined data) on each side, so the other processor should be receiving these items in a timely manner.
</p>

<p>
Each CPU has a queue which it can put data on. The other CPU can receive this data by reading from a register, or thanks to an interrupt. It will get the oldest item that the other CPU put on the queue. A kind of small application-specific protocol could be specified to manage the queue exchanges.
</p>

<p>
See <a href="http://www.double.co.nz/nintendo_ds/nds_develop7.html" target="_blank">Chris Double tutorial #7</a> for more details about hardware-based IPC. 
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




 
<a name="subsystems"></a>
<h4>Activating only the relevant subsystems</h4>

<p>
First, the DS can run in different modes, including the GBA Mode (ARM9 not used), sleep (for the ARM7), stop, halt, etc. The DS can be woken up from various IRQ (<em>Interrupt Requests</em>):
<ul>

<!--
	<li><b></b>: </li>
-->

	<li>a timer being triggered</li>
	<li>screen being opened</li>
	<li>slot-1 or slot-2 card being removed</li>
	<li>certain key combination pressed (with the exception of X and Y)</li>
</ul>
</p>

<p>
Second, most subsystems of the DS can be powered independently: sound speakers, Wifi, LCD screens, the two 2D engines, the 3D rendering and geometry engines.
</p>

<p>
Selective activation is useful notably to save energy.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>





<a name="rendering"></a>
<h4>2D/3D Rendering</h4>

<a name="renderingtoc"></a>

<p>
<center>
        <table summary="Table of contents" style="border: none">
        <tr>
          <td>
<!--
                       <a href="#"></a><br>
-->
<!--
    				<li><a href="#"></a></li>
-->

                   <div class="box">
                       <a href="#ingeneral">Rendering in general</a>

			<ul>
    				<li><a href="#pageflipping">Page flipping</a></li>
    				<li><a href="#screensandcores">Screens &amp; cores</a></li>
    				<li><a href="#videomodes">Video modes</a></li>
    				<li><a href="#memorybanks">VRAM Memory Banks</a></li>
			</ul>

                       <a href="#2D">2D Rendering</a>

			<ul>
    				<li><a href="#2Doverview">Overview</a></li>
    				<li><a href="#backgrounds">Backgrounds</a></li>
				<ul>
     					<li><a href="#rotoscale">Rotoscale backgrounds</a></li>
    					<li><a href="#erb">Extended Rotoscale backgrounds</a></li>
   					<li><a href="#textbackgrounds">Text backgrounds</a></li>
				</ul>
    				<li><a href="#framebuffermode">Framebuffer mode</a></li>
    				<li><a href="#formatconversions">Format conversions</a></li>
				<ul>
     					<li><a href="#preconversions">Precomputed conversions</a></li>
    					<li><a href="#runtimeconversions">Runtime conversions</a></li>
				</ul>
    				<li><a href="#sprites">Sprites</a></li>
				<ul>
     					<li><a href="#regularsprites">Regular sprites</a></li>
    					<li><a href="#affinesprites">Affine sprites</a></li>
    					<li><a href="#spriteanimation">Sprite animation</a></li>
				</ul>
    				<li><a href="#additional2D">Additional 2D information</a></li>
 			</ul>

                      <a href="#3D">3D Rendering</a>
          </div>

          </td>
        </tr>
      </table>
</center>

<center>[<a href="#toc">Back to the general table of contents</a>]</center>
</p>
<br><br>

<!--
<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>
-->


<a name="ingeneral"></a>
<h5>Rendering in general</h5>

<p>
The two screens can be managed separatly, or considered as two halves of a taller single screen. They can be used also with the DS being rotated of 90 degrees, on its side (portrait mode), like an open book.
</p>

<p>
Most of the informations related to the graphical rendering are stored in the VRAM, for <em>Video RAM</em>. Its size is 656 kilobytes, and it only accepts 16 or 32-bit writes (no 8-bit writes allowed).
</p>

<p>
2D/3D rendering requires images, geometries, textures, etc., see our <a href="#datastorage">data storage</a> section explaining how to access the resources needed by your application.
</p>

<p>
If the rendering takes place while the screens are redrawn, then the user will see on its screens images partly updated, leading to unwanted visual artefacts. The solution is either to modify the screen content only between two redraws or to use <a href="#pageflipping">page flipping</a>.
</p>

<p>
 The first approach can be implemented by waiting for the aforementioned VBI (<em>Vertical Blank Interrupt</em>) and performing the rendering only in its handler, i.e. in hard real time. One has just to ensure that rendering does not last more than the Vblank, which is rather short. This is not always possible, except for the most simple renderings. Otherwise page flipping should be preferred.
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>



<a name="pageflipping"></a>
<h6>Page flipping</h6>
<p>
When rendering is not trivial, this task might not be short enough to fit in the Vblank. <a href="http://www.coranac.com/tonc/text/bitmaps.htm#sec-page" target="_blank">Page flipping</a> (not to be mixed up with the more expensive double-buffering, which involves an extra screen copy) is a method that consists on rendering in a screen buffer while the hardware, simultaneously, displays another buffer. At each VBI, buffers are exchanged so that both tasks can continue. Page flipping is thus a way of eliminating nasty artefacts like tearing in animations. Palettes may have to be flipped as well as bitmaps.
</p>

<p>
Page flipping allows to have a lot more time to render than when rendering only during Vblank: here 16 ms (at 60 Hz) are available.
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>



<a name="screensandcores"></a>
<h6>Screens &amp; cores</h6>

<p>
In software you manipulate a <em>main</em> screen abstraction (main rendering core), that can be mapped either to the top actual screen or to the bottom one, and a <em>sub</em> screen (sub rendering core), which will correspond to the other hardware screen. They can be swapped at any time thanks to <code>lcdSwap()</code>.
</p>

<p>
Compared to the sub core, the main core offers following additional features:

<ul>
       <li>it adds <b>two more video modes</b> able to render large bitmaps</li>
       <li>it can render <b>directly from memory to the screen</b>: the 2D engine is then bypassed (framebuffer mode)</li>
      <li>one of its background layers can be <b>given to the 3D engine </b></li>
 </ul>
</p>

<p>
Both screens can be seen from software like 2D Cartesian coordinate systems, the abscissa (X axis) ranging from 0 (left) to 255 (right), the ordinate (Y axis) ranging from 0 (top) to 191 (bottom). 
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>


<a name="videomodes"></a>
<h6>Video modes</h6>

<p>
Both cores can be set in various <em>video modes</em>, each with different capabilities and features. The <em>sub core</em> has only five different video modes, whereas the  <em>main core</em> is more powerful: it is able to reallocate more VRAM, and has the ability to render basic vertex 3D (with a 2048 polygon limit) and several vertex shaders, such as <em>Toon Shading</em>. The main core also has an extra video mode called Mode 6 for large bitmaps. In addition, the display capture device is capable to take a capture screen only from this core. See <a href="http://liranuna.drunkencoders.com/nds-2d-tuts/lesson-1" target="_blank">LiraNuna's 2D tutorial</a> for more details.
</p>

<p>
 In a given screen mode, pixels are described according to a specific pixel format, that dictates their layout in memory : 
<ul>

<!--
        <li><b></b>: </li>
-->

        <li>the <b>size</b> of their description (ex: 16 bits per pixel) </li>
        <li>their <b>type</b>, either direct color (direct definition in RGB space) or palette index (reference to a color defined elsewhere)
        <li>the <b>ordering</b> in memory of the color components, say, GBR ordering (Red is in least significant bits, then Blue, then Green in most significant ones)</li>
        <li>the <b>size</b> of each color component, ex: 5 bits per component, each component ranges from 0 to 31, as in <code>xBBBBBGGGGGRRRRR</code></li>
       <li>the <b>meaning of the most significant bit</b> (the 'x' is the previous component layout), which is either ignored or, most of the time, taken as an alpha bit which tells whether this pixel is fully transparent (if 0) or if it should be displayed (if 1)</li>
</ul>
</p>

<p>
Direct color modes are simple, but use a lot of memory space when stored and a lot of bus bandwidth when blitted, compared to palette-based ones with 4-bit or 8-bit index, which are therefore often favoured.
</p>

<p>
There are libnds-provided macros (ex: <code>RGB15</code>) that help defining pixels according to specific formats. See <a href="http://www.double.co.nz/nintendo_ds/nds_develop2.html" target="_blank">Chris Double tutorial #2</a> for more details. 
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>



<a name="memorybanks"></a>
<h6>VRAM Memory Banks</h6>

<p>
Depending on the video mode, each rendering core will retrieve its video-related informations (ex: bitmaps, sprites, tiles, textures, maps) from hardcoded regions defined in overall memory address space.
</p>

<p>
These are <em>address</em> regions (i.e. a lower and higher addresses), but by default at these adresses there is no actual memory: the engines have almost no memory on their own (except for sprite attributes and base palettes).
</p>

<p>
You therefore need to map predefined chunks of actual video RAM into these specified address regions for the cores to use them. Each of these chunks is called a bank, there are nine of them, labelled VRAM_A through to VRAM_I. Each of these has a particular size and is best suited for specific purposes: choosing the appropriate layout and settings is all the more important that memory space is tiny.
</p>

<p>
The banks are:
<center>
  <table border="1" summary="VRAM Memory Banks">
    <caption>VRAM Memory Banks</caption>

    <tr>
        <th>Bank name</th>
        <th>Bank size (in Kilobytes)</th>
    </tr>

    <tr>
        <td>VRAM_A</td>
        <td>128</td>
   </tr>

    <tr>
        <td>VRAM_B</td>
        <td>128</td>
   </tr>

    <tr>
        <td>VRAM_C</td>
        <td>128</td>
   </tr>

    <tr>
        <td>VRAM_D</td>
        <td>128</td>
   </tr>

    <tr>
        <td>VRAM_E</td>
        <td>64</td>
   </tr>

    <tr>
        <td>VRAM_F</td>
        <td>16</td>
   </tr>

    <tr>
        <td>VRAM_G</td>
        <td>16</td>
   </tr>

    <tr>
        <td>VRAM_H</td>
        <td>32</td>
   </tr>

    <tr>
        <td>VRAM_I</td>
        <td>16</td>
   </tr>

  </table>
</center>
</p>

<p>
See also the <a href="http://www.dev-scene.com/NDS/NDS_Tutorials_VramTable" target="_blank">VRAM bank mapping</a> from Dovoto's tutorial.
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>




<a name="2D"></a>
<h5>2D Rendering</h5>

<a name="2Doverview"></a>
<h6>Overview</h6>

<p>
The system has two 2D engines, one per screen. Each screen can be put into a variety of different modes, with different feature sets. These engines are each quite similar to the Game Boy Advance's single 2D engine, though more powerful.
</p>

<p>
The VRAM banks previously mentioned are to be mapped according to the expected layout for 2D memory, which is mostly made of:
<ul>

<!--
        <li><b></b>: </li>
-->

        <li><b>background</b> memory, which contains either tilesets (32 blocks, 16 kilobytes each) and tile maps (32 blocks), or bitmaps</li>
        <li><b>sprite</b> memory, which contains tiles for each sprite</li>
</ul>
</p>

<p>
As for sprite attributes, as said previously each 2D core has its own built-in dedicated memory, which contains 128 entries (one entry per possible sprite). Each entry is made of four 16-bit attributes, storing the size, shape and location of the associated sprite. Up to 32 out of the 128 entries can correspond to affine transformations (named <em>rotsets</em>), whose additional attributes specify rotation and scale. Hence up to 32 rotsets can be defined, but more than one sprite can be associated to a given rotset.
</p>

<p>
Base palettes have their own per-engine memory too. Each 2D engine has two base palettes, one for the background, one for the sprites. Each base palette contains 512 16-bit color entries, in x555 BGR format.
</p>

<p>
See also the <a href="http://www.dev-scene.com/NDS/Tutorials_Day_4#Background_Memory_Layout_and_VRAM_Management" target="_blank">memory layout</a> as seen from the 2D engines, taken from Dovoto's tutorial.
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>



<a name="backgrounds"></a>
<h6>Backgrounds</h6>

<p>
Each video mode has a number of <em>backgrounds</em> (BG) that can be used. A background is a surface that, when drawn upon, displays on the hardware like a layer. Modes that have multiple backgrounds allow these backgrounds to be overlayed, so that they are drawn on top of each other. This, and the support of per-pixel transparency, enables for example a background with text to be overlayed on top of a background displaying an image.
</p>

<p>
Backgrounds are opposed to sprites: the formers take care of the decoration, the environment often static that may take the entire screen, whereas the laters represent the living entities (small moving objects, like animated characters).
</p>

<p>
Some backgrounds behave like framebuffers (per-pixel software rendering), others are tiled. Such backgrounds, in a very similar way to palettized surfaces (that contain, instead of pixels, a palette and color indices referring to that palette) are composed of a set of tiles (the "palette") and a map, which for each cell of its grid tells which tile should be placed here, as if the screens were divided into a series of 8x8 squares. Expressed in tile units, each screen is thus 32x24.
</p>

<p>
More precisely, instead of being a kind of array of pixels, a tile-based background is a kind of array of references to tiles, each tile being a fixed-size array of pixels (a rectangle 8 pixels wide and 8 pixels tall, i.e. 64 pixels). The 2D engine will thus sweep the background as if it was a grid of tiles: for each cell of the grid, it will read in the map array the corresponding tile entry, and will blit the tile being mentioned in that entry to the cell. Hence tiles allow to perform a full pavage of the background. 
</p>

<p>
The DS excels at tile-based rendering, which is the way to go for most games as it is hardware-accelerated, whereas framebuffer access implies slow software rendering. A few basic tiles can create complex displays quite nicely.
</p>

<p>
There are three types of backgrounds: <em>Rotoscale </em>(a.k.a. Rotation), <em>Extended Rotoscale</em> (a.k.a. Extended) and <em>Text</em>. See the <a href="http://www.dev-scene.com/NDS/Tutorials_Day_2#2D" target="_blank">table of graphic modes</a> from Dovoto's tutorial.
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>


<a name="rotoscale"></a>
<h7>Rotoscale backgrounds</h7>
<p>
<em>Rotoscale</em> backgrounds are tile-based backgrounds (or surfaces, in SDL-like language) that can be manipulated (affine transformations: 2-axis scrolled, scaled in or out, rotated, sheared, thanks a <a href="http://user.chem.tue.nl/jakvijn/tonc/affine.htm" target="_blank">transformation matrix</a>) and displayed directly on screen, all in hardware, i.e. with little overhead for the CPUs, no additional VRAM copy and no specific developing effort (it only involves setting some registers). They can be smaller or bigger than a screen, in which case only the relevant parts will be shown (clipping). 
</p>

<p>
Such regular rotoscale backgrounds use 8-bit tile entries. They can therefore use only up to 256 tiles. Each tile entry designates simply the number of its tile into character memory.
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>



<a name="erb"></a>
<h7>Extended Rotoscale backgrounds</h7>

<p>
<em>Extended Rotation Backgrounds</em> (ERB) are more powerful versions of Rotoscale backgrounds: they support larger tilesets (1024 instead of 256, which induces larger maps), they support more palettes (256-color ones), and they can operate in bitmap mode (linear frame buffer) as well as in tiled mode.
</p>

<p>
As ERB backgrounds can be accessed (read and write) like the framebuffer, as they provide additional hardware capabilities, they tend to make the framebuffer modes useless.
</p>

<p>
To demonstrate scrolling around an image, one may use for example a 256x256 background size (in pixels), with 16-bit color tiles (with one alpha bit). That background would be larger than the DS screen (256x192), but it would use only 128 kilobytes to store the image. VRAM_A could be chosen for that. 
</p>

<p>
Finally, hardware scrolling can be of great help to implement parallax scrolling (a fake sense of depth), when having multiple backgrounds sliding at different paces.
</p>

<p>
In tile mode, ERB use the same 16-bit tile entries as the text backgrounds (see below).
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>


<a name="textbackgrounds"></a>
<h7>Text backgrounds</h7>

<p>
They are general-purpose tiled backgrounds. A text background is made of:
<ul>
        <li>a <b>tileset</b>: a collection of up to 1024 tiles. Each tile is identified by its index, which is its number in the set, ranging from 0 to 1023</li>
        <li>a <b>map</b>, which is mainly a 2D array, whose size is at least 32x32 (depending on the background setup), that specifies for each of its cells which tile from the tileset should be rendered (blitted). A tile entry occupies two bytes (16 bits): the first 10 bits (the character index) encode the tile index (<code>2^10=1024</code>), and the 6 remaining bits (the control bits) record the tile attributes (see below)</li>
</ul>
</p>

<p>
The DS tiling engine is quite feature-rich: beyond displaying tiles as they are, it can flip them (horizontally and/or vertically), and use different palettes to render the same tile, for example for palette-based animations. These per-tile informations are stored in the aforementioned 6-bit attributes of tile entries (the control bits): one bit (on/off) for each flip (horizontal/vertical), and 4 bits to designate one of the 16 sub-palettes. 
</p>

<p>
So with text backgrounds you have nothing like an overall screen buffer that could be written at the pixel level: you can just manipulate tiles and maps, and it is the DS hardware that will read it to recompose the screen.
</p>

<p> 
The pixels of a tile are described as color indices taken from a palette. As palettes here are a collection of either 256 colors or 16 sub-palettes of 16 colors each, there are two color modes for tiles in text backgrounds:
<ul>
        <li>a <b>256-color mode</b> (a.k.a. 8-bit color mode):  a pixel is an index to the 256-color palette. The index is then a 8-bit integer, ranging for 0 to 255</li>
        <li>a <b>16-color mode</b> (a.k.a. 4-bit color mode):  a pixel is an index to a 16-color palette. The index is then an 4-bit integer, ranging for 0 to 15. Less memory is required, thus making room for more tiles and other elements in VRAM, but, with only 16 possible colors per tile, the rendering quality of the result might be poor</li>
</ul>
</p>


<p>
In the 512-kilobyte VRAM (Video RAM), there are locations dedicated to the storage of map data, in <em>map bases</em> (2 kilobytes each), or tile data, in <em>tile bases</em> (16 kilobytes each, a.k.a. charblock). Map and tile bases share the same region in VRAM, whose layout must be carefully planned. Usually one counts in map base units, for example the size of a tile base is 8 map bases.
</p>

<p>
As maps can be placed anywhere in the first 64 kilobytes of background memory, and tiles anywhere in the first 256 kilobytes, a good practise may be to reserve the first 16 kilobytes of background memory to your maps (hence 8 map bases, which therefore correspond to the first tile base), and, starting at tile base #1 (instead of #0), to use the remaining 496 kilobytes (31*16) to store your tiles.
</p>

<p>
As each tile base occupies 16 kilobytes, in 256-color mode there can be no more than 256 tiles per tile base  (<code>16*1024/(64*1)</code>), whereas in 16-color mode there can be 512 tiles per tile base (<code>16*1024/(64*0.5)</code>).
</p>

<p>
The tileset of a given map can refer up to 1024 tiles: more than a tile base can be referred to by a map base. Therefore in 256-color mode, there can be up to 4 tile bases per map base (<code>1024/256</code>), whereas in 16-color mode there can be up to 2 tile bases per map base (<code>1024/512</code>).
</p>

<p>
Map bases always have 32×32 tile entries. By default, the DS will be using a 32x32 tile map, a size of 256x256 pixels. It would be exactly as wide as a DS screen, and taller: screen height is 192 pixels, therefore there would be 64 extra rows. 
</p>

<p>
When wanting to perform (hardware) scrolling, one has to have a logical screen bigger than the rendered screen, in order to load in the background the neighboring parts before showing them. To create bigger backgrounds, you need to use several map bases, and to choose one out of the three other sizes: 32x64, 64x32 and 64x64. As explained in <a href="http://www.coranac.com/tonc/text/regbg.htm#sec-map" target="_blank">TONC</a>, maps using several map bases cannot be accessed as a unique array, per-map base accesses still has to be performed. Computing the address of a tile entry requires therefore a little more efforts.
</p>

<p>
More information on <a href="http://www.coranac.com/tonc/text/regbg.htm" target="_blank">regular tiled backgrounds</a> can be found in TONC and in Dovoto's <a href="http://www.dev-scene.com/NDS/Tutorials_Day_4" target="_blank">tutorial</a>.
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>


<a name="framebuffermode"></a>
<h6>Framebuffer mode</h6>
<p>
The framebuffer mode, or bitmap mode, is the easiest to directly draw to, but the less powerful of all modes. A <em>framebuffer</em> is a mode where the screen is mapped directly to a portion of main memory. Pixel informations written to this memory area in 15-bit direct color format will immediately result in their appearing on the screen. Therefore to plot a pixel, whose color is defined in a 16-bit integer c, at screen location (x,y), one just would have to write c at <code>FramebufferBaseAddress + y * ScreenPitch + x</code>, ScreenPitch being equal here to the screen width (no extra per-scanline bytes), 256. 
</p>

<p>
If it remains quite simple, it does not offer the various useful features supported by other modes, such as sprites, scrollings, etc., not to mention 3D primitives: with the framebuffer only software rendering is performed (raster graphics). And only the main screen can use this framebuffer mode.
</p>

<p>
Hence a good practise is to prefer sprites and tiled backgrounds over bitmap modes. Very few 2D games do not rely on the hardware acceleration.
</p>

<p>
See Dovoto's tutorial about software-based <a href="http://www.dev-scene.com/NDS/Tutorials_Day_3#Bresenham_Lines" target="_blank">line rendering</a> using the Bresenham algorithm. 
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>



<a name="formatconversions"></a>
<h6>Format conversions</h6>

<p>
Finally, the graphics to render are most of the time available first in general-purpose formats (png, jpeg, etc.). They have therefore to be converted into data that the DS may use natively, i.e. split into the appropriate palettes, tilesets, etc. This can be either precomputed (done at build time, once for all) or done at runtime, which may allow to benefit from the features of the general-purpose format, for example compression.
</p>



<a name="preconversions"></a>
<h7>Precomputed conversions</h7>

<p>
Tools include <a href="http://www.coranac.com/projects.php#grit" target="_blank">grit</a> (<em>GBA Raster Image Transmogrifier</em>, new name for git) and <a href="http://www.aaronrogers.com/ham/gfx2gba_readme.php" target="_blank">gfx2gba</a> (Linux port available) which, when given a file in 16 or 256-color PCX, TGA, SPR, BMP or TIM formats, can create a binary tileset (<code>*.raw</code>) with 8x8 tiles), a binary background map (<code>*.map</code>) and a 256-color palette file (<code>*.bin</code>):
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
gfx2gba -c256 -m -t8 -pmyPalette.bin myImage.bmp
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
One may use <a href="http://www.gimp.org/" target="_blank">The Gimp</a> to preconvert PNG and JPEG files to formats recognized by gfx2gba. There are also Python-Fu scripts for that tool, to convert images to formats appropriate for tiles and sprites. See this <a href="http://www.dspassme.com/programmers_guide/tutorial/using_tiles.html" target="_blank">guide</a> for further hints to use The Gimp with regard to the DS.
</p>

<p>
Another tool useful to convert sprites, backgrounds and textures is PAGfx, which has been ported to GNU/Linux (download <a href="http://www.palib.info/downloads/PAGfx/Linux/" target="_blank">here</a>). Its user just has to update <code>PAGfx.ini</code> and then to run <code>PAGfx.exe</code> that will read it and perform its image manipulations. Prefer for example the magenta colorkey (<em>transparent color</em>). This will result in various .h and .c files to be used when building, so that the corresponding resources are embedded. This implies <a href="#datastorage">linking these data directly</a> in the executable, which is rarely the best way to manage resources.
</p>

<p>
More information about PAGfx can be found in <a href="http://www.palib.info/wiki/doku.php?id=day4#converting_with_pagfx" target="_blank">this section</a> of PAlib tutorial.
</p>

<p>
Other tools include <a href="http://www.neoflash.com/forum/index.php?PHPSESSID=88241d0d50076371429b199bc63948f9&topic=3016.0" target="_blank">GbaGraphics</a>, by Brunni, which works when run from Wine.
</p>

<p>
These converted graphics will then have to be <a href="#datastorage">stored</a> so that the DS application will find it. 
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>



<a name="runtimeconversions"></a>
<h7>Runtime conversions</h7>

<p>
Tools include <a href="http://www.aaronrogers.com/ham/gfx2gba_readme.php" target="_blank">gba-jpeg</a>.
</p>

<p>
When developing a decoder, to read easily headers (notably fixed-size ones), one may use in-place structure reading, known as (packed) overlay: it maps directly a sequence of bytes being read from file into a C structure, provided the compiler is instructed about how data is padded.
</p>

<p>
See also: Dovoto's tutorial about <a href="http://www.dev-scene.com/NDS/Tutorials_Day_3#Working_With_Graphics_Files" target="_blank">BMP decoding</a>, <a href="http://liranuna.drunkencoders.com/nds-2d-tuts/" target="_blank">LiraNuna's 2D tutorial</a>, and <a href="http://www.double.co.nz/nintendo_ds/nds_develop10.html" target="_blank">Chris Double tutorial #10</a> for more details. 
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>



<a name="sprites"></a>
<h6>Sprites</h6>

<p>
Sprites are small (8x8 to 64x64 pixels) graphical objects that can be transformed independently from each other and can be used in conjunction with either bitmap or tiles background types (which are mutually exclusive). Like backgrounds, sprites are built out of tiles, but backgrounds and sprites cannot share tiles. The tiles available for sprites are stored in object VRAM, or OVRAM for short. They can be shared between different sprites, thus changing them will change them for all sprites (ex: when performing animations). The same is true for palettes.
</p>

<p>
OAM means <em>Object Attribute Memory</em>. This is where you control the sprites, which are managed by the DS hardware. At most 128 sprites are supported at a time. Each of them has three so-called attributes (hence OAM), including its onscreen position (top-left corner of the sprite) expressed in pixels. This position ranges between 0 and 511 for the abcissa, and between 0 and 191 for the ordinate. This means the sprite can be out of the screen bounds (256x192). Coordinates wrap around: a 512 abcissa is managed as if it was 0, some thing for a 192 ordinate. Other per-sprite informations in OAM are shape, size, requested flipping, and if a rotset is used. If yes, its number, in 0..31, is specified. In each rotset, a transformation matrix is specified, with zoom factors and rotation angle.
</p>

<p>
Generally speaking, the OAM is not directly read or written to, as during the VDraw this memory area is locked and cannot be accessed. This is less a limitation than a protection, as visual artefacts could be seen if the OAM was changed during screen update. Therefore programmers usually relies on an OAM double buffering: they have their own shadow copy in RAM of the OAM attributes, they can modify it at any time (including Vdraw), and during Vblank they update the real OAM from their shadow copy.
</p>

<p>
There are three available color modes for sprites: 
<ul>
        <li><b>16 palettes, each of 16 colors</b>: inherited from the GBA, this mode is of little use on the DS</li>
        <li><b>16 palettes, each of 256 colors</b>: uses twice as much memory, but is indeed the better trade-off. It is used by most of the time</li>
        <li><b>16-bit direct color</b>: no palette, each pixel can have its own color. Main problem is the very significant memory consumption</li>
</ul>
</p>

<p>
A special color can be elected in each of the color modes, the <em>colorkey</em>, so that the pixels that exactly match that color are not drawned at all: they will be fully transparent, which enables to have sprites which do not color all their bitmap area, i.e. who can have a non-rectangle shape. For example a disc sprite should not overwrite the background inside its clipping rectangle but outside of the disc: in this area we need to view the background behind it. A good and quite usual colorkey choice is the "pure" magenta (full red, full blue, no green), as it is seldom used for real colors.
</p>

<p>
As for the size of sprites, each dimension can be either 8, 16, 32 or 64 pixels (i.e. 1,2,4 or 8 tiles), but if a dimension is 64, then the other must be either 32 or 4 (not 8, not 16).
</p>

<p>
Each sprite must be given a number in 0..127 that identifies it, and that defines as well its priority in its background. The smaller a sprite number is, the highest is its priority: in a given background, a given sprite will be on top of the sprites with higher numbers, as if the engine rendered the sprites incrementally, from 127 to 0. In addition to this per-sprite priority, sprites can be associated with one background in 0..3. Similarly, a background with a smaller number will be on top of other backgrounds, and its associated sprites as well. Thus, as for priority, the sprites are first sorted by backgrounds, and in a given background they are sorted by their own priority. For example sprite #0 of background #0 will be always on top of all other sprites.
</p>

<p>
Each sprite behaves a bit like a big tile: it has an identifier and some overall informations such as flipping flags and palette-info for 16-color sprites. It is nevertheless made from several real tiles, which can be stored in memory according to two <a href="http://www.coranac.com/tonc/text/regobj.htm#sec-tiles" target="_blank">conventions</a>: 1D mapping or 2D mapping. Specific <a href="#preconversions">tools</a> can be used to turn any bitmap into a suitable tileset for DS sprites.
</p>

<p>
To follow TONC naming conventions, each sprite is either regular (standard, basic) or affine (being able to be rotated, scaled, sheared).
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>


<a name="regularsprites"></a>
<h7>Regular sprites</h7>
<p>
A regular sprite has several attributes that define its size, actual shape (depending both on the shape and size attributes), position (x,y of the top-left sprite corner in screen space), background priority (higher priorities are drawn first, hence are below lower-priority ones), flipping (horizontal and/or vertical), base tile, bit depth (palette range), activation (shown/hidden), <a href="http://www.coranac.com/tonc/text/gfx.htm#sec-blend" target="_blank">alpha-blending</a> status, <a href="http://www.coranac.com/tonc/text/gfx.htm#sec-mos" target="_blank">mosaïc</a> (blocky) effect status, <a href="http://www.coranac.com/tonc/text/gfx.htm#sec-win" target="_blank">windowing</a>, and more.
</p>

<p>
The size of sprites can be 64x64 (the default), 64x32, 32x64.
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>



<a name="affinesprites"></a>
<h7>Affine sprites</h7>
<p>
Affine sprites are extended regular sprites. They have all regular attributes, and refer to additional affine-specific informations, the previously mentioned rotsets. Each affine sprite is transformable: it references an affine 2x2 transformation matrix, which defines how it should be rotated, scaled or sheared when being rendered. This matrix transforms points expressed in screen space into points in texture space, not the other way round.
</p>

<p>
Because of round-off errors due to fixed point matrix multiplications, one should avoid to compute multiple transforms in a row by reusing the previous affine matrix to compute the newer one: the error would soon grow too much. One should keep track of current transformation settings (angles, zoom factor, etc.) and recompute from them an affine matrix instead.
</p>

<p>
More information about these affine operations can be read from <a href="http://www.coranac.com/tonc/text/affine.htm" target="_blank">TONC</a>, especially the <a href="http://www.coranac.com/tonc/text/affobj.htm" target="_blank">affine sprite</a> section about clipping, discretization and wrapping artefacts.
</p>

<p>
Sprites are discussed as well in Dovoto's <a href="http://www.dev-scene.com/NDS/Tutorials/Captain_Apathy/Tiling#Sprites" target="_blank">tutorial</a> and in this <a href="http://www.palib.info/wiki/doku.php?id=day4" target="_blank">section</a> of PAlib tutorial.
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>



<a name="spriteanimation"></a>
<h7>Sprite animation</h7>

<p>
To perform animations, one should better have its sprites refer to different tiles, rather than considering that a sprite owns the tiles it uses, and therefore updating these tiles. Changing the tile index in the sprite attributes is quite fast and easy, but it requires that the various tiles for the animation frames can fit in the tile block. For example, even with the biggest banks (128 kilobytes), no more than 32 64x64 sprites, at 256 bit color, can be stored.
</p>

<p>
Another method would be to load dynamically the tiles for the animations, for example thanks to DMA copies, either directly to VRAM, or in a kind of back-buffer located in main RAM that can be swapped with the current sprite buffer when the animation needs its data.
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>


<a name="additional2D"></a>
<h6>Additional 2D information</h6>
<p>
More information on <a href="http://www.coranac.com/tonc/text/video.htm#sec-vid-types" target="_blank">bitmaps, backgrounds and sprites</a>, coming from the GBA but mostly relevant for the DS as well.
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p><br><br>



<a name="3D"></a>
<h5>3D Rendering</h5>

<p>
The system's 3D hardware can perform a lot of operations:
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://en.wikipedia.org/wiki/Transform_and_lighting" target="_blank">transform and lighting</a>: performs 3D space to screen conversion, including lighting. Having it hardware accelerated frees the CPU from this computation-intensive task</li>
    <li>texture-coordinate transformation: so that textures (images used to wrap 3D shapes) can be used</li>
    <li><a href="http://en.wikipedia.org/wiki/Texture_mapping" target="_blank">texture mapping</a>: applies a texture to a shape, here without blending</li>
    <li><a href="http://en.wikipedia.org/wiki/Alpha_blending" target="_blank">alpha blending</a>: combines an image with a background to create the appearance of partial transparency</li>
    <li><a href="http://en.wikipedia.org/wiki/Anti-aliasing" target="_blank">anti-aliasing</a>: minimizes the distortion artifacts due to on-screen rendering (enhances the resulting image). Here available for edge drawings, not full-screen</li>
    <li><a href="http://en.wikipedia.org/wiki/Cel-shading" target="_blank">cel shading</a> (a.k.a. toon shading): simulates hand-drawn ( like cartoon or comic books) computer-generated graphics </li>
    <li><a href="http://en.wikipedia.org/wiki/Z-buffering" target="_blank">z-buffering</a>: management of image depth coordinates, one of the solutions to the visibility problem. Hardware fog is available</li>
</ul>
</p>

<p>
Character rendering might have a blocky appearance due to Point (nearest neighbor) texture filtering. 2D sub-pixel glyph rendering could be used though, as it is done with the TextViewer homebrew.
</p>

<p>
The DS can render at most about 6144 vertexes per frame (which translates to roughly 2048 triangles per scene or 1536 quads), at 60 frames per second. Rendering can occur only to a single screen at a time, so having 3D on both screens decreases performance significantly. The DS is more limited by its polygon budget than by its pixel fill rate.
</p>

<p>
There are 512 kilobytes of texture memory per screen, and the maximum texture size is 1024x1024 pixels.
</p>

<p>
The 3D core behaves a lot like an <a href="http://en.wikipedia.org/wiki/OpenGL" target="_blank">OpenGL</a> state machine, allowing for wrappers and the reuse of rendering code and data. Actually <a href="http://www.khronos.org/opengles/" target="_blank">OpenGL ES</a> would be the closest encapsulation, as there is no support on the DS for floating point computations. Fixed-point is used instead.
</p>

<p>
See also the TONC section about <a href="http://www.coranac.com/tonc/text/matrix.htm" target="_blank">basic linear algebra</a> and its <a href="http://www.coranac.com/tonc/text/mode7ex.htm" target="_blank">3D section</a> for theoritical elements about 3D rendering.
</p>

<br><p><center>[<a href="#renderingtoc">Back to the rendering table of contents</a>]</center></p>

<br><p><center>[<a href="#toc">Back to the main table of contents</a>]</center></p><br><br>



<a name="sound"></a>
<h4>Sound</h4>
<p>
Sound tends to consume a lot of CPU and RAM resources, hence the best is often to target first the hardware-supported features. 
</p>

<p>
Only the ARM7 can access the sound hardware, so we somehow have to have the ARM9 notify the ARM7 when it wants a sound to be played. 
</p>


<h5>Sound output</h5>
<p>
Relying on the sound mixing hardware is the best bet: it can manage 16 independent audio channels with about 5% memory bandwidth usage. Therefore using <a href="http://modarchive.org/" target="_blank">MOD</a>-like soundtracks is favored, even by commercial games. Supported formats are 8 bit, 16 bit, or <a href="http://en.wikipedia.org/wiki/ADPCM" target="_blank">ADPCM</a>.
</p>
 
<p>
On the other side, with ogg/mp3 decoding, one would eat around 50% of the ARM9 CPU power, or almost 100% of the ARM7, with a pretty low bitrate. One could use the <a href="http://xiph.org/vorbis/" target="_blank">Tremor</a> implementation to benefit from a FPU-less OggVorbis decoder (check that memory leak issues have been solved). Tight 32bit (ARM, not Thumb) loops should be favoured.
</p>

<p>
Sample data can be assigned independently to any of the 16 channels. For a given channel, the playback frequency of the sample (ex: 22 050 Hz), the sample size (ex: 8bit) and the sample data length can be set, among other informations (channel enabled or not, looping mode or one shot, volume, etc.). Stereo sound can be output, with panning from left to right for example.
</p>

<p>
Sample data also need to be passed to the hardware in raw format, i.e. as a series of uncompressed samples without any header. This is not the case of the most usual formats (wav, mp3, OggVorbis, etc.), therefore they have to be converted one way or another to the expected raw format (beforehand or by the program itself, at start-up or in-game). This can be done thanks to the <a href="http://sox.sourceforge.net/" target="_blank">sox</a> tool, or thanks to the <code>wav2gba</code> tool. More information about the conversion can be found <a href="http://www.double.co.nz/nintendo_ds/nds_develop4.html" target="_blank">here</a>.
</p>

<p>
Sound output requires sound to play, see our <a href="#datastorage">data storage</a> section explaining how to access the resources needed by your application.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="soundinput"></a>
<h5>Sound input</h5>

<p>
Once the amplifier has been powered on, the DS microphone is accessed through the <em>Serial Peripheral Interface</em> (SPI) on the ARM7, in a very similar way to the touchscreen is read. However helper libraries hide this inner working under higher level interfaces.
</p>

<p>
The built-in microphone can be used to perform some limited speech-recognition, as it is done in a few games.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="datastorage"></a>
<h4>Data storage &amp; application ressources</h4>

<h5>Linking the data directly in a ARM executable</h5>
<p>
This is the simplest method, it will work on any media, but it provides only limited space, as the whole ROM (including the data) will have to fit in the 4 megabytes of built-in RAM, and as the executables for each ARM must be under specific thresholds (64 kilobytes for the ARM7). Only read-only access to the data will be possible.
</p>

<p>
The data has to be converted to (binary) object files (*.o) thanks to objcopy (actually <code>arm-eabi-objcopy</code>) before being linked with the other object files in the the executable that will need them, thanks to the linker (actually <code>arm-eabi-g++</code>). With devkitARM makefiles, the inclusion of such object files is automated: if one creates a directory named <code>data</code> in the project folder (right next to <code>source</code> and <code>include</code>) and put in this <code>data</code> directory one's resource files renamed so that their final extension is <code>.bin</code>, then the Makefile will take them in charge automatically: it will apply <code>arm-eabi-objcopy</code> and create an appropriate associated header file, ready for inclusion.
</p>

<p>
Sounds would probably be embedded within the ARM7 executable, as this CPU is the only one able to access the sound hardware, in the unlikely case where the only 64 kilobytes permitted would be enough. Otherwise the data can be linked to the ARM9 executable. More information about the data embedding in executables can be found <a href="http://www.double.co.nz/nintendo_ds/nds_develop4.html" target="_blank">here</a>.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<h5>Using the non-volatile RAM available in slot-2 cartridges</h5>

<p>
Gameboy Advance cartridges (slot-2) have a 64 kilobytes place where data can be stored and retrieved, notably for game save. DS can use it, including in order to feed a program with data from the slot 2. 
</p>

<p>
This area is called SRAM, but it should be understood as Save RAM, and not the usual <a href="http://en.wikipedia.org/wiki/Static_random_access_memory" target="_blank">Static RAM</a>: it is non-volatile memory, its data will be kept even if the DS is switched off.
</p>

<p>
The GBA cartridge memory must be mapped to either the ARM7 or the ARM9 (then wait a few milliseconds before accessing it). Before writing to it, the cartridge ID should be checked to ensure there is a cartridge indeed and that the homebrew (maybe downloaded by Wifime) will not write over a commercial cartridge. It is done by reading 4 bytes from a given address in ROM space and by <a href="http://www.double.co.nz/nintendo_ds/nds_develop5.html" target="_blank">checking</a> whether the four bytes form the string <code>PASS</code>.
</p>

<p>
All reads and writes to the SRAM must be 8 bits at a time (neither 16 nor 32-bit). These accesses can be performed anywhere in the SRAM memory space, and do not have to follow any specific rule. Therefore anything can be stored here: texts, images, sounds, etc. A good practise is to write at the beginning of this memory a small header that helps identifying the structure of the data being stored.
</p>

<p>
Some flash cartridges have more than one SRAM space, but apparently only one of them can be easily accessed.
</p>

<p>
More information about reading from SRAM can be found <a href="http://www.double.co.nz/nintendo_ds/nds_develop5.html" target="_blank">here</a>.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<h5>Reading the data from a filesystem</h5>
<p>
Instead of decreasing the available RAM by adding data to executables, one may access selectively the slot-1 or slot-2 cartridges, as a filesystem, and retrieve only the chunks of chosen files taken from a directory tree.
</p>

<p>
With that method you can organize your data in as many files as you wish, and more important you are only limited by the size of the game cartridge, which is huge (up to 2 GB and more) compared to the other traditional storage locations in the DS. The main drawback is that it implies a cartridge must be used and your program must be stored on it. This method will not work for Wifi-downloadable applications (WMB).
</p>


<h6>Choosing a filesystem</h6>
<p>
The <a href="#romformats">.nds</a> ROM format and others offer space for a filesystem., and a buit-in filesystem too. The <em>ndstool</em> program can be used to add and remove files from it (use <code>ndstool -?</code> to display its help). Unfortunately there are no homebrew libraries available yet that allows reading this filesystem from the DS hardware.
</p>

<p>
Fortunately several other filesystems can be used, including the ancestor GBFS (<em>Gameboy Advance Filesystem</em>) and its successor, and now recommended, <a href="#libfat">libfat</a>, a library to manage (read/write/list) the FAT16 filesystem. It features better reentrancy support, cleaner source code, is built as a proper library and packaged as part of <a href="#devkitarm">devkitPro</a>.
</p>


<a name="usingfs"></a>
<h6>Using a filesystem</h6>
<p>
The method to use most filesystems is quite simple: one gathers first, on a PC, all the files to be stored on the ROM filesystem, sorted according to the target directory structure. 
</p>

<p>
Then a tool is used to create a single file that contains the filesystem (including these files). That file is then simply appended to the program binary. In some cases the program binary must be padded to a 256 byte boundary beforehand, thanks to the  <code>padbin</code> tool, ex: <code>padbin 256 MyProgramBinary.nds</code>. Then the filesystem can be simply appended, ex: <code>cat MyProgramBinary.nds MyFileSystem.fat &gt; MyProgram.nds</code>.
</p>

<p>
Finally the DS program have to use filesystem-specific code to manipulate its own ROM-embedded filesystem. It requires including the corresponding headers (ex: <code>#include &lt;fat.h&gt;</code>), initializing the filesystem support (ex: <code>fatInitDefault()</code>), and using the provided primitives to manipulate files (ex: <code>fopen</code>, <code>fread</code>, etc. like in POSIX systems) and directories (ex: <code>diropen</code>, <code>dirnext</code>, etc. here in a libfat-specific way).  
</p>

<p>
Note that with libfat both slot-1 and slot-2 memory can be accessed, and simultaneously. More information about the recommended lifat can be found <a href="http://chishm.drunkencoders.com/libfat/" target="_blank">here</a>.
</p>

<p>
More information about the mostly deprecated GBFS can be found <a href="http://www.double.co.nz/nintendo_ds/nds_develop6.html" target="_blank">here</a>.
</p>

<p>
More information on embedded <a href="http://www.coranac.com/tonc/text/bitmaps.htm#sec-data" target="_blank">external data</a> (written for GBA but applies to the DS as well).
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="inputdevice"></a>
<h4>Input device management</h4>

<p>
Input handling can be done thanks to the traditional gamepad, but also thanks to the touchscreen (it can be used to offer a virtual keyboard, or with a mouse-like interface, or as an handwriting tool, etc.) and/or the microphone (speaking, blowing, shouting, etc.).
</p>


<a name="keys"></a>
<h5>Keys</h5>

<p>
For all keys (or buttons) except X and Y, there is a read-only hardware register that can be read by either of the ARM to tell whether they are pressed or released. As for the X and Y keys, their state is available thanks to another register that can only be read from the ARM7.
</p>

<p>
For the ARM9 to have these last two keys, the ARM7 can read their state during the VBI and send them to the ARM9 thanks to the IPC structure. Two non-key informations can be transmitted that way too: the hinge state (DS lid open or closed) and  the stylus state (down or up , i.e. whether it is on the touchpad or not).
</p>

<p>
Note that the key state is read 60 times per second. It implies that if a key was pressed and released fast enough (it would be quite difficult though), it would not be detected. Another method, more robust, is event-based: each keypress can be detected thanks to a specific interrupt. Then no key change can be lost.
</p>

<p>
On the contrary, most user keypresses last for more than a VBI period (16 ms). Such a keypress should not be interpreted as multiple keypresses though, even if multiple iterations of the main loop in a row saw that key pressed. 
</p>

<p>
For example, if a key is used to pause/unpause a game, the user would press it once, but a too basic program would interpret it as a series of pause and unpause requests, whose length would be random, depending how many VBI were elapsed. 
</p>

<p>
Actually, from the developer point of view, current key state is far less interesting than key transition: even if knowing that a key is pressed might be useful, knowing that this key just went from the released state to the pressed state (or the opposite) is still more useful. libnds reports that information thanks to the <code>scanKeys</code>, <code>keysHeld</code>, <code>keysDown</code>, etc. primitives. 
</p>

<p>
 PAlib offers abstractions to read easily the key states, hiding the VBI interrupt, the ARM7/ARM9 IPC communication and the different bit set conventions, and offering transitional reads. 
</p>


<h5>Touchscreen</h5>

<p>
The touchpad is made of a resistive coating whose conduction changes depending on the area of the contacting object. This change is measured from a temperature, and converted into numerical values by an <a href="Analog-to-digital converter" target="_blank">Analog-to-digital converter</a>, then translated to an onscreen location.
</p>

<p>
These measurements can also be used to determine the area of the contact point which, to some degree, can be translated into pressure. If the only information wanted is whether the stylus hits the touchscreen, one should use the <code>scanKeys</code> macro. This is only if the pen is down that the stylus position can be of interest.
</p>

<p>
The touchpad communicates to the DS only via a serial interface to the ARM7. For example thanks to libnds-provided default ARM7 binary, the measured screen coordinates can be read once per frame and made available to the ARM9 (see default ARM7 template and the <code>touchReadXY</code> function).
</p>

<h5>Microphone</h5>
<p>
The built-in <a href="#soundinput">microphone</a> can be used to perform some limited speech-recognition, or to detect the user blowing air, shouting at it, etc..
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="rtc"></a>
<h4>Real-time clock</h4>
<p>
The DS keeps track of the date and of the time of day, to the second. Applications can react differently based on user time, duration since last use, etc.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="wireless"></a>
<h4>Wireless networking</h4>
<p>
The built-in Wifi support allows the DS to communicate (with a theoretical bandwith of 1-2 megabytes per second) with:
<ul>

<!--
	<li><b></b>: </li>
-->

	<li>a <b>802.11 standard access point</b> (i.e. public non-<a href="http://en.wikipedia.org/wiki/Captive_portal" target="_blank">captive portal</a> hotspots or a personal 802.11b or 802.11g wireless routers) to access the Internet. The DS supports <a href="http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy" target="_blank">WEP</a>
 encryption but not <a href="http://en.wikipedia.org/wiki/Wi-Fi_Protected_Access" target="_blank">WPA</a>. A full socket library has been implemented in the <a href="#dswifi">dswifi</a> library, which allows to port PC-originating network code to the DS</li>
 
	<li><b>other DS</b> in the vicinity, through <a href="http://en.wikipedia.org/wiki/NiFi" target="_blank">Nifi</a>, a modified WiFi protocol created by Nintendo for the DS and the Wii, partially secured using RSA security signing. It is used in non-online multiplayer mode, and to download game demos or multiplayer game software</li>
	
</ul>

</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="miscellaneous"></a>
<h4>Miscellaneous informations</h4>

<p>
Most of these informations come from the listed <a href="#detailedhardware">hardware resources</a>.
</p>


<h5>Game Logic</h5>
<p>
We saw in the <a href="#rendering">rendering section</a> that screen updates are in most cases hard-realtime synchronized, thanks to the VBI. For the overall game logic as well, a simple infinite <code>while()</code> loop in the <code>main()</code> function would not be very convenient, as either it would run at a random pace (depending on the amount of tasks to be performed on each iteration), or it would require to monitor the time interval between two iterations and to compute accordingly the behaviour of each simulated game actor. You then enter the realm of equation robustness against too high timesteps, etc.
</p>

<p>
These are real issues in the PC world where no two hardware platforms behave the same and where uncoupling all subtasks (audio/video rendering, AI, input reading, network management, etc.) becomes soon tricky, but in the console world the situation is somewhat simpler: everything ought to be hardwired and paced according to the same clock, here the 60 Hz rhythm provided by the VBI. 
</p>

<p>
Instead of putting that logic code is the VBI handler, the best way is to keep the <code>while()</code> loop in the <code>main()</code> function, but to make each iteration end with a request for the DS to sleep until next interrupt occurs (with libnds, one would use <code>swiWaitForVBlank()</code>). Therefore both rendering and logic will run at a predictable 60 Hz, and thanks to the sleeps the DS will exhaust its batteries later.
</p>


<h5>MMU</h5>
<p>
The DS does not have a Memory Management Unit (<a href="http://en.wikipedia.org/wiki/Memory_management_unit" target="_blank">MMU</a>), a hardware component responsible for handling memory accesses requested by the CPU, notably to enable virtual memory management, memory protection, cache control, bus arbitration or bank switching.
</p>

<p>
It reduces the potential stability of operating systems (as Linux; if they are to be used on a DS), and prevents to access, as fallback swap, to mass storage that would be available in slot-2-provided removable media. 
</p>


<h5>Non rendering-related hardware accelerations</h5>
<p>
The DS contains both divide and square root accelerators.
</p>


<h5>16/32 bit</h5>
<p>
The ARM7 processor supports both 32-bit and 16-bit instructions via respectively the ARM and Thumb instruction sets (the later is a subset of the former). 16-bit code is smaller than 32-bit one and, in some specific cases, faster (usually slower though). 16-bit code is often preferred, as it has more chances to fit in the tiny instruction caches. Moreover the size of ARM7 code must be in general 64 kilobytes or smaller.
</p>

<p>
The ARM9 is a full 32-bit CPU, but may be programmed in 16-bit too.
</p>

<p>
An important developing rule is to prefer using the <code>CPU native words</code> (16-bit datatype if the CPU is in 16-bit mode, 32-bit datatype if the CPU is in 32-bit mode) for most of your calculations, loop index, etc.: then the bus, the CPU registers and the instruction set will be "inline", as efficient as obtainable, whereas smaller datatypes would lead to runtime performance penalties. Unless they are packed in a structure, they will not be any smaller. Using such words only requires careful casting, because an ARM CPU is quite picky about memory alignment.
</p>



<h5>Serial Peripheral Interface</h5>
<p>
Various subsystems (power management, firmware, touchscreen, sound volume and control, microphone amplifier control and gain control, back-lighting of screens, power LED, battery status) can be accessed only thanks to the SPI (<em>Serial Peripheral Interface</em>) bus.
</p>


<h5>DMA</h5>

<p>
A <a href="http://en.wikipedia.org/wiki/Direct_memory_access" target="_blank">DMA</a> (<em>Direct Memory Access</em>) copy is basically a fast, CPU efficient, hardware accelerated copy: it allows certain hardware subsystems within the DS to access system memory for reading and/or writing independently of the CPU.
</p>

<p>
There are four prioritized DMA channels. They can transfer data asynchronously from the main CPU: the ARM9 initiates the transfer and, if it does not access to main memory, can continue its work while the DMA transfer is going on. Then it will receive an interrupt from the DMA controller once the operation has been done. It results in data transfer with much less CPU overhead. 
</p>

<p>
Note though that during a DMA transfer the CPU is locked off the bus, thus restraining a lot what it can done in the mean time. Note also that the DMA circuits are not aware of the ARM9 caches, leading to potential inconsistencies.
</p>

<p>
More information on DMA can be found in this TONC <a href="http://www.coranac.com/tonc/text/dma.htm" target="_blank">section</a>.
</p>


<a name="timers"></a>
<h5>Timers</h5>
<p>
A timer is a hardware function that can be set to raise an interrupt at regular intervals, once enabled. There are eight incrementing 16bit timers, four for each CPU.
</p>

<p>
More information on timers can be found in this TONC <a href="http://www.coranac.com/tonc/text/timers.htm" target="_blank">section</a>.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="tools"></a>
<h3>Gathering the adequate tools for homebrew</h3>

<p>
Quite a few languages can use sources directly read from the DS. Currently these are mostly interpreted (no native compiler available): there are ports for Python, Perl or Lua, maybe one day <a href="http://www.erlang.org" target="_blank">Erlang</a>. Some of them are expected to be run from DSLinux.
</p>

<p>One of course could use  <a href="http://www.coranac.com/tonc/text/asm.htm" target="_blank">ARM assembly</a> code to develop, but for most needs it would be useless overkill, as the development duration would explode for no real gain. Even with higher level languages though, some knowledge of <a href="http://www.coranac.com/tonc/text/numbers.htm" target="_blank">bit operations</a> and other low level operations is required.
</p>

<p>
As for C/C++, one needs a full build toolchain, since these languages are compiled instead of being interpreted. No native toolchain is available directly from the DS: it would demand more RAM than the built-in 4 megabytes (hence specific flash carts would be required), compilation would be long, and the development process would be quite inconvenient.
</p>

<p>
Therefore application development starts usually on a computer rather than on the DS: the built binaries are cross-compiled, i.e. they are generated on a PC but according to the conventions of another architecture (here, the DS), so that they can be executed finally on this target architecture. This is quite common in embedded environments.
</p>

<p>
Once the programs are compiled (from the C/C++ sources to a set of object files) and linked (thanks to DS-specific <a href="http://www.dev-scene.com/NDS/Tutorials_Day_2#Linker" target="_blank">linkscripts</a> telling, depending on the ARM, which and how memory regions should be used at runtime), they can be tested in place, i.e. on the PC, thanks to DS <a href="#emulators">emulators</a>, or they can be <a href="#limitations">transferred</a> to the DS and run on it.
</p>

<p>
We consider here that you have the basic tools installed on your computer, notably a text editor (vi, emacs, nedit, etc.) or an <a href="http://en.wikipedia.org/wiki/Integrated_development_environment" target="_blank">IDE</a>
 (for <em>Integrated Development Environment</em>, ex: KDevelop, VisualHAM or <a href="http://www.palib.info/wiki/doku.php?id=day1#using_palib_with_visual_c_2005_express" target="_blank">Visual C++ 2005 Express</a>, etc), and the <code>GNU make</code> program. The associated makefiles, which specify how the different targets for an application should be built (which steps, which tools, which options, etc.), are essential, as way too many commands are involved in the repetitive development process to type them directly when needed. Other generic tools should be used as well, for source control (CVS, SVN), for documentation generation (doxygen), etc.
</p>


<a name="loani"></a>
<p>
Most of the tools that will be mentioned here (i.e. devkitARM, libnds, libfat, dswifi, PAlib, DeSmuME, NO$GBA), plus dlditool, can be installed by hand or thanks the <a href="http://osdl.sourceforge.net/OSDL-latest/LOANI.html" target="_blank">LOANI</a> script, provided by OSDL for GNU/Linux users. One just has to download <a href="http://sourceforge.net/project/showfiles.php?group_id=71354&package_id=161367" target="_blank">latest</a> LOANI archive, extract it and run:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
./loani.sh --nds --buildTools
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
to have them automatically downloaded, extracted and installed in their OSDL reference version, ready to be used. All these tools are open source, and are here dedicated to the DS (thanks to the <code>--nds</code> switch).
</p>

<p>
See <a href="http://www.dev-scene.com/NDS/Tutorials_Day_1#Installation_Of_Tools" target="_blank">Dovoto's tutorial</a> and <a href="http://www.devkitpro.org/setup.shtml" target="_blank">Dave Murphy's guide</a> (maintainer of devkitARM) for more information about the installation of tools.
</p>

<p>
Note that the devkitARM tools are designed to run on 32-bit architectures. If your PC uses a 64-bit processor you will need the <code>ia32-libs</code> for Debian-based distributions.
</p>

<p>
We will now list all the major software that might be involved in homebrew development.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="devkitarm"></a>
<h4>First: the compiler toolchain, with devkitARM</h4>

<p>
We need the common build tools to generate binaries from our C/C++ sources: a preprocessor, a (ARM) compiler and a linker (not related to the cartridges, here it designates a software tool) that knows the DS ROM <a href="romformats">formats</a> and its <a href="http://www.dev-scene.com/NDS/Tutorials_Day_2#Memory_Layout" target="_blank">memory</a> layout.
</p>

<p>
Tools for commercial developers are not available for homebrewers but, luckily, there is an alternative toolchain, whose name is <a href="http://www.devkitpro.org/" target="_blank">devkitpro</a>. This toolchain is adapted from the <a href="http://en.wikipedia.org/wiki/GNU_Compiler_Collection" target="_blank">GCC</a> (<em>GNU Compiler Collection</em>) one. Its supports many consoles besides the DS (GameBoy Advance, GP32, Playstation Portable and GameCube). DS are ARM-based, hence we need to choose <a href="http://www.devkitpro.org/category/devkitarm/" target="_blank">devkitARM</a>, which provides everything we need (and more). </p>

<p>
Installing devkitARM on UNIX is straightforward: one just has to <a href="http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=124207" target="_blank">download</a> latest stable version and extract it. Nothing more needs to be done, as the toolchain is prebuilt here: you download directly the appropriate binaries, and there is not real point in recreating them from their sources.
</p>

<p>
To use the standard functions devkitARM offers (ex: <code>abs, atoi, free, getenv, rand</code>, etc.), one should specify in its source files <code>#include &lt;stdlib.h&gt;</code>.
</p>

<p>With devkitARM you will be able to write programs with all the classical C/C++ core constructs. But what about text output ? Graphics ? Touchpad or key input ? The C/C++ language and runtime do not really provide these features natively.
</p>

<p>
You could thus perform all these operations by yourself, from the lowest level. You would then have to figure out for example that, at address <code>0x4000000</code>, there is a 32-bit register that you can write to, in order to control the display. Even if most of the relevant technical <a href="#detailedhardware">information</a> is available, your time and patience might be quite quickly exhausted. Thus you can use a low level library instead, that would spare you these very significant efforts. This is the task of libnds, discussed below.
</p>

<p>
Note that <em>dynamic</em> libraries are not supported on the DS. Therefore each executable has to be statically linked with the libraries it uses. It is not a real drawback on such a platform where OS multitasking (see <a href="#linuxonds">DSLinux</a>) is not widely used. The size of your executables should not explode anormally due to the (static) linking to multi-purpose libraries, since only object files defining symbols effectively referred to will be kept. The inclusion is per object file and not per symbol, so as soon as a symbol is used, all the other symbols defined together in its objet file will be added too, even if they are not used.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="libnds"></a>
<h4>Second: the low-level library, libnds</h4>

<p>
<a href="http://en.wikipedia.org/wiki/Libnds" target="_blank">Libnds</a>, formerly named <a href="http://www.drunkencoders.com/documents/DS/ndslib.htm" target="_blank">ndslib</a>, supports nearly all features of the Nintendo DS, including: touchscreen, microphone, 2D/3D hardware, and 802.11b Wi-Fi via the dswifi library (which will be detailed below). See also the libnds <a href="http://devkitpro.sourceforge.net/devkitProWiki/libnds/" target="_blank">API</a>.
</p>

<p>
It is not the purpose of libnds to give you advanced components that would do all the work for you. It is just a thin layer that will abstract a bit hardware facilities, thanks to suitable low-level primitives which will hide unwanted technical details, such as the actual location of registers in memory.
</p>

<p>
libnds is thin enough not to really imply tradeoffs: compared to ad hoc (direct) lowest level programming, using it should not hinder anything or result in a loss of performance. 
</p>

<p>
Hence if you are not making a full use of libnds, most of the time it is that you chose to rely on higher level libraries.
</p>

<p>
The installation of libnds is trivial (just a matter of extracting the latest <a href="http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=151608" target="_blank">archive</a>). If you plan to use PAlib (discussed later), libnds will be provided with it, no need for a specific libnds install then (although the PAlib-included version is often quite outdated). 
</p>

<p>
Apart from the numerical constants (ex: addresses of registers), libnds defines several useful primitives (functions, defined in header files stored in <code>libnds/include/nds</code>) such as:
<ul>

<!--

       <li><code></code>: </li>
<-->

        <li><code>consoleDemoInit</code>, <code>consoleInitDefault</code> or <code>consoleInit</code>: initializes a text-based console so that <code>printf</code> can be used directly to write strings on a DS sub screen. See also: <code>consoleClear</code></li>

       <li><code>videoSetMode</code>, <code>vramSetBankA</code>, <code>lcdMainOnBottom</code>, etc. are used to set-up the video rendering</li>

       <li><code>irqInit</code>, <code>irqEnable</code>, etc. allow to setup the interrupt handler and manage interrupt status, for example to enable the VBI (<code>IRQ_VBLANK</code>).  See also: <code>swiWaitForVBlank</code> (<a href="#interrupts">more information</a> on interrupts)</li>

       <li>other <code>swi* functions</code> (ex: <code>swiCopy</code>) provide access to BIOS functions</li>

       <li><code>scanKeys</code>, <code>keysHeld</code>, <code>keysDown</code>, etc. simplify quite a lot key handling, with regard to positive logic, transitional states and so on (<a href="#keys">more information</a> on keys)</li>

</ul>

</p>

<p>One just has to include the libnds header (<code>#include &lt;nds.h&gt;</code> with the appropriate command-line switch <code>-IPath/To/Libnds/Headers</code>) to compile against the library. To link to it the <code>-LPath/To/Libnds/Library -lnds</code> switches have to be added, at the end of the link line (libnds does not depend on any other system-specific library, but higher level ones, such as PAlib, use libnds).
</p>

<p>
One can use also the <a href="http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=159894" target="_blank">libnds examples</a> to learn how to use the library. They are not installed by LOANI currently.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="libfat"></a>
<h4>Third: a recommended FAT library, libfat</h4>

<p>
Most applications and games need some way of reading and writing from and to non-volatile media, and to access it as a filesystem rather than, say, a sequence of data blocks. This is useful notably to read resource files (images, sounds, etc.) and to write highscores, settings and saved games.
</p>

<p>
In the case of the DS, many filesystems could be used, but one of them, FAT16, is by far the most common. To manage such filesystems, a dedicated library, <a href="http://chishm.drunkencoders.com/libfat/" target="_blank">libfat</a>, can be used. It depends on libnds, both of which being packaged as part of DevkitARM.
</p>

<p>
With libfat files can be managed almost exactly as they would be on POSIX systems. Directories follow different conventions. See also our <a href="#usingfs">section</a> about the use of filesystems for the DS.
</p>

<p>
Note that libfat allows only to read directly the filesystems in the first partition of slot-1 and slot-2 cards: it does not allow to read a FAT filesystem embedded in a ROM, i.e. directly stored in the application executable. Using embedded filesystems can be convenient, so that the application is entirely self-contained (as commercial games for example) and the user does not have to and cannot mess with the various application files. To use a FAT filesystem embedded in a ROM, one may use <a href="#libefs">libefs</a>.
</p>

<p>
Note also that in its current form, libfat cannot be used by default nor efficiently with the ARM7: the library is too large to fit in its at most 96 kB of fast RAM. To use libfat nevertheless with the ARM7, the linker script should be modified so that the ARM7 executable is stored in main memory. But this RAM is quite slower than the IWRAM.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="libefs"></a>
<h4>Fourth: a library to manage ROM-embedded filesystems, libefs</h4>
<p>
libefs allows to manage a ROM-appended file system, on slot-1 or slot-2 cards. It is, to a certain extent, a homebrew counterpart to the official (Nintendo proprietary) NitroFS filesystem.
</p>

<p>
libefs has to know the target card filesystem (most generally FAT, in that case libefs depends on libfat) to locate first the ROM, so that it can find in it its embedded filesystem: most of the problem comes from the fact that a running homebrew program does not know the name of the ROM file that it was loaded from (<code>argv[]</code> cannot be set, at least is not set currently).
</p>

<p>
Once libefs is initialized, reading files and listing directories in that embedded filesystem is supported. Writing to files can be performed (self-modifying ROM), provided that a file with the target name already exists and was created with a sufficient size (space must be already allocated). Thus filenames must be planned, and sizes too: at ROM generation, just create a file with random content (or, better, all zero) of the right size, and modify its content at runtime. For example, 
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
echo "Meant to be overwritten!" > MyFutureContentFile.dat 
devkitPro/devkitARM/bin/padbin 1000 MyFutureContentFile.dat
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
Then <code>MyFutureContentFile.dat</code> will be a 1000-byte file whose content could be change at runtime, once included in the ROM embedded filesystem. 
</p>

<p>Multiple files can be opened at the same time by libefs.
After a series of writes, make sure you call <code>EFS_Flush</code>, to ensure data is actually written.
</p>

<h5>Creating a NDS executable with an embedded libefs-supported filesystem</h5>
<p>
Creation and appending of the filesystem is performed directly by <code>ndstool</code>: libefs plays mostly a role afterwards, at runtime. Therefore one has to ensure that the ARM executable (ARM7 and/or ARM9) that will access to the embedded filesystem is indeed linked with libefs.
</p>

<p>
All the files and directories to be put in the ROM filesystem should be copied in a root dedicated directory (ex: <code>MyFutureNitroFS</code>) in your project directory, on your PC, with the desired organization (file hierarchy). Then, when creating your .nds ROM with <code>ndstool</code>, you have to specify of course your ARM7 and ARM9 executables, but also here your content directory, as "data files", i.e. with the <code>-d</code> option. For example:
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
ndstool -c MyGame.nds -7 MyARM7Exec.bin -9 MyARM9Exec.bin -d MyFutureNitroFS
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
The resulting .nds should be patched thanks to <code>efs.exe</code> before being distributed (this allows to prepare some space in the ROM header for the cached location of the libefs-enabled ROM in the card, to look up afterwards the appended filesystem).
</p>

<p>
As usual, the end user may need to DLDI-patch its ROM so that it can work on his target slot-1 or slot-2 device.
</p>

<p>
The build process is a bit different if using a slot-2 device that does not have a libfat support or if targeting an emulator: the ROM should not include at first your appended data (hence <code>ndstool</code> is only given the two ARM executables), but you should create a FAT image (ex: <code>MyFATImage.img</code>) containing your data files (i.e. the content of the previously mentioned <code>MyFutureNitroFS</code> directory).
</p>

<p>
Once your .ds.gba ROM padded to a 512-byte boundary (<code>devkitPro/devkitARM/bin/padbin 512 MyGame.ds.gba</code>), just append your FAT image (ex: <code>cat MyGame.ds.gba MyFATImage.img &gt; MyGameWithFS.nds</code>). Finally one just to apply the <code>fcsr</code> DLDI patch to enjoy its ROM. Apparently it uses the <code>gba_nds_fat</code> system to read the FAT image. See these <a href="http://forum.gbadev.org/viewtopic.php?p=114090&highlight=fcsr+dldi#114090" target="_blank">posts</a> for more information.
</p>


<p>
In all cases, if the ROM (say, the .nds file), ends up, because of the libefs-embedded filesystem, with a size that exceeds 4 MB, the loader will load the ARM7 and ARM9 executables to RAM, and ignore the trailing data, which will remain usable though.
</p>

<p>
See 
<a href="http://forum.gbadev.org/viewtopic.php?t=13195" target="_blank">libefs main article</a> and this other <a href="http://forum.gbadev.org/viewtopic.php?t=13080" target="_blank">thread</a>
for more details.
</p>



<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="dswifi"></a>
<h4>Fifth: a useful library to manage Wifi, dswifi</h4>

<p>
<a href="http://akkit.org/dswifi/" target="_blank">dswifi</a> (see also
<a href="http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=199021" target="_blank">here</a>) offers a low level interface to the DS Wifi connectivity. Access points, connexions, IP adresses, frames and packets can be easily handled thanks to that library. This allows to use the standard (IEEE 802.11) Wifi connectivity, currently no homebrew library allows to communicate using the proprietary (Nintendo-specific) Nifi protocol.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="palib"></a>
<h4>Sixth: an (optional) higher level library, PAlib</h4>

<p>
<a name="palibtoc"></a>
<center>
        <table summary="Table of contents" style="border: none">
        <tr>
          <td>
<!--
                       <a href="#"></a><br>
-->

                   <div class="box">
                       <a href="#palibwhat">What PAlib is</a><br>
                       <a href="#palibwho">Who should use PAlib</a><br>
                       <a href="#palibprovides">What PAlib provides</a><br>
			<ul>
				<li><a href="#palibconventions">Conventions</a></li>
				<li><a href="#palibbasic">Basic primitives</a></li>
				<li><a href="#palibsync">Synchronization</a></li>

				<li><a href="#palibtext">Text output</a></li>
				<ul>
					<li><a href="#palibtiledtext">Tile-based font rendering</a></li>
					<li><a href="#palibsofttext">Software-rendered fonts</a></li>
					<li><a href="#palibtextprimitives">Text rendering primitives</a></li>
				</ul>

				<li><a href="#palibinput">Input device management</a></li>
				<ul>
					<li><a href="#palibinputkeys">Keys</a></li>
					<li><a href="#palibinputtouch">Touchscreen</a></li>
					<li><a href="#palibinputkeyboard">Virtual keyboard</a></li>
					<li><a href="#palibinputshape">Hand-written shape recognition</a></li>
				</ul>

				<li><a href="#palibsprites">Sprite management</a></li>
				<ul>
					<li><a href="#palibspritebasics">Sprite basics</a></li>
					<li><a href="#palibspriterotscale">Rotation &amp; scaling</a></li>
					<li><a href="#palibspritesfx">Flipping, mosaïc, alpha-blending</a></li>
					<li><a href="#palibspriteframe">Frames &amp; animations</a></li>
					<li><a href="#palibspritedual">Virtual double screen: dual sprites</a></li>
					<li><a href="#palibspritecollision">Sprite collisions</a></li>
				</ul>

				<li><a href="#palibbackground">Background management</a></li>
				<ul>
					<li><a href="#palibbackgroundtypes">Three types of backgrounds</a></li>
					<li><a href="#palibbackgroundtiled">Tiled backgrounds</a></li>
					<li><a href="#palibbackgroundtiledscroll">Tiled background scrollings</a></li>
					<li><a href="#palibbackgroundframebuffer">8-bit &amp; 16-bit framebuffer backgrounds</a></li>
					<li><a href="#palibbackgroundrot">Rotation backgrounds</a></li>
				</ul>
				<li><a href="#palib3D">3D</a></li>
				<li><a href="#palibmovie">Movie playback</a></li>
				<li><a href="#palibsound">Sound</a></li>
				<li><a href="#palibfs">Filesystem</a></li>
				<li><a href="#palibwifi">Wifi communications</a></li>
			</ul>
                       <a href="#palibbuilding">Building with PAlib</a><br>
                       <a href="#palibinstall">Installing PAlib</a><br>
                       <a href="#palibalternate">Alternate choices to PAlib</a><br>
<!--                       <a href="#"></a> -->
          </div>

          </td>
        </tr>
      </table>
</center>

<center>[<a href="#toc">Back to the main table of contents</a>]</center>
</p><br><br>


<!--
<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>
-->

<a name="palibwhat"></a>
<h5>What PAlib is</h5>
<p>
<a href="http://www.palib.info" target="_blank">PAlib</a> (<a href="https://sourceforge.net/projects/pands/" target="_blank">alternate site</a> on Sourceforge) is one of the highest level abstracting libraries. It is built on top of libnds and offers various higher-level integrated services to the homebrewer.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibwho"></a>
<h5>Who should use PAlib</h5>
<p>
Like HAM for the <em>GameBoy Advance</em>, its intended public is developers wanting to use the most time-effective methods to write their software. Hardware purists often consider any library beyond libnds being useless (bloating software), restrictive or performance-killer. One should try both ways to make one's opinion.
</p>

<p>
As for me, I found interesting to use first libnds only, to learn how things work. Once done, anything allowing to gain some time sounds interesting to me, and I would not like to reinvent the wheel too often. So I use PAlib quite frequently, often after studying the sources to understand how each of its primitives is implemented.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibprovides"></a>
<h5>What PAlib provides</h5>

<p>
The PAlib library encapsulates hardware-related operations into higher level C structures and functions, whose suffix is <code>PA_</code>. One should read the <a href="http://www.palib.info/wiki/doku.php" target="_blank">official tutorial</a> first, before consulting the <a href="http://www.palib.info/Doc/PAlibDoc Eng/main.html" target="_blank">full API documentation</a>. There are many useful examples in the <code>PAlibExamples</code> package, and in the following sections: <a href="http://www.palib.info/wiki/doku.php?id=day12" target="_blank">Quick Demos</a>, Platform Game (<a href="http://www.palib.info/wiki/doku.php?id=day13" target="_blank">first</a> version, <a href="http://www.palib.info/wiki/doku.php?id=day15" target="_blank">second</a> one) and <a href="http://www.palib.info/wiki/doku.php?id=day14" target="_blank">Carré Rouge</a>.
</p>

<p>
Some of the most common services (not all) offered by PAlib will be discussed here.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibconventions"></a>
<h6>Conventions</h6>
<p>
<ul>
        <li><b>Screens</b> are designated by a bool: true (1) for the top one, false (0) for the bottom one</li>
        <li><b>Tile coordinates</b> range from 0 to 31 horizontally, and from 0 to 19 (not the expected 23) vertically. They are encoded in 16-bit unsigned integers (<code>u16</code>)</li>
        <li><b>Backgrounds</b> range from 0 to 3</li>
        <li>PAlib behaves somewhat like a <b>state machine</b>. For example, after <code>PA_InitText</code> specified which background is to be used for a given screen, text rendering on that screen will use implicitly that background</li>
        <li>The <b>headers</b> where symbols are declared, the <b>implementation</b> files where they are defined are specified here between brackets (filenames are separated by "-" when a symbol is defined more than once, for example one time for each ARM). Ex: [Header: <code>PA_General.h</code> ; Implementation: <code>armX/PA.c</code>]. The X in armX signifies either 7 or 9, as both define it</li>
        <li>There is a <b>FPS</b> counter for each screen, which keeps track of the number of frames per second (60 if using the VBL and not taking longer than 16.7ms to execute). This allows to perform time-based animations, and to <a href="http://www.palib.info/wiki/doku.php?id=day6#get_the_fps" target="_blank">monitor</a> actual FPS</li>

</ul>
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>

<!--
        <li><b></b>: </li>
-->

<!--
<h6></h6>
<p>
<ul>
        <li><code></code>: [Header: <code></code>; Implementation: <code></code>]</li>
</ul>

</p>
-->

<a name="palibbasic"></a>
<h6>Basic primitives</h6>
<p>
<ul>

        <li><code>PA_Init()</code>: initializes the library. Must be used at the beginning or main(). [Header: <code>PA_General.h</code>; Implementation: <code>armX/PA.c</code>]
	<ul>

		<li><b>ARM7</b>: real-time clock read, enables sound (subsystem powered on, volume set, IPC set, microphone on), IPC set</li>

        	<li><b>ARM9</b>: 2D subsytem initialized, lid state updated, real-time clock read from ARM7, random generator seeded from current time, VBL counter reset, stylus coordinates initialized to screen center, interrupts initialized (including VBL), IPC set, for each screen: brightness set to visible, state initialized</li>
	</ul>
	</li>

        <li><code>PA_InitRand</code>, and <code>PA_Rand</code>, <code>PA_RandMax</code>, <code>PA_RandMinMax</code>: they allow respectively to seed for the real-time clock the random number generator (to avoid obtaining always the same random sequences), and to generate random values between specified bounds [Header and Implementation: <code>arm9/PA_Math.h</code>]</li>

        <li><code>PA_GetAngle</code>, <code>PA_Sin</code> and <code>PA_Cos</code>: fast trigonometric-related functions, explained <a href="http://www.palib.info/wiki/doku.php?id=day6#trajectories_and_angles" target="_blank">here</a></li>

        <li><code>PA_RTC</code>: to read time and date</li>

        <li><code>PA_UserInfo</code>: to read user informations (name, birthday, language, message, alarm)</li>
        <li><code>PA_SetScreenLight</code>: to set the screen backlighting</li>

        <li>your homebrew can be customized thanks to <code>TEXT1, TEXT2 and TEXT3</code>: see the root makefile</li>

        <li><code>hardware windows</code> can be managed, see this <a href="http://www.palib.info/Doc/PAlibDoc Eng/group___window.html#ga1" target="_blank">API</a>. [Header and Implementation: <code>PA_Window.h</code>]</li>

</ul>

</p>

<p>
See also the API documentation for <a href="http://www.palib.info/Doc/PAlibDoc Eng/group___general.html" target="_blank">general functions</a>.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibsync"></a>
<h6>Synchronization</h6>
<p>
<ul>

        <li><code>PA_InitVBL()</code>: prepares the use of the VBL to synchronize operations, by setting VBL PAlib handler and enabling the VBL [Header and Implementation: <code>arm9/PA_Interrupt.h</code> - <code>arm7/PA.c</code>]</li>

        <li><code>PA_WaitForVBL()</code>: puts the DS in sleep mode, waiting to be awoken by the VBL interrupt. It powers off some subsystems (starting from the ARMs), which saves battery charge. Lid might be checked here [Header and Implementation: <code>arm9/PA_General.h</code>]</li>

       <li><code>PA_SetAutoCheckLid</code>, <code>PA_CheckLid</code>, <code>PA_LidClosed</code>: lid can be automatically checked at each VBL. Should it be closed, the DS will shutdown automatically until the lid is opened again, as most commercial games do [Header and Implementation: <code>arm9/PA_General.h</code>]</li>

</ul>

</p>

<p>
See also the API documentation for <a href="http://www.palib.info/Doc/PAlibDoc Eng/_p_a___interrupt_8h.html" target="_blank">interrupts</a>.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>



<a name="palibtext"></a>
<h6>Text output</h6>


<a name="palibtiledtext"></a>
<h7>Tile-based font rendering</h7>

<p>
There is a 10-color <b>preset palette</b> for text rendering: white (0), red (1), green (2), blue (3), magenta (4), cyan (5), yellow (6), lightgray (7), darkgray (8), black (9).
</p>

<p>
Text can be cleared by printing at the same location a string containing as many spaces as there were characters in the previously rendered string.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibsofttext"></a>
<h7>Software-rendered fonts</h7>
<p>
Most text primitives are tile-based. If it allows them to be simple and fast (since they are hardware-accelerated), they are fixed-width and have to fit in 8x8 tiles. So software-rendered fonts have been added, see for example <code>PA_SmartText</code>.
</p>

<p>
These are plotted in framebuffer mode, and allows for fonts of different sizes and, in a given font, for characters themselves of different sizes (variable width). PAlib offers by default five different font sizes, numbered 0 to 4, starting from characters 4 or 5 pixels wide and tall (probably too small to be readable without efforts) to far bigger fonts.
</p>

<p>
Last choice with these framebuffer-based fonts is the color depth they use. They can be either in 16 colors only, for better speed and lower memory footprint (see <code>PA_16cText</code>). Or they may have a 8-bit color depth, to benefit from 256 colors and from the possibility of being rotated by the hardware of +Pi/4 or -Pi/4, so that the DS can be held in portrait mode rather than in landscape mode (see <code>PA_SmartText</code>).
</p>

<p>
Variable character spacing leads to better looking and more compact text renderings, at the expense of: speed (such software rendering is a lot slower), simplicity of use (for example with these fonts the background has to be cleared first), and absence of direct printf-like formatting (which would be still slower, though it can done separatly if needed, with <code>sprintf</code> for example).
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibtextprimitives"></a>
<h7>Text rendering primitives</h7>

<p>
<ul>

        <li><code>void PA_InitText(u8 screenNumber, u8 backgroundNumber)</code>: initializes the Palib module dedicated to text rendering, including a preset 10-color palette. It loads the appropriate font data in VRAM and selects the specified screen and backgrounds. That same background will be used for all next text renderings to this screen. Works only in modes 0, 1 and 2. [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_Text.c</code>]</li>

        <li><code>void PA_SetTextTileCol(u8 screenNumber, u8 color)</code>: sets the specified color (0 to 9) from preset palette as current text color for next renderings. [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_Text.c</code>]</li>
 
       <li><code>PA_SetTextCol(u8 screenNumber, u16 r, u16 g, u16 b)</code>: sets the specified RGB color as current text color for all text renderings (next and already rendered ones). Each color component should be in 0..31. [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_Text.c</code>]</li>
 
       <li><code>void PA_SetTileLetter(u8 screenNumber, u16 tileAbscissa, u16 tileOrdinate, char letter)</code>: renders the specified letter in specified screen to specified location. [Header and Implementation (macro): <code>arm9/PA_Text.h</code>]</li>

        <li><code>u16 PA_OutputSimpleText(u8 screenNumber, u16 tileAbscissa, u16 tileOrdinate, const char * text)</code>: renders the specified C-string (null terminated) in specified screen to specified location, after having removed any previous text that would be already in the target location. Returns the number of letters rendered. [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_Text.c</code>]</li>

        <li><code>void PA_OutputText(u8 screenNumber, u16 tileAbscissa, u16 tileOrdinate, const char * text, ...)</code>: renders the specified C-string, respecting a specified printf-like format, in specified screen, after having removed any previous text that would be in the target location. Manages the extra variable-length parameters a bit like printf: %s to output another string, %d to output a value, %fX to output a float with X digits, \n to go to the next line, %cX to choose one of the 0..9 colors from the preset palette. Here's the API example:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
PA_OutputText(0, 0, 1, "My name is %s and I have only %d teeth", "Mollusk", 20);
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
 Far richer than <code>PA_OutputSimpleText</code>, but quite slower. [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_Text.c</code>]</li>
 
        <li><code>u32 PA_BoxText(u8 screenNumber, u16 basex, u16 basey, u16 maxx, u16 maxy, const char *text, s32 limit)</code>: renders the specified C-string so that it fits in the specified box (whose upper-left corner is (basex, basey), lower-right corner being (maxx,maxy)), using word-wrapping. No more than <code>limit</code> characters will be rendered. [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_TextSpecial.c</code>]</li>

        <li><code>u32 PA_BoxTextNoWrap(u8 screenNumber, u16 basex, u16 basey, u16 maxx, u16 maxy, const char *text, u32 limit)</code>: renders the specified C-string so that it fits in the specified box (whose upper-left corner is (basex, basey), lower-right corner being (maxx,maxy)), even by cutting words (no word-wrapping). No more than <code>limit</code> characters will be rendered. [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_TextSpecial.c</code>]</li>

        <li><code>void PA_ClearTextBg(u8 screenNumber)</code>: clears all text tile entries in the map, resets the print states [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_Text.c</code>]</li>

        <li><code>void PA_InitCustomTextEx(u8 screenNumber, u8 bg_select, void *tiles, text)</code>: initializes the font module with specified custom font, made thanks to PAGfx. <code>text</code> is a symbol name corresponding to the filename of the font image converted with PAGfx. [Header and Implementation (macro): <code>arm9/PA_Text.h</code>]</li>

        <li><code>void PA_ShowFont(u8 screenNumber)</code>: displays the full font being used currently. Useful for debugging purposes [Header and Implementation (macro): <code>arm9/PA/PA_Text.c</code>]</li>
 
        <li><code>s16 PA_SmartText(u8 screenNumber, s16 basex, s16 basey, s16 maxx, s16 maxy, char* text, u8 color, u8 size, u8 transp, s32 limit)</code>: renders the specified C-string so that it fits in the specified box (whose upper-left corner is (basex, basey), lower-right corner being (maxx,maxy)), using word-wrapping and a <b>variable-width</b> font on an 8 bit background (see <code>PA_Init8bitBg</code>). <code>color</code> is the color index in the palette (0..255). <code>size</code> is the font size and ranges from 0 (really small) to 4 (pretty big). No more than <code>limit</code> characters will be rendered. <code>transp</code> will clear the text location before rendering if equal to zero, will render on top of previous content if one, will not render anything but count the letters if two, will rotate of Pi/4 the text if three, of -Pi/4 if four. [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_Text.c</code>]</li>

        <li><code>s16 PA_CenterSmartText(u8 screenNumber, s16 basex, s16 basey, s16 maxx, s16 maxy, char* text, u8 color, u8 size, u8 transp)</code>: renders the specified C-string so that it fits <b>centered</b> in the specified box (whose upper-left corner is (basex, basey), lower-right corner being (maxx,maxy)), using word-wrapping and a <b>variable-width</b> font on an 8 bit background (see <code>PA_Init8bitBg</code>). <code>color</code> is the color index in the palette (0..255). <code>size</code> is the font size and ranges from 0 (really small) to 4 (pretty big). No more than <code>limit</code> characters will be rendered. <code>transp</code> will clear the text location before rendering if equal to zero, will render on top of previous content it if one, will not render anything but count the letters if two, will rotate of Pi/4 the text if three, of -Pi/4 if four. [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_Text.c</code>]</li>

        <li><code>void PA_8bitCustomFont(bit8_slot, bit8_fontName)</code>: adds a custom font to the 8-bit font system. The specified font must have been converted with PAGfx. The 0-4 font slots are set by PAlib (but may be reset if needed), whereas the 5-9 slots are left free for the user. [Header and Implementation (macro): <code>arm9/PA_Text.h</code>]</li>

        <li><code>void PA_InitTextBorders(u8 screenNumber, u8 x1, u8 y1, u8 x2, u8 y2)</code>: defines a text box with borders, so that primitives for box font rendering can be used in it. Up to one such box can be used. [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_TextSpecial.c</code>]</li>

        <li><code>void PA_EraseTextBox(u8 screenNumber)</code>: erases the text in the text box defined thanks to <code>PA_InitTextBorders</code>. [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_TextSpecial.c</code>]</li>

        <li><code>u32 PA_SimpleBoxText(u8 screen, const char *text, u32 limit)</code>: renders the specified C-string so that it fits in the previously initiliazed textbox, using word-wrapping. No more than <code>limit</code> characters will be rendered. Same as <code>PA_BoxText</code>, but using text borders already defined. [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_Text.c</code>]</li>

        <li><code>void PA_ClearTextBg(u8 screenNumber)</code>: clears all text tile entries in the map, resets the print states [Header: <code>arm9/PA_Text.h</code>; Implementation: <code>arm9/PA/PA_Text.c</code>]</li>

</ul>
</p>

<p>
Text output primitives taking an argument for string size (text length) are useful to perform per-character progressive typing, by incrementing this size at each VBL for example. One has to ensure with boxed text that the string is not too long: its size must not be higher than <code>(maxx - basex)*(maxy - basey)</code>.
</p>

<p>
Colored texts can be rendered per letter (see the <code>%cX</code> format switch with primitives like <code>PA_OutputText</code>) or per-string (see <code>PA_SetTextTileCol</code>). In all cases the color definition of a palette index can be redefined, see <code>PA_SetTextCol</code>.
</p>

<p>
Other functions include <code>PA_CompareText</code> (to compare two strings), <code>PA_CopyText</code> (to copy one string into another), <code>PA_Print</code> (to print text without specifying a location), <code>PA_PrintLetter</code> (same thing for one letter instead of a text). There are some special effects for font rendering, defined in <code>PA_OutputTextSpecialX</code>, with X in 0..5. 
</p>

<p>
One may use <code>PAFont</code> to create custom fonts, see this <a href="http://www.palib.info/wiki/doku.php?id=day3#custom_font section" target="_blank">section</a> of PAlib tutorial. Another more recent tool is <a href="http://palib.info/forum/modules/newbb/viewtopic.php?viewmode=flat&type=&topic_id=3108&forum=10" target="_blank">dsFont</a>.
</p>

<p>
A PAlib text tutorial can be found <a href="http://www.palib.info/wiki/doku.php?id=day3" target="_blank">here</a>, and the associated API for text output is <a href="http://www.palib.info/Doc/PAlibDoc Eng/_p_a___text_8h.html" target="_blank">here</a>.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>



<a name="palibinput"></a>
<h6>Input device management</h6>


<a name="palibinputkeys"></a>
<h7>Keys</h7>

<p>
Button states can be read from the <code>Pad</code> structure. Here K will be the name of a key, in {Left, Right,Up,Down,A,B,Select,Start,X,Y,L,R}. For each key, both the current state (in <code>Pad.Held.K</code>) and the transitional state (in <code>Pad.Released.K</code> and <code>Pad.Newpress.K</code>) will be automatically updated (as boolean values) during the VBL (once per frame), to know respectively if this key is currently pressed, if it just went from pressed to released, or from released to pressed. Transitions last just for one frame.
</p>

<p>
For further informations, refer to PAlib <a href="http://www.palib.info/wiki/doku.php?id=day3#pad" target="_blank">pad tutorial</a> and to the <a href="http://www.palib.info/Doc/PAlibDoc Eng/group___keys.html" target="_blank">Key input system</a> section of the API. Main header is <code>arm9/PA_Keys.h</code>, main implementation is <code>arm9/PA/PA_Keys.c</code>.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibinputtouch"></a>
<h7>Touchscreen</h7>

<p>
The stylus is managed in a very similar way to the keys: it is updated once per frame, and in <code>Stylus.Held</code>, <code>Stylus.Released</code> and <code>Stylus.Newpress</code> one can know whether it is up or down, and if it is just after a transition or if it has been already so for a while.
</p>

<p>
For further informations, refer to PAlib <a href="http://www.palib.info/wiki/doku.php?id=day3#stylus" target="_blank">stylus tutorial</a> and to the <a href="http://www.palib.info/Doc/PAlibDoc Eng/group___keys.html" target="_blank">Key input system</a> section of the API. Main header is <code>arm9/PA_Keys.h</code>, main implementation is <code>arm9/PA/PA_Keys.c</code>.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibinputkeyboard"></a>
<h7>Virtual keyboard</h7>

<p>
This is in my opinion one of the most interesting features of Palib. This module displays a keyboard bitmap on the touchscreen and allows the stylus to select keys, so that text can be input in a rather convenient way.
</p>

<p>
After having been set-up in a free background thanks to <code>PA_InitKeyboard</code>, the keyboard can be smoothly scrolled to a given position when created with <code>PA_KeyboardIn</code>: it slides in from the bottom, and can slide out with <code>PA_KeyboardOut</code>. Its two colors can be changed thanks to <code>PA_SetKeyboardColor</code> (as for the background color, one should use <code>PA_SetBgPalCol</code>. <code>PA_CheckKeyboard</code> allows finally to read the characters being hit: any non-null return code designates directly the newly read key. 
</p>

<p>
The keyboard pictures (two of them are necessary, to show the available characters depending on the shift key being selected on not) are located in <code>lib/arm9/PA/keyboard.bmp</code>, which allows for skinnable keyboards (see also the <code>PA_InitCustomKeyboard</code> macro).
</p>

<p>
For further informations, refer to PAlib <a href="http://www.palib.info/wiki/doku.php?id=day3#keyboard" target="_blank">pad tutorial</a> and to the <a href="http://www.palib.info/Doc/PAlibDoc Eng/group___keyboard.html" target="_blank">Keyboard</a> section of the API.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibinputshape"></a>
<h7>Hand-written shape recognition</h7>

<p>
This is another quite amazing feature: powerful and really easy to use. Priceless for games needing to draw specific shapes (ex: runes) or as an alternative to the virtual keyboard.
</p>

<p>
Shape recognition can be used either to input <a href="http://www.palib.info/wiki/doku.php?id=day3#pa_graffiti" target="_blank">PA Graffiti</a> (standard shapes that map to letters) or custom-made patterns.
</p>

<p>
For PA Graffiti input, one just has to call each frame <code>PA_CheckLetter</code>, and everything will behave like in the case of <code>PA_CheckKeyboard</code>, when the virtual keyboard was used.
</p>

<p>
For recognition of custom-made shapes, one just has to first disable the PA Graffiti input (thanks to <code>PA_UsePAGraffiti(0)</code>), then to associate shapes to letters before reading recognized symbols thanks to <code>PA_CheckLetter</code> once again. Quite impossible to be simpler.
</p>

<p>
But how can such a custom-shape be described ? Just draw it yourself on the touchscreen, and make it be read by the system with <code>PA_RecoShape</code>. It will return an encoded string describing the shape you drew. You then just have to store it in your program, and register it thanks to <code>PA_RecoAddShape</code> so that the module will be able to recognize this shape afterwards.
</p>

<p>
In the <code>PA_RecoInfo</code> structure, which is updated when the stylus is just released, some other informations are stored: the total length in pixels of the drawing, the starting and ending points, and a bounding box of the drawing, the smallest upright rectangle that encloses the shape.
</p>

<p>
I found this feature really impressive indeed.
</p>

<p>
For further informations on shape recognition, refer to the dedicated section in <a href="http://www.palib.info/wiki/doku.php?id=day3#shape_recognition" target="_blank">PAlib tutorial</a> and to the <a href="http://www.palib.info/Doc/PAlibDoc Eng/group___reco.html" target="_blank">Shape Recognition</a> section of the API.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>



<a name="palibsprites"></a>
<h6>Sprite management</h6>


<a name="palibspritebasics"></a>
<h7>Sprite basics</h7>
<p>
Sprite palettes can be loaded thanks to <code>PA_LoadSpritePal</code>, then sprites using them can be created with <code>PA_CreateSprite</code>, which sets the number of the sprite, thus its priority in its background. Once done they can be moved, either thanks to the stylus with <code>PA_MoveSprite</code> (touching the sprite will link its center to the stylus and make it follow its movements until released, see also <code>PA_SpriteTouched</code>), or, more frequently, with the very simple <code>PA_SetSpriteXY</code> (or <code>PA_SetSpriteX</code>, or <code>PA_SetSpriteY</code>).
</p>

<p>
One just has not to forget they set the upper-left corner of the sprite, whereas often it is moved center-wise, and that coordinates are wrapped around. Reciprocally sprite positions can be read, thanks to <code>PA_GetSpriteX</code> and <code>PA_GetSpriteY</code>.
</p>

<p>
As opposed to the previous per-sprite priority in a given background (default one is background #0), a sprite can be associated with the background having another (lower) priority thanks to <code>PA_SetSpritePrio</code>.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibspriterotscale"></a>
<h7>Rotation &amp; scaling</h7>

<p>
Sprites can be as well rotated and scaled (both from their center point), when associated to one of the 32 rotsets. (0..31). <code>PA_SetSpriteRotEnable</code> allows to associate a sprite to a rotset, knowing that multiple sprites can share the same rotset, if they are to be rotated and scaled the same way.
</p>

<p>
Then rotsets can be modified, with regard to scale, zoom and both by, respectively, <code>PA_SetRotsetNoZoom</code>, <code>PA_SetRotsetNoAngle</code> and <code>PA_SetRotset</code>. The specified angles are in 0..511, counter-clockwise. The zoom factors can be 256 (normal size), 512 (half size), 128 (double size), and can be set independently for abscissa and ordinates. Finally a sprite can be detached from its rotset thanks to <code>PA_SetSpriteRotDisable</code>.
</p>

<p>
When rotated and/or scaled up, the sprite might exceed the rectangular size declared at its creation (ex: 32x32). In this case it will be clipped (exceeding parts will be cut), unless <code>PA_SetSpriteDblsize</code> is used to double the dimensions of its clipping rectangle (hence quadrupling the clipping area). One must then take into accound the fact that it will offset the sprite position, as the sprite is always located relatively to the upper left corner of its clipping box.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>



<a name="palibspritesfx"></a>
<h7>Flipping, mosaïc, alpha-blending</h7>

<p>Sprites can be flipped horizontally (<code>PA_SetSpriteHflip</code>) and/or vertically (<code>PA_SetSpriteVflip</code>). The mosaïc effect can be used on them, thanks to <code>PA_SetSpriteMosaic</code> first, then <code>PA_SetSpriteMosaicXY</code> (the specified mosaïc settings will be common to all sprites having the mosaïc effect enabled). The same stands for transparency (alpha-blending, whose level ranges from 0 for transparent to 15 for the default, solid): all sprites having it enabled (thanks to <code>PA_SetSpriteMode</code>), once the option is activated on the backgrounds (with <code>PA_EnableSpecialFx</code>), share the same transparency level (set by <code>PA_SetSFXAlpha</code>) 
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>



<a name="palibspriteframe"></a>
<h7>Frames &amp; animations</h7>

<p>
Frames are basically animation steps for a given sprite. All such frames should be put on a tall unique image, each being on top of the other after the conversion (as a consequence all the frames have to share the same palette). The sprite itself would be created as if it was made of only one image, then <code>PA_SetSpriteAnim</code> would be used to select one of the sprite frames, which will be the sprite current bitmap. Note that selecting a new frame triggers the copy of this frame to tile memory, an operation that takes some resources and may slow down an application should too many frames be replaced.
</p>

<p>
Thus frames allow to choose directly, for each sprite, which of its multiple images will to be displayed. But it is still up to the developer to manage the overall animation, with regard to frame selection and timing.
</p>

<p>
Animations push one step further the process: they automate the frame management. The developer just has to specify the starting frame, the ending frame, the pace (animation speed, expressed in frames per second) to
<code>PA_StartSpriteAnim</code>. Then at this function return, the animation will start and perform an infinite looping, until either <code>PA_StopSpriteAnim</code> or <code>PA_PauseSpriteAnim</code> is called, respectively to stop or pause the animation.
</p>

<p>
To spare some memory, symetrical frames can be included only in one version, using the hardware-accelerated <code>PA_SetSpriteHflip</code> and <code>PA_SetSpriteVflip</code> to flip them horizontally and/or vertically just before their animation step comes.
</p>

<p>
Lastly, one may choose, thanks to the two extra options offered by <code>PA_StartSpriteAnimEx</code>, the animation type, i.e. whether the frames are displayed in a basic loop (<code>ANIM_LOOP</code>, frame #1 to #n, then #1 to #n, etc.), in a back and forth way (<code>ANIM_UPDOWN</code>, frame #1 to #n, then #n to #1, then #1 to #n, etc.) or just once (<code>ANIM_ONESHOT</code>). The number of cycles can be chosen with the second extra option, with <code>-1</code> for infinite cycling, and a positive number to set the number of cycles to that value. Note that with <code>ANIM_UPDOWN</code>, going back and forth uses two cycles.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibspritedual"></a>
<h7>Virtual double screen: dual sprites</h7>

<p>
This features allows to manage both screens as if they formed a single double-sized one: ordinates ranges from 0 to 383 (starting from the top-left pixel of the top screen), instead of 0 to 191 (twice).
</p>

<p>
This can be obtained by using the <code>Dual</code> prefix (ex: <code>PA_DualCreateSprite</code>, <code>PA_DualSetSpriteXY</code>, <code>PA_DualSetSpriteRotEnable</code>, etc.). In this case no screen parameter is to be specified, as there is only one logical screen. 
</p>

<p>
The hinge space between the two screens can be abstracted (as if it did not exist, the two screen being directly one on top of the other) or, on the contrary, managed as if it were a hidden part of the overall logical screen. For the first case <code>PA_SetScreenSpace</code> would be called with a zero parameter, whereas on the second case the default value, 48 pixels, could be kept, or extended to 64 pixels.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibspritecollision"></a>
<h7>Sprite collisions</h7>
<p>
One thing is to be able to move sprites around, another one is to detect when they collide. PAlib provides two ways of detecting collisions: circular or rectangular bounding boxes, explained <a href="http://www.palib.info/wiki/doku.php?id=day6#sprite_collisions" target="_blank">here</a>. If neither of them is pixel-perfect, they are most of the time quite sufficient.
</p>

<p>
Circular detection is obtained thanks to <code>PA_Distance</code>, to compare the (square) distance between the centers of the (circle) bounding-boxes to the (square of the) sum of their radius.
</p>

<p>
Rectangular detection is obtained thanks to up to four comparisons, without need of a specific function.
</p>

<p>
Most tile-based games should implement a collision map, a 2D array of boolean values that tells if at a given tile location [p,q] the corresponding tile is walkable for example.
</p>

<p>
For further informations on collision with PAlib, refer to the dedicated section in its <a href="http://www.palib.info/wiki/doku.php?id=day6#sprite_collisions" target="_blank">tutorial</a>.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>



<a name="palibbackground"></a>
<h6>Background management</h6>


<a name="palibbackgroundtypes"></a>
<h7>Three types of backgrounds</h7>
<p>
PAlib makes use mainly of 256-color tiled backgrounds (up to four of them, named bg0..bg3; tiled background #0, i.e bg0, will be drawn on top of #1, etc.), with their traditional tile maps and tilesets. 8-bit or 16-bit framebuffer backgrounds are less used (using respectively 3/8 and 3/4 of a 128-kilobytes VRAM bank, up to one per screen), and rotation backgrounds (either regular or ERB, up to two per screen) are even less used. 
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibbackgroundtiled"></a>
<h7>Tiled backgrounds</h7>

<p>
Tiled backgrounds can be loaded directly thanks to <code>PA_EasyBgLoad</code> or <code>PA_LoadTiledBg</code> (including their palette), if they have been produced by PAGfx (see this <a href="http://www.palib.info/wiki/doku.php?id=day5#converting" target="_blank">section</a> of PAlib tutorial). Otherwise <code>PA_LoadSimpleBg</code> and <code>PA_LoadBgPal</code> should be used, for example with data (maps, palettes, tiles) produced by gfx2gba. With both tools, .h and .c files can be produced and included in the executable, which is one of the ways to embed resources (the simplest, though with limitations).
</p>

<p>
As PAGfx makes an optimized use of tiles, their index may vary, and one should better read them from the map directly, if possible. Once a tile index is known, any map position can be set to the corresponding tile thanks to <code>PA_SetMapTileEx</code>.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibbackgroundtiledscroll"></a>
<h7>Tiled background scrollings</h7>
<p>
Classical scrollings can be achieved thanks to <code>PA_BGScrollXY</code> or <code>PA_EasyBgScrollXY</code>, both of which specifies the position the background should scroll to (both have counterparts to scroll only horizontally or vertically, ex: <code>PA_BGScrollX</code>). Backgrounds are wrapped around, but on 256 pixel boundaries: if your background is, say, 256+X pixel wide, there will be a 256-X blank space until the 512 pixel boundary allows it to wrap.
</p>

<p>
PAlib introduced special tiled backgrounds named <em>LargeMap</em>, which can exceed the 512x512 tile size offered by the hardware. To do so, during the scrolling, PAlib loads dynamically next tiles. Such backgrounds should be loaded with <code>PA_LoadPAGfxLargeBg</code>, and scrolled with <code>PA_LargeScrollXY</code> (not too slow, but does not wrap around) or with <code>PA_InfLargeScrollXY</code> (wraps around, but is quite slow).
</p>

<p>
Parallax scrollings (where different backgrounds scroll at different speeds, the closest the fastest to create a 3D/depth effect) are implemented as well: use for example <code>PA_InitParallaxY</code> to initialize a vertical parallax scrolling and then <code>PA_ParallaxScrollY</code> to perform the actual scrolling. LargeMap backgrounds can be parallax scrolled too.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibbackgroundframebuffer"></a>
<h7>8-bit &amp; 16-bit framebuffer backgrounds</h7>

<p>
They take a lot of memory, their rendering is slow, but: they allow to display pictures in common formats (with PAlib: 16-bit .jpeg, 8/16-bit .gif, 16-bit .bmp, 8/16-bit .raw are supported) without prior conversion, and/or to easily draw shapes with the stylus, and 16-bit framebufferst got rid of the palette (as many colors as pixels, thanks to direct colors).
</p>

<p>
Images for framebuffers must be 256×192 to avoid their being distorted. PAGfx should be used for them. For 8-bit framebuffers, use <code>PA_Init8bitBg</code> to setup the background mode, <code>PA_LoadNormalBgPal</code> to load the palette and <code>PA_Load8bitBitmap</code> to load the bitmap itself. For 16-bit framebuffers, no palette is needed, thus use just <code>PA_Init16bitBg</code> to setup the background mode and <code>PA_Load16bitBitmap</code> to load the bitmap itself. 
</p>

<p>
Images can be included from header files (automatically produced from images found in the <code>data</code> directory) and displayed with, for example, <code>PA_LoadGif</code> and <code>PA_LoadGifXY</code>.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibbackgroundrot"></a>
<h7>Rotation backgrounds</h7>

<p>
After <code>PA_SetVideoMode</code> is used to set an appropriate video mode (up to two rotating backgrounds can be used at once, they can be wrap-around or not), these backgrounds (and their palettes) must be loaded with <code>PA_LoadPAGfxRotBg</code> (if produced by PAGfx), before being rotated (around any given point) and/or scaled and/or moved with <code>PA_SetBgRot</code>.<code></code><code></code>
</p>

<p>
For further informations on backgrounds with PAlib, refer to the dedicated section in its <a href="http://www.palib.info/wiki/doku.php?id=day5" target="_blank">tutorial</a> and to the following sections  of the API: <a href="http://www.palib.info/Doc/PAlibDoc Eng/group___bg_tiles.html" target="_blank">Normal Tiled Background Modes</a>, <a href="http://www.palib.info/Doc/PAlibDoc Eng/group___bg_rot.html" target="_blank">Rotating Backgrounds</a> and <a href="http://www.palib.info/Doc/PAlibDoc Eng/group___tile_dual.html" target="_blank">Background Modes on two Screens</a>.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>



<a name="palib3D"></a>
<h6>3D</h6>

<p>
Even if there is a pseudo-3D video mode (the <a href="http://www.palib.info/Doc/PAlibDoc Eng/group___mode7.html" target="_blank">Mode 7</a>, that can be used for example to implement interesting special effects), there is a real 3D subsystem on the DS, that can be used with PAlib.
</p>

<p>
No need any more to define <code>USE_3D</code> in PA_Config.h. One just has to use <code>PA_Init3D</code> to initialize the 3D subsystem on the bottom screen (use <code>PA_SwitchScreens</code> to target the top screen). Then <code>PA_Init3DDrawing</code> should be used to define where the camera is and in which direction it is looking at.
</p>

<p>
To see something, at least one object is to be created in an adequate location. First the current transform matrix should be saved thanks to <code>glPushMatrix</code>, then the object should be defined (ex: with <code>PA_3DBox</code>), then the saved trasnform matrix should be restored (<code>glPopMatrix</code>) before requesting the rendering to take place (<code>glFlush</code>).
</p>

<p>
PAlib's current 3D layer uses floating-point coordinates, which is somewhat a performance-killer. <a href="www.khronos.org/opengles/" target="_blank">OpenGL ES</a> version for platforms with no hardware floating-point support (FPU-less, hence using fixed-point) could be use instead. Some tricks couls allow to have 3D on both screens "simultaneously", but it would be rather limited.
</p>

<p>
More information can be found in the <a href="http://www.palib.info/wiki/doku.php?id=day10" target="_blank">3D section</a> of the PAlib tutorial and in the <a href="http://www.palib.info/Doc/PAlibDoc Eng/group___d.html" target="_blank">related section</a> in the API documentation.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibmovie"></a>
<h6>Movie playback</h6>

<p>
First the original movie has to be converted from the .avi to various .vid files and a header. Then a template should be used to include the movie in a GBFS filesystem before playing it with <code>PA_LoadMultiVidGBFS</code>, after having initialized GBFS (<code> PA_InitGBFS</code>) and the adequate video mode (either <code>PA_Init16bitBg(1, 3)</code> or <code>PA_Init16bitBg(0, 3)</code>).
</p>

<p>
More information about movie playback can be found in the <a href="http://www.palib.info/wiki/doku.php?id=day11" target="_blank">Video section</a> of the PAlib tutorial.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibsound"></a>
<h6>Sound</h6>
<p>
There are two kinds of PAlib sound output: raw output and MOD playback, which are rather complementary. Both need the sound system to be initialized, thanks to a call to <code>PA_InitSound</code>. There are 16 hardware channels that can playback simultaneously, by default 8 of which are reserved by PAlib for raw output, the remaining 8 being used by the MOD player.
</p>

<p>
Raw output is like reading a .wav file: easy and perfect for special effects, but not adequate for musics due to the very significant size of these longer sounds. When having a sound to be output on the DS, it must be converted first. An appropriate target format could be mono 8-bit signed samples at 11025 Hz (but stereo sound and higher sample rate are supported). To play that sound on the DS, once the sound subsystem is initialized, use simply <code>PA_PlaySimpleSound</code>. One of the 8 (0..7) hardware channels reserved by PAlib should be then specified.
</p>

<p>
On the contrary, MOD is perfect for music playback, since musics are encoded in very small sizes. Once the sound system is initialized, one just has to use <code>PA_PlayMod</code> to play a MOD file, that should not have more than 8 channels.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibfs"></a>
<h6>Filesystem</h6>
<p>
PAlib includes a filesystem named PAFS (<em>PAlib File System</em>), although the older <a href="http://www.pineight.com/gba/#gbfs" target="_blank">GBFS</a> filesystem could be used too (PAlib provides a <a href="http://www.palib.info/Doc/PAlibDoc Eng/group___g_b_f_s.html" target="_blank">GBFS</a> wrapper for backward compatibility). PAFS allows to read files from the ROM, or directly from the RAM (embedded filesystem in the executable), which allows to use it with WMB and emulators as well. Running from RAM implies a maximum total size for the executable of 4 megabytes, and to specify the RAM size you want to reserve for the user filesystem.
</p>

<p>
<a href="#libfat" target="_blank">libfat</a> is quite an interesting alternative to the less commonly used PAFS. PAlib offers a few helper functions to be with with libfat (see <code>arm9/PA_IO.h</code> and <code>arm9/PA/PA_IO.c</code>).
</p>

<p>
First the PAFS image must be created with PAFS.exe, by appending files to the archive. Then various primitives allow to initialize the filesystem module on the DS (either from slot-2 thanks to <code>PA_FSInit</code> or from RAM thanks to <code>PA_FSRamInit</code>) and to read/write files and directories. For ROM, see the <code>PA_PAFSFile</code> and <code>PA_FSSys</code> array structures. For RAM, see <code>PA_FSRam</code> (to define the allocated size in RAM for the filesystem) and <code>PAFSStart</code> to read the RAM instead of the ROM.
</p>

<p>
More information can be found in the <a href="http://www.palib.info/wiki/doku.php?id=day9" target="_blank">PAFS section</a> of the PAlib tutorial.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibwifi"></a>
<h6>Wifi communications</h6>
<p>
<a href="http://www.palib.info/hosted/delfare/PAlibwifi.zip" target="_blank">PAlibwifi</a> is used for this. The corresponding header file (<code></code>) and library (<code>libdswifi9r.a</code>, i.e. <code>LIBSPA:= -lpa9 -ldswifi9r</code>) should be specified.
</p>

<p>
Initialization of the library should be done thanks to <code>PA_InitWifi</code>, and connection with <code>PA_ConnectWifiWFC</code>, before a socket connected to a remote host can be created with <code>PA_InitSocket</code>. Then data can be sent and received, thanks to <code>send</code> and <code>recv</code>. <code>PA_GetHTTP</code> allows to retrieve a file thanks to the HTTP protocol. The IP address of the DS, as seen by the outside (Internet), can use <code>PA_GetHTTP</code> to call a server returning the IP of the client.
</p>

<p>
More information can be found in the <a href="http://www.palib.info/wiki/doku.php?id=day20" target="_blank">Data Transfer and Multiplayer</a> section of the PAlib tutorial.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>




<a name="palibbuilding"></a>
<h5>Building with PAlib</h5>

<p>
At compile time, PAlib overall headers must be included: <code>#include &lt;PA9.h&gt;</code> for the ARM9, with the <code>-IPath/To/PAlib/include/nds</code> command-line switch. A PAlib general header will in turn include all the specialized headers, like <code>PA_Interrupt.h</code>.
</p>

<p>
At link time, the PAlib (static) library <code></code> must be specified. As it depends on libdns, following switches should be used: <code>-LPath/To/PAlib/lib -lpa9 -LPath/To/Libnds/lib -lnds</code> for the ARM9.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>



<a name="palibinstall"></a>
<h5>Installing PAlib</h5>
<p>
To install PAlib, follow <a href="http://www.palib.info/wiki/doku.php" target="_blank">PAlib's tutorial</a> or use LOANI.
</p>

<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<a name="palibalternate"></a>
<h5>Alternate choices to PAlib</h5>

<p>
There are still many other libraries, but they are less used. <a href="http://libsdl.org/" target="_blank">SDL</a> has been <a href="http://gpf.dcemu.co.uk/ndsSDL.shtml" target="_blank">ported to the DS</a>. This abstraction layer is very useful to port (often PC) applications to lesser known platforms such as the homebrew-enabled DS, but in our case a few issues remains: the DS SDL implementation is not complete, it uses a lot of memory with regard to what is available, and a lot of hardware acceleration would be bypassed because of the layer. SDL may be here a way of starting a port, even though finally the game ought not to rely on it, for performance reasons.
</p>


<br><p><center>[<a href="#palibtoc">Back to the PAlib table of contents</a>]</center></p><br><br>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>








<a name="building"></a>
<h3>Building your first DS program</h3>

<p>
Now has come the time for a first test, here directly with PAlib. LOANI users should first source the <code>LOANI-installations/OSDL-environment.sh</code> file to update their environment: <center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
. OSDL-environment.sh
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>
 
 
<p>
Then let's build some tests: go for example in <code>devkitPro/PAlibExamples/Input/Keyboard/Keyboard</code> and just execute <code>make</code>. It will read the <code>Makefile</code> and generate, from the sources (in <code>source/main.c</code>), the corresponding ROM: <code>Keyboard.ds.gba</code>, <code>Keyboard.nds</code> and
<code>Keyboard.sc.nds</code> (all occupying around 95 ko). Refer to our section about <a href="#romformats">ROM formats</a> for a reminder of their respective role.
</p>

<p>
Something similar to this should occur:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
&gt; make<br>
main.c<br>
arm-eabi-g++ -g -mThumb-interwork -mno-fpu -LYourLOANIDir/LOANI-0.5/LOANI-installations/devkitPro/PAlib/lib -specs=ds_arm9.specs main.o -LYourLOANIDir/LOANI-0.5/LOANI-installations/devkitPro/PAlib/lib -lpa9 -LYourLOANIDir/LOANI-0.5/LOANI-installations/devkitPro/libnds/lib -lfat -lnds9 -ldswifi9 -o build.elf<br>
Nintendo DS rom tool 1.33 - Jan 27 2007 16:00:04<br>
by Rafael Vuijk, Dave Murphy,  Alexei Karpenko<br>
built ... Keyboard.ds.gba<br>
dsbuild 1.21 - Jan 28 2007<br>
using default loader<br>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
To decrypt a bit, the Makefile will try to rebuild target <code>$(OUTPUT).ds.gba</code>, whose name is deduced from the current directory (here, Keyboard). To build <code>Keyboard.ds.gba</code>, <code>Keyboard.nds</code> is needed, which in turns implies <code>Keyboard.bin</code> exists, then <code>Keyboard.elf</code>, then <code>$(OFILES)</code>. This variable contains all the object files needed, deduced from the source code (<code>*.c, *.cpp</code>) but also from the resources to be embedded (ex: <code>*.jpg, *.bmp</code>, etc.).
</p>

<p>
Thus the first thing is to obtain these object files. The C++ compiler for ARM (<code>arm-eabi-g++</code>) is called to generate an object file for the ARM9, main.o, from main.c. Have a look at this file, this is the main one you are expected to write on the future. 
</p>

<p>
Once all the object files are created, they can be aggregated by the linker (here, <code>arm-eabi-g++</code> again) in <code>Keyboard.elf</code> (ELF for <code>External Link Format</code>).
</p>

<p>
More precisely main.o, that provides the <code>main()</code> function, will be linked (statically; no dynamic linking available on the DS) with PAlib (<code>-lpa9</code> refers to <code>libpa9.a</code>, 9 for the ARM9), which itself uses some helper libraries: libfat, libnds9, dswfi9, even if this simple example does not use them all. Linking with unused libraries will not make your ROM bigger: they will not be included if really not referred to.
</p>

<p>
<code>Keyboard.elf</code> can then be converted in <code>Keyboard.bin</code> by <code>arm-eabi-objcopy</code>, whose role is to copy and translate object files from a given binary format to another, here stripping extra informations not needed and not handled by the toolchain.
</p>

<p>
From <code>Keyboard.bin</code>, <code>Keyboard.nds</code> (at last, a ROM file !) will be generated thanks to <code>devkitARM/bin/ndstool</code>, whose role is to combine the two ARM executables and the data resources into a single file ready for DS distribution. Note that <code>Keyboard.bin</code> contains everything but the executable for the ARM7. This one is retrieved here from a precompiled default version, a kind of template, located in <code>arm7.bin</code>.
</p>

<p>
Finally the <code>devkitARM/bin/dsbuild</code> executable is used to generate <code>Keyboard.ds.gba</code> from <code>Keyboard.nds</code>. This involves adding a slot-2 loader. 
</p>

<p>
See also our more <a href="#buildindepth">in-depth build example</a>.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="testing"></a>
<h3>Testing your first DS program</h3>

<p>
You have two options here: either the ROM must come one way or another to the DS (transfer), or the DS must come to the ROM and the PC (emulation). 
</p>


<h4>Transferring</h4>
<p>
The most obvious method is to transfer your ROM, here <code>Keyboard.sc.nds</code> (renamed for the Supercard, from <code>Keyboard.ds.gba</code>), to your DS: copy it to, say, your microSD card, insert that card in your DS and run the ROM, for example thanks to the SuperCard menu. That should work.
</p>

<p>
This method has however two drawbacks. The minor one is that on some computers, notably laptops like mine, Linux support for SD card is still quite limited, and often you end up with mounting, reading or writing problems. The major drawback is, even if the SD are well recognized, it becomes soon tiedous to swap the card again and again between its adapter on PC and the DS. For most people, the developing process requires too frequent tests to do so.     
</p>

<p>
Using a Wifi transfer, preferably thanks to a router, could do the trick, and be more convenient than the card swap. One could use DSLinux for a SSH or FTP transfer followed by a reboot. This is not necessarily the best solution ever though. As for cable (parallel, USB, etc.), as already discussed, they either require soldering efforts, or are quite expensive and require still some user action (to plug/unplug the cable seems to be required). 
</p>


<a name="emulators"></a>
<h4>Emulating</h4>

<p>
The second method for testing your programs is to use an <a href="http://en.wikipedia.org/wiki/Emulator" target="_blank">emulator</a>. This will allow a PC to mimic your DS, so that you can test in-place the (approximated) result of your ROM.
</p>

<p>
Though the imitation is not always perfect (sadly, programs may work when emulated, but not on the actual DS device; the other way round is possible of course), emulators have progressed a lot. For the Linux user, in decreasing order of interest, one should use:
<ol>
<!--
    <li><a href="" target="_blank"></a></li>
-->

	<li>

<p>
<a href="http://nocash.emubase.de/gba.htm" target="_blank">NO$GBA</a>, probably the best emulator around, with a very complete and accurate 2D support, a fast improving 3D support, able to run many commercial games. On Linux it should be used with Wine (<code>apt-get install wine</code> for Debian-based distributions). Just use LOANI, or <a href="http://nocash.emubase.de/no$gba-w.zip" target="_blank">download</a> it, unzip it, run <code>wine NO\$GBA.EXE</code> and select your .ds.gba file (ex: <code>Keyboard.ds.gba</code>)
</p>

<p>
	<center>
    	<img src="NoCashGBA-screenshot.png" alt="NO$GBA"></img>
	</center>
</p>

<p>
	The colors might seem different from the expected ones due to a kind of DS screen emulation filter. This can be deactivated in <code>Options -&gt; Emulation Setup -&gt; GBA Mode</code> (or press F11) by selecting <code>VGA (poppy bright).
</p>

<p>
	NO$GBA can provide a <a href="http://nocash.emubase.de/gba-dev.htm" target="_blank">source level debugger</a> as well, for professionals (this advanced tool is not free of charge). </code>
</p>
	</li>


	<li>
	<p>
	<a href="http://www.desmume.org/" target="_blank">DeSmuME</a>: probably the fastest of all emulators. Does not support zooming and rotation. There is a <a href="http://desmume.org/?p=19" target="_blank">Linux</a> version and even Debian packages, based on a SDL port. Some people prefer to run the Windows version from Wine. It is one of the few emulators to allow for the reconfiguration of key mappings
	</p>

	<p>
	To do so, use LOANI or <a href="http://www.desmume.com/download.htm" target="_blank">download</a> DeSmuME latest stable version, unzip it, and simply run <code>wine NDeSmuME.exe</code>. In the <code>File</code> menu, you can select <code>Open and Execute</code>, and choose, this time, your .nds file (ex: <code>Keyboard.nds</code>). You should then be able to test it immediately:
	<center>
    	<img src="DeSmuME-screenshot.png" alt="DeSmuME"></img>
	</center>
	</p>
	</li>
	
	 
    <li><a href="http://dualis.1emu.net/" target="_blank">Dualis</a> (not tested). Known to be less accurate but faster than NO$GBA, now unable to manage libfat unless FCSR (which stands for <em>flashcartsram</em>) drivers are used. Maybe a bit too permissive compared to the DS</li>
	
    <li><a href="http://spazioinwind.libero.it/linoma/ideas.html" target="_blank">Ideas</a> (not tested). One of the first and only to support 3D and sounds, still true at the time of this writing</li>
	
    <li><a href="http://www.ndsemulator.com/nintendo-ds/ensata.htm" target="_blank">Ensata</a> (not tested; illegal material leaked from Nintendo SDK, according to some sources)</li>

    <li>DSEmu, despite its plugin feature, is probably deprecated now (not tested)</li>
	
</ol>
</p>

<p>
See also the <a href="http://www.ndsemulator.com/" target="_blank">NDSEmulator.com</a> site.
</p>

<p>
Debugging thanks to any emulator a ROM using a <a href="#libfat">libfat</a>-based filesystem (either directly or through <a href="#libefs">libefs</a>) is possible by creating a FAT12 image file from your content directory, appending that image to your padded ds.gba ROM, and finally applying the fcsr DLDI-patch on it. See this <a href="" target="_blank">thread</a> for more information.
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="andnow"></a>
<h3>And now ?</h3>

<p>
Thanks to this guide and the listed <a href="#tutorials">tutorials</a>, you should be more than ready to write your own DS application. Often starting simple and building up works well. Thanks to <a href="#forums">forums</a> and <a href="#irc">IRC</a> channels, you should have kind support if needed.

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
As a final word, have fun programmin' the DS !
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>


</p>



<a name="otherinfos"></a>
<h2>Some other information sources</h2>



<!-- ########################################################################-->
<a name="tutorials"></a> 
<h3>Tutorials</h3>
<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://www.double.co.nz/nintendo_ds/" target="_blank">Double</a>: interesting, well explained but in some cases deprecated</li>
	
    <li><a href="http://www.dev-scene.com/NDS/Tutorials" target="_blank">Dovoto</a>'s tutorial: a really good one</li>
	
    <li><a href="http://www.playeradvance.org/forum/showthread.php?t=4277" target="_blank">PAlib for Linux</a> (1/2)</li>
	
    <li><a href="http://www.palib.info/wiki/doku.php" target="_blank">PAlib for Linux</a> (2/2)</li>
	
    <li><a href="http://www.coranac.com/tonc/text/" target="_blank">TONC</a>: lots of GBA informations, most of which still applies to the DS</li>
	
    <li><a href="http://www.patatersoft.info/manual_online.html" target="_blank">Patatersoft</a></li>
	
    <li><a href="http://www.drunkencoders.com/index.php?system_id=1&page=Tutorials" target="_blank">drunkencoders</a> tutorials</li>

    <li><a href="http://scorpei.com/TBGTDSHB/The_Beginners_Guide_To_NDS_Homebrew.pdf" target="_blank">Running Nintendo DS homebrew</a> [PDF], by Simon van de Berg. Helps to understand and choose linkers</li>

    <li>DS <a href="http://delfare.pizz.biz/tutoEN.htm" target="_blank">3D tutorial</a></li>

   <li>Writing a <a href="http://www.webbesen.dk/gba/" target="_blank">PONG clone</a> on the GBA</li>

    <li><a href="http://www.playeradvance.org/forum/showthread.php?t=6103" target="_blank">Programmer sur DS avec la libnds</a>, by Pitt (in French)</li>

</ul>

</p>


<!-- ########################################################################-->
<a name="forums"></a> 
<h3>Forums</h3>
<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://forum.gbadev.org/viewforum.php?f=18" target="_blank">gbadev forums</a></li>

    <li><a href="http://forums.abxy.org/f/nintendo-ds" target="_blank">abxy DS forums</a></li>
	
</ul>

</p>


<!-- ########################################################################-->
<a name="irc"></a> 
<h3>IRC channels</h3>
<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="irc://irc.blitzed.org" target="_blank">Dev-Scene IRC</a> (channel: #dsdev)</li>

    <li><a href="irc://irc.freenode.net" target="_blank">DSLinux IRC</a> (channel: #DSLinux)</li>
	
</ul>

</p>


<!-- ########################################################################-->
<a name="applications"></a>
<h3>Homebrew applications &amp; games</h3>

<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://scummvm.drunkencoders.com/" target="_blank">ScummVM DS</a></li>
	 
    <li><a href="http://www.mrdictionary.net/lemmings/" target="_blank">Lemmings DS</a></li>

    <li><a href="http://mdxonline.dyndns.org/archives/nds/" target="_blank">Moonshell</a></li>

    <li><a href="http://www.dragonminded.com/?loc=ndsdev/DSOrganize" target="_blank">DSOrganize</a>, transform your DS into a PDA</li>

<!-- Apparently a piracy-related site ?
    <li><a href="http://www.nintendo-ds-roms.com/" target="_blank">DS ROMs</a></li>
-->
	
</ul>

</p>


<!-- ########################################################################-->
<a name="otherlinks"></a>
<h3>Some interesting links</h3>
<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->
    <li><a href="http://en.wikipedia.org/wiki/Nintendo_DS_homebrew" target="_blank">Nintendo DS</a> on Wikipedia</li>
	
    <li><a href="http://en.wikipedia.org/wiki/Nintendo_DS_booting_tools" target="_blank">DS booting tools</a> on Wikipedia</li>
	
    <li><a href="http://forum.gbadev.org/viewtopic.php?t=8353" target="_blank">Link repository from gbadev</a></li>

    <li><a href="http://www.ndshb.com/modules.php?name=Content&pa=showpage&pid=27" target="_blank">Extension for DS ROMs explained</a> (twice)</li>
	
    <li><a href="http://www.dev-scene.com" target="_blank">Dev-Scene</a></li>
	
    <li><a href="http://www.aaronrogers.com/nintendods/" target="_blank">Aaron Rogers</a></li>
	
    <li><a href="http://www.drunkencoders.com" target="_blank">Drunk Encoders</a></li>
	
    <li><a href="http://nintendo-ds.dcemu.co.uk/" target="_blank">DS News</a></li>

	<li><a href="http://www.nintendods.com/" target="_blank">Nintendo official website</a></li>


    <li><a href="http://www.warioworld.com/" target="_blank">WarioWorld</a>, software development support group (for professionals, authorized Nintendo developers and licensees). Nintendo only accepts official companies with a game development team, and sufficient experience in certain areas for their official developer support program. Small structures are expected to find a "Nintendo-certified" publisher prior to submit their games</li>

    <li><a href="http://tobw.net/dswiki" target="_blank">DS Developing Wiki</a></li>
 
    <li><a href="http://www.coranac.com/tonc/text/refs.htm" target="_blank">TONC references</a></li>
   
    <li>Resources in French:
	<ul>

<!--
    	<li><a href="" target="_blank"></a></li>
-->

    	<li><a href="http://www.gamebe.com/articles/lire/4/nintendo-ds-r-evolution/" target="_blank">Présentation de la DS</a></li>

    	<li><a href="http://www.portabledev.com/pages/ds/tutoriels/tutos.-chris-double" target="_blank">Traduction des tutoriels de Chris Double</a> </li>
	
    	<li>Les <a href="http://mobiles.gx-mod.com/modules/tutos/index.php?id=37" target="_blank">linkers pour DS</a></li>
		
    	<li><a href="http://www.playeradvance.org/forum/showthread.php?t=4277" target="_blank">Installation de PALib sous Linux</a></li>
	
    	<li>Présentation de <a href="http://playeradvance.org/forum/showthread.php?t=5340" target="_blank">Moonshell</a>, <a href="http://www.supercard-france.info/index.php?option=com_content&task=view&id=19&Itemid=78" target="_blank">installation</a> (sous Windows)</li>

    	<li>Informations sur la <a href="http://www.supercard-france.info/" target="_blank">SuperCard</a>, notamment pour <a href="http://www.supercard-france.info/index.php?option=com_content&task=view&id=29&Itemid=141" target="_blank">la mettre à jour</a></li>
	</ul>
	</li>

		
</ul>

 </p>

<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>




<a name="appendices"></a>
<h3>Appendices</h3>

<p>
<a name="appendixtoc"></a>
<center>
        <table summary="Table of contents" style="border: none">
        <tr>
          <td>
<!--
                       <a href="#"></a><br>
-->

                   <div class="box">
                       <a href="#buildindepth">Appendix 1</a>: in-depth example of the usual cross-compilation build process<br>
                       <a href="#sketches">Appendix 2</a>: DS sketches
          	   </div>
          </td>
        </tr>
      </table>

[<a href="#toc">Back to the main table of contents</a>]
</center>
</p>
<br><br>

<!--
<br><p><center>[<a href="#appendixtoc">Back to the appendix table of contents</a>]</center></p><br><br>
-->


<a name="buildindepth"></a>
<h4>Appendix 1: in-depth example of the usual cross-compilation build process</h3>

<p>
This explanation is based first on a PAlib example (an executable using PAlib is built), then on examples taken from libdns (the build of the library itself, and the one of a program using it).
</p>

<p>
The Make versions have been modified to remove the '@' characters at the beginning of actual make target commands, so that their output can be seen on a terminal.
</p>

<p>
Some output have been shorten (indicated by <code>[..]</code>), and LOCAL and PREFIX shell variables have been substituted for better readability.
</p>


<h5>PAlib example build</h5>
<p>
The PAlib example discussed here is taken from <code>PAlibExamples/Sprites/Movement/MoveSpritewithStylus</code>. The vast majority of PAlib Makefiles are exactly the same. 
</p>



<p>The Makefile is taken into account from the build subdirectory:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
&gt; make

[ -d build ] || mkdir -p build

make --no-print-directory -C build -f ${LOCAL}/Makefile
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<p>
First the dependancies of main.o are determined with devkitARM gcc (<code>-MM</code> option), and requested to be stored them in the <code>build/main.d</code> file thanks to the following command-line:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
arm-eabi-gcc -MM -g -Wformat=2 -Winline -Wall -O2 -I${LOCAL}/include -I${LOCAL}/build -I${LOCAL}/data -I${PREFIX}/libnds/include -I${PREFIX}/libnds/include/nds -I${PREFIX}/PAlib/include/nds -I${LOCAL}/build -DARM9 -I${PREFIX}/PAlib/include/nds -o main.d ${LOCAL}/source/main.c

            </div>
          </td>
        </tr>
    </table>
</center>
This is nothing DS-specific here. See GCC <a href="http://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html#Option-Summary" target="_blank">Option Summary</a> to look-up switches: 
<ul>
<!--
        <li> <code></code>: </li>
-->
        <li> <code>-g</code>: adds debugging information</li>
        <li> <code>-Wformat=2</code>: checks calls to printf and scanf, strftime, etc.</li>
        <li> <code>-Winline</code>: warns if a function can not be inlined whereas it was declared as inline</li>
        <li> <code>-Wall</code>: enables most general warnings</li>
        <li> <code>-O2</code>: attempts to improve the performance and/or code size</li>
</ul>

</p>

<p>
The result in <code>build/main.d</code> is:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
 main.o:  \
  ${LOCAL}/source/main.c \
  ${PREFIX}/PAlib/include/nds/PA9.h \
  ${PREFIX}/libnds/include/nds.h \
 [..] (many PAlib and libnds includes skipped) 
  ${LOCAL}/source/gfx/all_gfx.c \
  ${LOCAL}/source/gfx/vaisseau.c \
  ${LOCAL}/source/gfx/sprite0.pal.c \
  ${LOCAL}/source/gfx/all_gfx.h
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
It states basically that as soon as at least one of the files listed after the <code>main.o:</code> target is modified, this <code>main.o</code> should be rebuilt.
</p>

<p>
Once these dependencies have been computed in <code>main.d</code>, <code>main.o</code> is to be compiled. This gcc, adapted for DS cross-compilation, transforms main.c into main.o, an ELF 32-bit LSB relocatable object file, ARM, version 1 (SYSV), not stripped. Same command-line than previous one, except there is no -MM switch and the main.o target is specified:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
arm-eabi-gcc -g -Wformat=2 -Winline -Wall -O2 -I${LOCAL}/include -I${LOCAL}/build -I${LOCAL}/data -I${PREFIX}/libnds/include -I${PREFIX}/libnds/include/nds -I${PREFIX}/PAlib/include/nds -I${LOCAL}/build -DARM9 -I${PREFIX}/PAlib/include/nds -c ${LOCAL}/source/main.c -o main.o
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>Then <code>main.o</code> is linked to the libraries it refers to, which results in the generation of  <code>build.elf</code>, an ELF 32-bit LSB executable, ARM, version 1 (SYSV), statically linked, not stripped:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
arm-eabi-g++ -g -mthumb-interwork -mno-fpu -L${PREFIX}/PAlib/lib -specs=ds_arm9.specs main.o -L${PREFIX}/PAlib/lib -lpa9 -L${PREFIX}/libnds/lib -lfat -lnds9 -ldswifi9 -o build.elf
            </div>
          </td>
        </tr>
    </table>
</center>
Here <code>-mthumb-interwork</code> requires that a given program can use both the ARM and Thumb instruction sets. See GCC <a href="http://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html#ARM-Options" target="_blank">ARM options</a> for more details. <code>-mno-fpu</code> should mean that no floating-point unit is available, although this does not seem to be the proper switch to be used here. <code>-specs</code> specifies the DS link script that shall be used (to take into account the DS memory layout and al), and the various libraries are listed in order, from the most specific to the least (<code>PAlib, libfat, libnds, dswifi</code>). All these settings are to be used only for the ARM9.
</p>

<p>The result is an executable in the ELF format, which has to be transformed into a format directly suitable for the DS thanks to <code>arm-eabi-objcopy</code>:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
arm-eabi-objcopy -O binary build.elf build.bin
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
Finally the target .nds file can be obtained from the ARM9 executable just built (build.bin) and from the template ARM7 executable (prebuilt <code>arm7.bin</code>) with some additional metadata (logo, sentences, etc.):
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
ndstool -c ${LOCAL}/MoveSpritewithStylus.nds -9 build.bin -7 ${PREFIX}/PAlib/lib/arm7/arm7.bin -o ${LOCAL}/build/../logo_wifi.bmp -b ${LOCAL}/build/../logo.bmp "PAlib Project;using PAlib;www.palib.info"
            </div>
          </td>
        </tr>
    </table>
</center>

The output tells us it succeeded:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
Nintendo DS rom tool 1.33 - Jan 27 2007 16:00:04
by Rafael Vuijk, Dave Murphy,  Alexei Karpenko
built ... MoveSpritewithStylus.ds.gba
dsbuild ${LOCAL}/MoveSpritewithStylus.nds
dsbuild 1.21 - Jan 28 2007
using default loader
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

Last step is to create an exact copy of the .ds.gba into a .sc.nds file, as a work-around to SuperCard faulty format identification:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
cp ${LOCAL}/build/../MoveSpritewithStylus.ds.gba ../MoveSpritewithStylus.sc.nds
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<br><p><center>[<a href="#appendixtoc">Back to the appendix table of contents</a>]</center></p><br><br>



<h5>Libnds build</h5>

<p>
When creating the actual library, code for both ARM is to be compiled.
</p>

<h6>ARM7</h6>
<p>
Here is an example of compilation:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
arm-eabi-gcc -MMD -MP -MF ${PREFIX}/libnds-sources/deps/arm7/clock.d -g -Wall -O2 -fomit-frame-pointer -ffast-math -I${PREFIX}/libnds-sources/include -mthumb -mthumb-interwork -mcpu=arm7tdmi -mtune=arm7tdmi -DARM7 -I${DEVKITPRO}/libnds-sources/build/arm7 -c ${DEVKITPRO}/libnds-sources/source/arm7/clock.c -o clock.o
            </div>
          </td>
        </tr>
    </table>
</center>

<p>
here is a link example for library creation:

<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
arm-eabi-ar -rc ${DEVKITPRO}/libnds-sources/lib/libnds7.a audio.o clock.o microphone.o spi.o touch.o card.o gbfs.o interrupts.o biosCalls.o interruptDispatcher.o
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
and here an example where an executable is (statically) linked against a library:

<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
arm-eabi-gcc -specs=ds_arm7.specs -g -mthumb -mthumb-interwork -Wl,-Map,basic.map defaultARM7.o  -L${DEVKITPRO}/libnds-sources/lib -lnds7 -o ${DEVKITPRO}/libnds-sources/basic.elf
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
The map-related settings tell which object files of the static libraries must be embedded in the executable, due to which symbols being used by this executable. These .map files are generated by the linker, thanks to a <code>-Map myMap.map</code> option. Here this option has to be passed by the compiler to the linker, so the <code>-Wl,</code> switch is added. 
</p>




<h6>ARM9</h6>
<p>
For the ARM9, here is an example of compilation:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
arm-eabi-gcc -MMD -MP -MF ${DEVKITPRO}/libnds-sources/deps/arm9/boxtest.d -g -Wall -O2 -fomit-frame-pointer -ffast-math -I${DEVKITPRO}/libnds-sources/include -mthumb -mthumb-interwork -march=armv5te -mtune=arm946e-s -DARM9 -I${DEVKITPRO}/libnds-sources/build/arm9 -c ${DEVKITPRO}/libnds-sources/source/arm9/boxtest.c -o boxtest.o
console.c
            </div>
          </td>
        </tr>
    </table>
</center>

<p>
here is a link example for library creation:

<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
arm-eabi-ar -rc ${DEVKITPRO}/libnds-sources/lib/libnds9.a COS.o default_font.o SIN.o TAN.o boxtest.o console.o exceptions.o gurumeditation.o image.o keys.o ndsmotion.o pcx.o rumble.o sound.o system.o touch.o video.o videoGL.o card.o gbfs.o interrupts.o dcache.o exceptionHandler.o icache.o biosCalls.o interruptDispatcher.o
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
and here an example where an executable is (statically) linked against a library:

<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
arm-eabi-gcc  -specs=ds_arm9.specs -g -mthumb -mthumb-interwork -Wl,-Map,TouchTest.map balldata.bin.o ballpalette.bin.o  main.o  -L${DEVKITPRO}/libnds/lib -lnds9 -o ${DEVKITPRO}/libnds-examples/input/TouchTest/TouchTest.elf
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<br><p><center>[<a href="#appendixtoc">Back to the appendix table of contents</a>]</center></p><br><br>



<h5>Synthesis</h5>
<p>
For compilation, following switches are recommended: 
<ul>
        <li><b>ARM7</b>: 
	   <ul>
		<li>in debug mode: <code>-g -Winline -Wall -O0 -mthumb -mthumb-interwork -mcpu=arm7tdmi -mtune=arm7tdmi -DARM7 -DDEBUG</code></li>
		<li>in release mode: <code> -Winline -Wall -O3 -fomit-frame-pointer -ffast-math -mthumb -mthumb-interwork -mcpu=arm7tdmi -mtune=arm7tdmi -DARM7</code></li>
	   </ul>
	</li>

        <li><b>ARM9</b>: 
	   <ul>
		<li>in debug mode: <code>-g -Winline -Wall -O0 -mthumb -mthumb-interwork -march=armv5te -mtune=arm946e-s -DARM9 -DDEBUG</code></li>
		<li>in release mode: <code> -Winline -Wall -O3 -fomit-frame-pointer -ffast-math -mthumb -mthumb-interwork -march=armv5te -mtune=arm946e-s -DARM9</code></li>
	   </ul>Sometimes alternate flags, <code>-mcpu=arm9tdmi -mtune=arm9tdmi</code> are used, but they should be not favoured, as less accurate.
	</li>
</ul>

C++ code not using RTTI nor exceptions may add: <code>-fno-rtti -fno-exceptions</code>.
</p>

<p>
To create a library X from a set of object files (generated as explained previously), use <code>arm-eabi-ar -rc libXp.a a.o b.o c.o [...]</code>, with p being 7 or 9 for the ARM7 or the ARM9 (recommended convention).
</p>

<p>
To link an executable against a library X (generated as explained previously), use:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
arm-eabi-gcc -specs=ds_arm9.specs -g -mthumb -mthumb-interwork -Wl,-Map,MyExecMap.map a.o b.o [..] -L${DEVKITPRO}/libnds/lib -lnds9 -o MyExec.elf
            </div>
          </td>
        </tr>
    </table>
</center>

with being 9 being replaced by 7 depending on the ARM.
</p>

<br><p><center>[<a href="#appendixtoc">Back to the appendix table of contents</a>]</center></p><br><br>



<a name="sketches"></a>
<h4>Appendix 2: DS sketches</h3>

<p>
When designing a GUI, for example for a game, one often draws quickly some sketches to figure out various organizations, with pen and paper. To help that process, we designed a quick and dirty DS-Lite representation suitable for printing (two DS per sheet): 

<center>
    <a href="Nintendo-DS.png" target="_blank"><img src="Nintendo-DS.png" alt="Nintendo DS sketch" height="300" border=2></img><br>
(click to enlarge)</a>
</center>
Source file is <a href="Nintendo-DS.svg" target="_blank">Nintendo-DS.svg</a>.
</p>

<br><p><center>[<a href="#appendixtoc">Back to the appendix table of contents</a>]</center></p><br>

<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


  <br>
  <br>
  <br>
  <br>

 <h3>Please react !</h3>

  <p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, <a href="mailto:homebrew@esperide.com?subject=[OSDL]%20Homebrew%20for%20Nintendo%20DS">drop us a line</a>!</p><br>
  <br>
  <hr>
  <br>
 
  <center>
    [<a href="#_top_">Top</a>]
	<br>
    <br>
    <em>Last update: Friday, August 3, 2007</em>
  </center>
</body>
</html>
