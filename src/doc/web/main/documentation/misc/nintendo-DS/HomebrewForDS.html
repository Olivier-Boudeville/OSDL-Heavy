<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">

<!--    Ce document fait partie du projet OSDL.
		Pour toute remarque, envoyer un courriel à toshiba.laptop@esperide.com
-->
<!--    
        Date de création : Saturday, June 2, 2007.
        Auteur : Olivier Boudeville (toshiba.laptop@esperide.com)
        Version : 0.1
-->

<html lang="EN">
<head>
  <title>OSDL - A guide to homebrew development for the Nintendo DS</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="description" content="OSDL">
  <meta name="keywords" content="OSDL, installation, laptop, multiboot">
  <link rel="stylesheet" type="text/css" href="../../../../common/css/OSDL.css">
  <link href="../../../../images/OSDL-icon.png" rel="OSDL icon">
</head>

<body>
  
  <div class="banner">
  
    <p><em>General</em> <a href="../../../../common/black.html" onclick="parent.toolbar.location='../../MainMenu.html'">home page</a>
    <a href="../../../../Map.html">site map</a> <a href="mailto:homebrew@esperide.com?subject=[OSDL]%20Homebrew%20for%20Nintendo%20DS">mail us</a></p>
	
  </div><a name="_top_"></a>
  

<h1>A guide to homebrew development for the Nintendo DS</h1>


<a name="toc">
<center>
	<table summary="Table of content" style="border: none">
        <tr>
          <td>
		<!--
		       <a href="#"></a><br>
		-->

		   <div class="box">
		       <a href="#overview">Overview</a><br>
		       <a href="#tobuy">What should be bought</a><br>
			   <ul>

		<!--
			<li><b></b> : </li>
		-->

					<li>A <a href="#buytheconsole">console</a></li>
					<li>Some recommended <a href="#accessories">accessories</a></li>
					<li>Required <a href="#addons">add-ons</a></li>
					
				</ul>
		       <a href="#inaction">The console in action, with and without its add-ons</a><br>
			   
		       <a href="#hardware">Hardware resources</a><br>
			   <ul>	   
					<li>The console <a href="#innerconsole">inner workings</a></li>
					<li>The <a href="#cartridges">cartridges</a></li>
				</ul>	
					   
		       <a href="#thirdparty">Using some third-party software</a><br>
			   <ul>
					<li>Understanding the various <a href="#romformats">ROM formats</a></li>
					<li><a href="#linkerstorage">Linker storage &amp; DLDI</a></li>
					<li>An example : <a href="#linuxonds">Linux on DS</a>
				</ul>		   
			   
		       <a href="#programmingDS">Programming the DS</a><br>
			   <ul>
			   		<li>Gathering the <a href="#tools">adequate tools</a> for homebrew</li> 
					<ul>
						<li>the compiler toolchain, with <a href="#devkitarm">devkitARM</a>
						<li>the low-level library, <a href="#libnds">libnds</a>
						<li>a FAT library, <a href="#libfat">libfat</a> 
						<li>a library to manage Wifi, <a href="#dswifi">dswifi</a> 
						<li>an (optional) higher level library, <a href="#palib">PAlib</a></li>
					</ul>
						
			   		<li><a href="#building">Building</a> your first DS program</li>
					<li><a href="#testing">Testing</a> your first DS program</li>

					<li> <a href="#usinghardware">Using effectively the hardware</a><br>
			   		  <ul>
						<li><a href="#twocpu">Two</a> general-purpose CPU to handle</li>					
						<li>Activating only the relevant <a href="#subsystems">subsystems</a></li>			
						<li>2D/3D <a href="#rendering">Rendering</a></li>		<li><a href="#sound">Sound</a> input and output</li>
						<li><a href="#datastorage">Data storage</a> &amp; application ressources</li>
						<li><a href="#inputdevice">Input device</a> management</li>
						<li><a href="#wireless">Wireless</a> networking</li>	
						<li><a href="#miscellaneous">Miscellaneous</a></li>
					  </ul>	
					</li>
							   
			   </ul>		   
			   
		       <a href="#otherinfos">Some other information sources</a><br>

          </div>

          </td>
        </tr>
      </table>
</center>
<!--
<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>
  -->

  
<a name="overview"></a>
<h2>Overview</h2>

<p>
The goal here is to develop applications, mostly games, to be run on the <a href="http://en.wikipedia.org/wiki/Nintendo_DS" target="_blank">Nintendo DS</a>, from the hobbyist point of view, as opposed to a software/game production company. This kind of developments is called <a href="http://en.wikipedia.org/wiki/Homebrew_(video_games)" target="_blank">homebrew</a>. We do not support piracy or the illegal use of the copyrighted Nintendo SDK by non-licensed developers. We use here unofficial development kits, such as <a href="http://www.devkitpro.org/" target="_blank">devkitPro</a>. These coding efforts are to remain free and legal.
</p>

<p>
Portable development will be kept in mind, as having one's game working both on a DS and on a PC is quite enjoyable. In this guide the C/C++ language will be favored. The development platform will be a standard PC, preferably using GNU/Linux.
</p>

<p>
Most of the informations here came from homebrew websites (many thanks to Cearn for <a href="http://www.coranac.com/tonc/text/" target="_blank">TONC</a> and to Chris Double for his <a href="http://www.double.co.nz/nintendo_ds/" target="_blank">tutorial</a>) and from IRC discussions (notably, thanks to <a href="" target="_blank">Wintermute</a> [Dave Murphy] and <a href="http://www.akkit.org/sgstair/" target="_blank">sgstair</a> [Stephen Stair]). More generally, many thanks to the fearless homebrewers !
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="tobuy"></a> 
<h2>What should be bought</h2>


<a name="buytheconsole"></a> 
<h3>The console</h3>

<p>
First of course is the Nintendo DS itself (see a video <a href="http://www.youtube.com/watch?v=Xp7Be1qsblI" target="_blank">presentation</a>). It should be a DS <a href="http://en.wikipedia.org/wiki/Nintendo_DS_Lite" target="_blank">Lite</a>, which is quite superior to the previous "<a href="http://en.wikipedia.org/wiki/Nintendo_DS" target="_blank">fat</a>" version : better screens, thiner, lighter, better autonomy, more beautiful, etc. The color does not matter, but the black version is quite sober, which opens it the possibility of somewhat faking a classical PDA. This is one of the intended uses in my case, besides game programming.
</p>

<p>
The main competitor for the DS would be Sony's PlayStation Portable, PSP, although they are quite different in price, capabilities and market shares. The lack of input device other than the gamepad, the quite low autonomy, the price and Sony policies make a lot of people favour DS over PSP, at least for the intended usage (PDA and homebrew).
</p>

<p>
As most console manufacturers enforce a unique pricing for all vendors, choose the one with the better conditions (guarantee, return policy, etc.), preferably not online : dealing with real shops is convenient, especially to have its DS replaced whenever there are dead pixels. This happens quite often apparently, and not all vendors accept easily to replace it. 
</p>

<p>
As for me, I bought my DS Lite in France, in a FNAC shop (I could cancel my buying during a 15-day period), in may 2007, for 150 euros, and had no dead pixel.
</p>

<p>
Here is the content of the Nintendo box :
<center>
    <a href="content.jpeg" target="_blank"><img src="content-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>

</p>

<p>This box includes only :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li>the <b>DS Lite</b></li>
	<li>the <b>power supply</b> to charge the batteries</li>
	<li>some (rather useless) <b>documentation</b></li>
</ul>
</p>

<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>




<a name="accessories"></a>
<h3>Some recommended accessories</h3>

<p>
You can make a better use of your DS potential thanks to them.
</p>

<center>
    <a href="accessories.jpeg" target="_blank"><img src="accessories-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>
</p>

<p>
From the most useful to the least :

<ul>

<!--
	<li><b></b> : </li>
-->

	<li><b>screen protectors</b>, necessary at least for the touch screen, whose life duration would be quite low otherwise (note : beware to the way they should be applied, I screwed up the first protection, and the second, for the touch screen, trapped nasty micro-bubbles of air; no, the screens do not have the same exact dimensions !). A kind of fabric could help cleaning the screens and the console itself : finger prints are quite visible on it, especially on the black DS</li>
	
	<li>a <b>case</b> for transporting safely your DS. Mine is in leather on purpose : wanting to look like a casual PDA</li>
	
	<li><b>replacement stylus</b>, in case you loose the only one provided (the smaller ones are for the "fat" DS)</li>

	<li><b>car power supply</b> : well, why not...</li>

	<li>specific <b>headphones</b> are quite useless, as the DS uses standard 3.5 jack. Would be interesting only if they included a microphone (seems to be a proprietary plug for audio input)</li>

	<li><b>game stylus</b>, to be placed on the user thumb. Not helpful here, for mostly non-gaming usage</li>
	
	<li><b>boxes for game cartridges</b>. I bought the DS only to program it, I do not plan to buy any game (hope you do not sell the DS at loss, Nintendo : the razor and blades business model won't work for homebrewers)</li>

</ul>

</p>

<p>
I bought a Bigben Interactive pack of 5 accessories (6 euros) and a (black) Subsonic Premium Pack (mostly for the leather case; 15 euros), both of course for DS Lite. Hence one can have all these recommended accessories for quite a low price.
</p>

<p>
See also the Wikipedia <a href="http://en.wikipedia.org/wiki/Nintendo_DS_accessories" target="_blank">article</a> about DS accessories.
</p>

<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>



<a name="addons"></a>
<h3>The add-ons for homebrew development</h3>

<h4>Needing a console that can be programmed</h4>
<p>
Having a basic console is not enough to be able to program it : Nintendo, due to the fear of piracy, preferred to make the life of homebrewers more difficult than technically needed, notably thanks to hardened firmwares preventing modifications or execution of non-acknowledged code : apparently they are encrypted with a private key from Nintendo, the device uses the embedded public one to decipher the firmware before running it.
</p>

<p>
Hence, to have access to a DS that can be programmed, one has to circumvent these protections. One of the simplest ways of doing so is to use special game-like cards, at least once. This is a vast subject and many cases have to be taken into account, see <a href="http://en.wikipedia.org/wiki/Nintendo_DS_booting_tools" target="_blank">Booting Tools</a> on Wikipedia for details.
</p>
  
  
<h4>A rather cheap and easy solution</h4>

<p>
Since the DS is not sold with a rewritable storage medium, some storage device is required to store homebrew. Though one could instead use <a href="http://en.wikipedia.org/wiki/Wireless_Multiboot" target="_blank">WMB</a> (<em>Wireless Multiboot</em>), which is a method to send programs to be run on the DS using a PC with specific Wi-Fi adaptors, but it would not be convenient enough : transferred content would be lost on DS power-off, a Ralink-compatible Wifi adaptor would be required, the sent applications could not occupy more than 4 MB, a hacked firmware would be needed, etc.
</p>

<p>
As for me, I intended to have Linux working on my DS, and for that the native 4 MB of RAM where quite small, so I wanted to have both 32 MB of additional RAM (the maximum size that can be addressed by the DS bus) and access to <a href="http://en.wikipedia.org/wiki/Nintendo_DS_storage_devices" target="_blank">mass storage</a> on removable media. 
</p>

<p>
The best and simplest bet was to use in the slot-1 (the DS-specific one, small and at the top of the console, a.k.a the DS card) a <a href="http://eng.supercard.cn/products.htm" target="_blank">SuperKey</a> (a kind of <a href="http://en.wikipedia.org/wiki/NoPass" target="_blank">NoPass</a>) as a fake game used to enable the execution of code from the slot-2 (the big one at the bottom, used for GBA compatiblity, a.k.a the GBA cartridge). This slot-2 would host a <a href="http://eng.supercard.cn/products.htm" target="_blank">SuperCard Lite</a> (note : avoid the rumble series, it does not provide more RAM), which indeed, besides the 32 MB of RAM, offers a <b>micro-SD</b> port.</p>

<p>
I bought both the SuperKey and the SuperCard Lite (black version) from <a href="http://www.fl-games.com/" target="_blank">FL-games</a> for 65 euros (shipping included) and was quite happy of it (no compatibility issue between the two cards to be afraid of).
</p>

<p>
Here are the three boxes : the Nintendo DS Lite one, the SuperKey and the SuperCard. Note the two-euro coin : there are quite small indeed.

<center>
    <a href="boxes.jpeg" target="_blank"><img src="boxes-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>
</p>
 
<p>
Here is a view of a bare DS running the default firmware (hence the mandatory health and safety warning) and, below, the quite tiny SuperKey and SuperCarde Lite themselves :

<center>
    <a href="warning.jpeg" target="_blank"><img src="warning-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>
</p>

 
<p>
Last be not least, one should have at least one micro-SD card, I bought a 2 GB Kingston one from <a href="http://www.pc-look.com/" target="_blank">PC-look</a> for 28 euros, shipping included. My laptop had a SD reader/writer (well, Ubuntu could not use it properly but it is another story), so no real need to buy anything else. Separate USB reader/writer are quite inexpensive anyway. Check that your micro-SD card is sold with a SD adapter, so that the actual tiny micro-card can fit in a basic SD reader. 
</p>

<p>
To use your micro-SD, you should first format it in <b>FAT</b> (i.e. FAT16, not FAT32), as factory settings are not reliable in all cases, or not the expected ones. Formatting can be done both from Windows or from Linux.
</p>

<p>
FAT is for the moment favored over other filesystems by most homebrewers, mainly because it is adequate for small size storage media, and for the sake of simplicity : there already exists a library for it on the DS, <a href="#libfat">libfat</a>.
</p>

<p>
Finally in my case the full equipment cost only 265 euros.
</p>

<a name="limitations"></a>
<h4>Some limitations for the seasoned homebrewer though : transferring files to the DS</h4>

<p>
Such removable media (as microSD) are not the magic bullet for the frantic homebrewer : to anticipate a bit on further subjects, when generating programs for the DS from your PC, to test them you may either execute them "in place", directly on your PC thanks to <a href="#emulators" target="_blank">DS emulators</a> (but they do not behave always as a DS would behave) or you have to send them to the DS by one way or another. This can be done thanks to the aforementioned microSD card, but it soon becomes tedious to swap again and again the card and its adapter. 
</p>

<p>
An alternate way would be to use a Wifi access point or a Wifi router, preferably not a mere Wifi adapter, which would have to embed a specific chip etc. in order to work with the DS. Such devices could be for example the famous <a href="http://en.wikipedia.org/wiki/WRT54G" target="_blank">Linksys WRT54G routers</a> (55 euros approximately) or <a href="http://en.wikipedia.org/wiki/Fonera" target="_blank">La Fonera</a>, both of which are inexpensive and, on a side node, run Linux, whose firmware and software can be programmed, etc., in a very similar way to the one we are to program applications for the DS.
</p>

<p>
Other still less usual methods would be :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li>a <b>parallel-port cable</b> :  you can open your DS, solder about 10 points to the motherboard, and get a parallel-port cable. But that's quite a lot of work</li>

	<li>the <a href="http://natrium42.com/blog/?p=38" target="_blank">dserial</a> ($45+shipping)</li>

	<li>the <b>Ds Xtreme</b>, if available. It is quite expensive though</li>
	
</ul>


<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>


 
<a name="inaction"></a>
<h2>The console in action, with and without its add-ons</h2>

<p>
The snapshot below shows the official main screen :  
<center>
    <a href="pictochat.jpeg" target="_blank"><img src="pictochat-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>
</p>

<p>
What happens when the cards are inserted ? Both ought to be used : if only the slot-1 one (SuperKey) is inserted, you will have two white screens, and if only the slot-2 one (SuperCard) is active, then your DS will run in backward compatibility mode for the GBA. 
</p>

<p>
When both cards are inserted, you can see the SuperCard splash screen, but here one could not go further, as the microSD card was not inserted. See it in its case, on the right, the SD adapter being on the left. The SuperCard-like black object below the DS is just the default plastic filler to protect the console from dust.
<center>
    <a href="supercard-run.jpeg" target="_blank"><img src="supercard-run-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>
</p>

<p>
Inserting the microSD card and rebooting is not really interesting, as this card  is still empty.
</p>

<p>
We see nevertheless that our customized console works well and is ready to be used.
</p>

 <p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>

 
 
 
 
<a name="hardware"></a> 
<h2>Hardware resources</h2>

<p>
Buying things was quite easy. Now, let's try to use them ! First of all, let's learn what is available for our developments.
</p>


<a name="innerconsole"></a>
<h3>The console inner workings</h3>
<p>
Even though Nintendo designed a low-cost handheld, the DS offers quite a lot of features :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li><b>two TFT back-lighted screens</b> (hence the DS meaning <em>Dual Screen</em>, although <em>Developer System</em> is mentioned sometimes), whose maximal resolution is 256x192, with up to 260 000 colors (5 bit for each channel). These are 3-inch screens (61x46 mm), with a dot pitch of 0,24 mm (contrast is 162:1). Screens are separated by about 21 mm. The DS Lite ones are far brighter and more resitant than the DS "fat" ones, and support four levels of brightness</li>
	
	<li>a resistive <b>touchpad</b> integrated with the bottom screen. The resulting touchscreen can be used with a stylus, the user's finger, wrist strap, etc. It can measure at most one press at a time, so it will average multiple presses, by reporting only a single one at their barycenter</li>
	
	<li>
	<p>

	<b>two all-purpose processors (CPU)</b> :
	  <ul>
		<li>an <b>ARM9</b> : <a href="http://en.wikipedia.org/wiki/ARM9E" target="_blank">ARM946E-S</a>, main CPU, 67 MHz, between 200 and 300 MIPS (<em>Million Instructions Per Second</em>), RISC 32 bit</li>
		<li>an <b>ARM7</b> : <a href="http://en.wikipedia.org/wiki/ARM7TDMI" target="_blank">ARM7TDMI</a>, co-processor, 33 MHz, about 20 MIPS, 16-bit/32-bit RISC</li>
	  </ul>
	</p>

	<p>
	Both can be running code at the same time. 
	</p>

	<p>
	The ARM (<em>Arcos Risc Machine</em>) family is quite widespread on embedded devices, and is known to be small, cheap and power-savvy. The Nintendo 64 offered roughly 100 MIPS, PlayStation 2 and PSP (PlayStation Portable) roughly 560 MIPS, GameCube 980 MIPS. According to some sources, the DS processors are under-clocked to save some power. Some people <a href="http://youtube.com/watch?v=PYIvASbELkw" target="_blank">overclocked</a> them, which involves quite some electronical skills and risks</p>
	</li>
	
	<li>several <b>memory banks</b>, notably 4 MB (4096 kB) of built-in RAM, whose layout is somewhat complex but for the most part is shared by the two processors. There is an additional 656 KB of video RAM, and 64 kB of <a href="http://en.wikipedia.org/wiki/Static_random_access_memory" target="_blank">SRAM</a> intended for game saves</li>
	
	<li>one GPU (<em>Graphical Processing Unit</em>) made of two <b>advanced 2D rendering systems</b> (one for each screen) and a <b>3D rendering system</b>, able to offer various <a href="#3D">3D features</a>. It can render up to 120 000 triangles per second at 60 frames per second, a fill rate of about 30 million pixels per second. This is a completely custom chip integrated in the same chip as both ARM. It is <b>not</b>, sadly, the PowerVR MBX that was announced by some <a href="http://portables.p-nintendo.com/articles/D-232-1.html" target="_blank">sources</a></li>

	<li>A <b>flashable</b> <a href="http://en.wikipedia.org/wiki/Firmware" target="_blank">firmware</a>, on NVRAM (Non-Volatile RAM)</li>
	
	<li>A <b>gamepad</b> (four-direction keys), with <b>6 bigger buttons</b> (X, Y, A, B in a cross layout; L and R on the far side of the DS) and <b>two smaller</b> (Start and Select)</li>
	
	<li>integrated <b>wireless networking</b>, able to offer proprietary protocol (called <em>NiFi</em>, for Nintendo Wifi) and 802.11b Wifi connectivity, both for local exchanges between DS and communications through the Internet (range between 10 and 30 meters)</li>
	
	<li>a <b>16 hardware channel Virtual Surround sound output</b> with stereo speakers (whose quality is rather good) and standard headphone plug (3.5 mm jack). A sliding button allows to set the volume. DAC runs at 10-bit 32768 Hz stereo</li>
	
	<li>a <b>microphone</b> for sound input, which allows (application-specific) speech-recognition</li>
	
	<li>two <b>slots for FLASH cards</b> : the Slot-1 (DS specific, looking a bit like a small Compact Flash card, currently up to 128 GB of internal storage) and the Slot-2 (legacy GBA port, used by several add-ons)</li>
	
	<li><b>lithium-ion battery</b> (1000 mAh battery, whereas the DS "fat" has 850 mAh) : with a DS Lite in DS mode, depending on the screen brightness, at least 6 to 10 hours of play, in GBA mode up to 12 hours, in sleep mode two weeks, all when starting from a fully charge battery (4 hours of charge). Of course autonomy decreases with slot-1/slot-2 cards being added. After five hundred charges, the battery capacity drops to about seventy percent and should be replaced</li>
	
	<li><b>small form factor</b> : the (closed) DS Lite is 133 mm × 73.9 mm × 21.5 mm (versus 148,6 x 84,6 x 28,7 mm for the DS "fat"), for 218g (275g for the DS "fat")</li>

	<li><b>built-in realtime 33MHz clock</b>, maintaining time and date even when the DS has been shutdown</li>

	<li><b>two green/orange/red LEDs</b> are available, they can be seen both when the console is open or closed. By default they inform about the Wifi and the battery status</li>
		
</ul>
</p>

<p>
The ARM RISC architecture is heavily inspired from the <em>GameBoy Advance</em> one. Both have an ARM7 (but the DS one is running at 66 MHz instead of 33 MHz), explaining partly the very good retrocompatibility of DS for GBA, and the DS hardware is quite close to the one of PocketPC devices. The performances are expected to be somewhat near the Nintendo 64 ones.
</p>

<a name="memorylayout"></a>
<p>
See the <a href="http://www.dev-scene.com/NDS/Tutorials_Day_2#Memory_Layout" target="_blank">diagram explaining the DS memory layout</a> on Dev-Scene website.
</p>

<p>
Input handling can be done thanks to the traditional gamepad, but also thanks to the touchscreen (it can be used to offer a virtual keyboard, or with a mouse-like interface, or as an handwriting tool, etc.) and/or the microphone (speaking, blowing, shouting, etc.).
</p>

<p>
The two screens can be used also with the DS rotated of 90 degrees, on its side, like an open book.
</p>

<a name="detailedhardware"></a>
<p>
More low-level informations about the DS hardware : 

<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->
	
	<li><a href="http://neimod.com/dstek/" target="_blank">DS Tek</a></li>
	<li><a href="http://nocash.emubase.de/gbatek.htm" target="_blank">GBATEK</a></li>
	<li><a href="http://auia.net/ds/" target="_blank">NDSTech</a></li>
	<li><a href="http://www.dev-scene.com/NDS/Tutorials_Day_2" target="_blank">Dev-Scene tutorial</a></li>
	
</ul>
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br>



<a name="cartridges"></a>
<h3>The cartridges</h3>
<p>
There are two different ports in which cards can be inserted : Slot-1 and Slot-2. In both cases, cards are mostly <a href="p://en.wikipedia.org/wiki/Read-only_memory" target="_blank">ROM</a>, but some of them have a small amount of non-volatile memory, usually <a href="http://en.wikipedia.org/wiki/EEPROM" target="_blank">EEPROM</a> (notably <a href="http://en.wikipedia.org/wiki/Flash_memory" target="_blank">Flash</a> memory), to save some data (highscores, game saved, etc.).
</p>

<h4>The Slot-1 port (a.k.a. DS port)</h4>

<p>
Usual DS game cards are 33.0 × 35.0 × 3.8 mm, and weigh around 3,5 g. They can contain up to 128 MB, but in this case they are a smaller transfer rate than 64 MB ones.  
</p>

<p>
SuperKey and the other Slot-1 <a href="http://en.wikipedia.org/wiki/NoPass" target="_blank">NoPass</a> counterparts, apart from allowing the use of the Slot-2 devices, do not add any memory or feature. They just set the program counter so that it points to a memory location in the GBA slot, allowing programs to be run from storage there. On the contrary, they consume some power that reduces the console autonomy. A <a href="http://en.wikipedia.org/wiki/Flashme" target="_blank">flashed</a> firmware can be used instead, for the most daring.
</p>


<h4>The Slot-2 port (a.k.a. GBA cart, or Flash Cart)</h4>

<p>
There are several slot-2 add-ons, which all provide their own set of features. From the ARM9 point of view, they can offer up to 32 MB of additional ROM (which can be actually RAM) and 64 kB of RAM. This GBA slot bus only supports 16-bit writes, which leads to problems when needing to perform 8-bit only write operations.</p>

<p>
The SuperCard Lite is one of the most interesting linkers, as it fits well in the GBA port (it does not protrude when used with DS Lite) and provides both the optimal 32 MB of RAM and an access to removable storage, here a microSD card. Most of these removable cards are formatted in <a href="http://en.wikipedia.org/wiki/File_Allocation_Table" target="_blank">FAT</a> (i.e. FAT16, not FAT32), which implies no more than 2 GB can be managed. 
</p>

<p>
These linkers use their built-in RAM as a mock flash cartridge, as a cache fed from their mass storage. Some DS homebrew also uses this additional RAM, though addressing issues and speed make it less useful than the DS's built in memory. Some people complained about Supercard's built-in RAM being too slow for some GBA games.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>






<a name="thirdparty"></a>
<h2>Using some third-party software</h2>

<p>
Software distribution on the DS is mostly based on ROM images, which can be downloaded on a PC as unique files. These files are read by the DS system, which see them as a kind of archive (a filesystem actually) containing possibly numerous files and directories.  
</p>



<a name="romformats"></a>
<h3>Understanding the various ROM formats</h3>

<p>
One can find several file extensions for Nintendo ROM. Each extension has a <a href="http://www.ndshb.com/modules.php?name=Content&pa=showpage&pid=27" target="_blank">specific meaning</a>, is associated to a specific executable format, and must be chosen adequately.
</p>

<p>
Their sole purpose is to contain binaries (i.e. executables) for the two ARMs and, most often, application-specific data (icons, bitmaps, sounds, etc.), stored as a unique flat file or as a full filesystems, in one or more files, each filesystem containing in turn files and directories. To be run from the GBA ROM (slot-2), they should include a loader that transfers them to the RAM.
</p>


<h4>Known formats &amp; extensions</h4>

<p>
The most frequent extensions are :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li><p><b>.nds</b> (ex: <code>myGame.nds</code>) : 
	this binary for the DS embeds the two executables needed, one for each ARM, and optionally some appended data. This file format was designed to be run from RAM filled from the slot-1, hence it does not include any specific loader. Therefore old generation .nds do not have a loader at all, and thus an external one must be used, generally provided by the menu loader of the flash cart device.</p>
	
	<p>Some newer .nds put nevertheless a loader, which they store into some unused space of the header. Sadly, many GBA flashers mess up the NDS header, thinking it's a corrupted GBA header. An external loader is then needed again.
	</p>
	
	<p>
	.nds files are made of a (NDS) header, then a region dedicated to the ARM7, then a region dedicated to the ARM9, then the data, for example a filesystem. The FlashMe + WMB method and GBA Movie Player support .nds files. They are often used with slot-1 cards, such as M3 and DS-X
	</p>
	</li>
	
	<li><b>.ds.gba</b> (ex: <code>myGame.ds.gba</code>) : this binary for the DS is designed to run from GBA ROM. It is usually made of a small loader (to transfer thanks to the ARM7 the ROM content from the GBA card to the main RAM) contained in a 512-byte (GBA) header, then a .nds file, and zero or more appended data files. The code from the .nds reads from the appended data files using reads from GBA ROM space. GBA flash carts, M3, and SuperCard support this. They are often used with slot-2 cards, such as EZ4</li>
	
	<li><b>.gba.nds</b> : the SuperCard firmware seems to believe that the .ds.gba format is indicated by the .nds extension. Hence to run a .ds.gba program on a SuperCard, one has to rename it first so that its extension becomes .nds. However by doing so one could mix it up with real .nds. One work-around is then to rename that program with, for example, a .gba.nds extension, instead of a mere .nds. However for a SuperCard, an original <code>myGame.ds.gba</code> could be renamed preferably to <code>myGame.sc.nds</code> (see below)</li>

	<li><b>.sc.nds</b> : extension to be used with SuperCard (sc) and, in some cases, G6 lite. This is a renamed .ds.gba (and maybe too DLDI-patched, see below). The .sc.nds extension is a (better since clearer) alternative to the ds.gba one</li>
	
</ul>
</p>

	
<p>
Some quite uncommon names and extensions are :
<ul>

<!--
	<li><b></b> : </li>
-->
	
	
	<li><b>.srl</b> : also called <em>clean dump</em>, it is a dump of commercial ROM, made of a .nds file and an appended file system, usually in Nitro-FAT format. The code in the .nds file reads from the appended file system, using block transfers, through the DS game card access registers. Homebrew tools do not generate .srl, and WMB does not support .srl. These clean dumps are sometimes distributed as .nds ROM, because they use the same header</li>
	
	<li><b>_BOOT_MP.nds</b> : the GBAMP (<em>GBA Movie Player</em>) will boot automatically on this file</li> 
	 
</ul>
</p>


<h4>Conversions between ROM formats</h4>

<p>
.nds programs can be converted into ds.gba programs. It involves prepending a loader, which may load the first appended .nds file, or allow selection of one of many .nds files.
</p>

<p>A loader can be a file named <em>ndsloader.bin</em>, which could be prepended that way :
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
On Windows :
copy /b ndsloader.bin &lt;the .nds file to convert&gt; &lt;the resulting merged file&gt; 

For example :
copy /b ndsloader.bin myGame.nds myGame.ds.gba

On Linux :
cat ndsloader.bin &lt;the .nds file to convert&gt; &gt; &lt;the resulting merged file&gt; 

For example :
cat ndsloader.bin myGame.nds > myGame.ds.gba
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
The other way round, from ds.gba to .nds, usually cannot be performed if not already done by the author, because most often the application relies on specific data meant to be embedded, which is not supported with a .nds file.
</p>

<p>
There are some tools, such as the <a href="http://l33t.spod.org/ratx/DS/SC/scmhbp/" target="_blank">Supercard Magic Homebrew Patcher</a>, that turns your .nds / .ds.gba files into a fixed supercard .sc.nds file. 
</p>

<p>Finally, most of the recent FAT-based homebrew applications need to be patched according to the relevant DLDI script, before being run.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="linkerstorage"></a>
<h3>Linker storage and DLDI</h3>

<p>
Before rushing for the numerous homebrew softwares available on the Internet, one must understand the problem encountered with the various <em>linkers</em>, the specific cards inserted in Slot-2 to provide dedicated storage. It therefore applies mostly to ROM using the .ds.gba format, including .gba.nds and .sc.nds. 
</p>

<p>
As each linker offers its own memory interface (the way it writes to the Flash ROM), as soon as an application has to access to a memory provided by the linker, this homebrew has to be aware of the specific linker it will run with. Several solutions exist : one may build as many versions of one's software as supported linkers (it becomes soon tedious and messy), or one may use Chishm's DLDI, for FAT-based applications.
</p>

<p>
<a href="http://chishm.drunkencoders.com/DLDI/" target="_blank">DLDI</a> stands for <em>Dynamically Linked Device Interface for libfat</em>. The DLDI-aware software can be storage-agnostic. It has just to be built once, and patched according to the target linker it is to run with, before being transferred to the DS.
</p>

<p>
The point is that for the user it is quite easy to patch the software, and it frees the developer from having to take into account each and every linker variation on the market. Even linkers released years after one's software will be supported thanks to DLDI, with no additional efforts from the original author.
</p>

<p>
DLDI is needed whenever libfat versions more recent than Christmas 2006 are being used.
</p>


<a name="dldiexample"></a>
<p>
In practice, the user will need :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li>the target <b>DLDI-enabled software to patch</b> (of course)</li>
	<li>a <b>patching tool</b> : the command-line or GUI <a href="http://chishm.drunkencoders.com/DLDI/" target="_blank">dlditool</a>, available for Windows, <a href="http://chishm.drunkencoders.com/DLDI/downloads/dlditool-linux-x86.zip" target="_blank">Linux</a> and Mac OS X</li>
	<li>the <b>device-specific patch file</b> which corresponds to your linker (see <a href="http://chishm.drunkencoders.com/DLDI/" target="_blank">DLDI Device patches</a>, including the one for <a href="http://chishm.drunkencoders.com/DLDI/downloads/sclt.dldi" target="_blank">SuperCard Lite (SD Card)</a>)</li>
</ul>

</p>

<p>
Linux users just have to put the dlditool archive (here <code>dlditool-linux-x86.zip</code>) and the device-specific patch file (here <code>sclt.dldi</code>) in a new directory and prepare them. For example :
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
mkdir ~/dldi
mv ~/dlditool-linux-x86.zip ~/sclt.dldi ~/dldi
cd ~/dldi
unzip dlditool-linux-x86.zip
chmod +x dlditool
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>



<p>
One just has then to use the DLDI tool to patch the software (here <code> myGame.nds</code>) according to its linker-specific patching specification : <code>./dlditool sclt.dldi myGame.nds</code> for example. Check that the tools returned that the operation was successfully performed.
</p>

<p>
Another option for Windows users is to install <a href="http://psychowood.altervista.org/getDLDIrc.html" target="_blank">DLDIrc</a>, which is configured once for all with a target linker and adds to the contextual menus for each selected DS ROM (the menu obtained with the right-click) the possibility to patch it.
</p>

<p>
More informations about DLDI : on <a href="http://www.dev-scene.com/NDS/Libfat_DLDI" target="_blank">Dev-Scene</a>.
</p>

<p>
Finally, some homebrew make use the SRAM (actually, a non-volatile RAM) that may be provided by a flash cart.
</p>



<a name="linuxonds"></a> 
<h3>An example : Linux on DS</h3>

<p>
Even though most DS applications are to be run standalone (i.e. by themselves, not using any other specific operating system), one can nonetheless have its DS run a dedicated <a href="http://en.wikipedia.org/wiki/Operating_system" target="_blank">operating system</a> (OS). Beyond the fun experience, it may allow for multitasking, or may just provide an environment familiar to the user, with useful tools.
</p>

<p>
Should an OS be used, it will have to be executed as any other application. This OS will then be able itself to run the applications it hosts. They may even run simultaneously, if the OS supports multitasking and if it does not monopolize too much of the DS resources for its own need, thus not letting enough CPU or RAM for these executables.  
</p>

<p>
Among all other operating systems, homebrewers often favor <a href="http://en.wikipedia.org/wiki/Linux" target="_blank">Linux</a>.
</p>

<p>
On the DS this OS is provided thanks to <a href="http://en.wikipedia.org/wiki/DSLinux" target="_blank">DSLinux</a>, based on <a href="http://en.wikipedia.org/wiki/UClinux" target="_blank">uClinux</a>.
</p>

<p>
It can be <a href="http://kineox.free.fr/DS/" target="_blank">installed</a> quite easily (this can be taken in charge through LOANI too, see <a href="#loaninds">below</a>) :
<ol>
<!--
	<li><b></b> : </li>
-->
	<li><b>download</b> <a href="http://kineox.free.fr/DS/dslinux-dldi.tgz" target="_blank">dslinux-dldi.tgz</a> on your computer
 </li>
	<li><b>extract</b> it in a new directory</li>
	<li><b>patch</b> the extracted <code>dslinux.nds</code> with the adequate DLDI device patch (refer to our DLDI <a href="#dldiexample">nano-guide</a>)</li>
	<li><b>copy</b> the full directory content (i.e. <code>dslinux.nds</code> and the <code>linux</code> directory extracted from the archive) at the root of your SD</li>
	<li><b>reboot your DS</b>, select Linux and enjoy</li>
</ol>
 
</p>

<p>
See DSLinux running, with the virtual stylus-based keyboard on the bottom screen :
<center>
    <a href="linux-global.jpeg" target="_blank"><img src="linux-global-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>
</p>

<p>
The terminal output is on the top screen :
<center>
    <a href="linux-zoom.jpeg" target="_blank"><img src="linux-zoom-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>

</p>

<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://dslinux.org/" target="_blank">DS Linux Official WebSite</a>, including its <a href="http://dslinux.org/?page=faq" target="_blank">FAQ</a></li>
	
    <li><a href="http://en.wikipedia.org/wiki/DSLinux" target="_blank">DS Linux on Wikipedia</a></li>
	
    <li><a href="http://www.debian.org/ports/arm/" target="_blank">ARM-dedicated Debian build</a></li>
	
    <li><a href="http://popcon.debian.org/" target="_blank">Popularity contest</a> for architectures supported by Debian (see ARM)</li>

</ul>
 
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>





<a name="programmingDS"></a>
<h2>Programming the DS</h2>

<p>
Programming the DS is quite fun because it is rather down to the metal : being that close to the hardware, with no operating system, no drivers, no hardware incompatibilities (well, until we look at the flash carts), it is a good pretext to struggle against low level details. Probably a very good way to practise embedded developments as well. Not to mention that having its own programs working on a console is quite satisfactory.
</p>

<a name="tools"></a>
<h3>Gathering the adequate tools for homebrew</h3>

<p>
Quite a few languages can use sources directly taken from the DS. They are mostly interpreted : there are ports for python, perl or lua, maybe one day Erlang. Some of them are expected to be run from DSLinux.  
</p>

<p>
As for C/C++, one would need a full build toolchain, since these languages are compiled instead of being interpreted. No native toolchain is available directly from the DS : it would demand more RAM than the built-in 4 MB (hence specific flash carts would be required), compilation would be long, and the development process would be quite painful.
</p>

<p>
Therefore the development process starts usually on a computer rather than on the DS : the built binaries are cross-compiled, i.e. they are generated on a PC but according to the conventions of another architecture, so that they can be executed finally on this target architecture (here, the DS). This is quite common in embedded environments.
</p>

<p>
Once the programs are compiled and linked, they can be tested in place, i.e. on the PC thanks to DS emulators, or they can be <a href="#limitations">transferred</a> to the DS and run on it.
</p>

<p>
We consider here that you have the basic tools installed on your computer, notably a text editor (vi, emacs, nedit, etc.) or an IDE (KDevelop, etc), and the <code>GNU make</code> program.
</p>

<p>
Most of the tools that will be mentioned here (i.e. devkitARM, libnds, libfat, dswifi, PAlib, DeSmuME, NO$GBA), plus dlditool, can be installed by hand or thanks the <a href="http://osdl.sourceforge.net/OSDL-latest/LOANI.html" target="_blank">LOANI</a> script, provided by OSDL for GNU/Linux users. One just has to download latest LOANI archive and to run :
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
./loani.sh --nds --buildTools
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
to have them automatically downloaded, extracted and installed in their OSDL reference version, ready to be used. All these tools are open source.
</p>

<p>
See <a href="http://www.dev-scene.com/NDS/Tutorials_Day_1#Installation_Of_Tools" target="_blank">Dovoto's tutorial</a> and <a href="http://www.devkitpro.org/setup.shtml" target="_blank">Dave Murphy's guide</a> (maintainer of devkiptARM) for more information about the installation of tools.
</p>

<p>
Note that the devkitARM tools are designed to run on 32-bit architectures. If your PC uses a 64-bit processor you will need the <code>ia32-libs</code> for Debian-based distributions.
</p>



<a name="devkitarm"></a>
<h4>First : the compiler toolchain, with devkitARM</h4>

<p>
We need the common build tools to generate binaries from our C/C++ sources : a preprocessor, a (ARM) compiler and a linker (not related to the cartridges, just a software) that knows the DS ROM <a href="romformats">formats</a> and its <a href="#memorylayout">memory</a> layout.
</p>

<p>
Tools for commercial developers are not available for homebrewers but, luckily, there is an alternative toolchain, whose name is <a href="http://www.devkitpro.org/" target="_blank">devkitpro</a>. This toolchain is adapted from the <a href="http://en.wikipedia.org/wiki/GNU_Compiler_Collection" target="_blank">GCC</a> one. Its supports many consoles besides the DS (GameBoy Advance, GP32, Playstation Portable and GameCube). DS are ARM-based, hence we need <a href="http://www.devkitpro.org/category/devkitarm/" target="_blank">devkitARM</a>, which provides everything we need (and more). </p>

<p>
Installing devkitARM on UNIX is straightforward : one just has to <a href="http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=124207" target="_blank">download</a> latest stable version and extract it. Nothing more needs to be done, as the toolchain is prebuilt here : you downloaded the appropriate binaries, and there is not real point in recreating them from their sources.
</p>

<p>With devkitARM you will be able to write programs with the classical C/C++ constructs. But what about text output ? Graphics ? Touchpad or key input ? The C/C++ language and runtime do not really provide these features natively, but you can do everything yourself. You just have to figure out for example that at address <code>0x4000000</code> there is a 32-bit register that you can write to, in order to control the display. Even if most relevant <a href="#detailedhardware">informations</a> are available, your time and patience might be quite quickly exhausted. Thus you can use a low level library instead, that would spare you these efforts. This is the task of libnds.
</p>

<p>
Note that dynamic libraries are not supported on the DS. Therefore each executable has to be statically linked with the libraries it uses. It is not a real drawback on such a platform where OS multitasking (see <a href="#linuxonds">DSLinux</a>) is not widely used. The size of your executables should not explode anormally due to the (static) linking to multi-purpose libraries, since only the symbols effectively referred to will be kept : if a library function is not used by the executable, its code will be stripped off automatically.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="libnds"></a>
<h4>Second : the low-level library, libnds</h4>

<p>
<a href="http://en.wikipedia.org/wiki/Libnds" target="_blank">Libnds</a>, formerly <a href="http://www.drunkencoders.com/documents/DS/ndslib.htm" target="_blank">ndslib</a>, supports nearly all features of the Nintendo DS, including: touch screen, microphone, 2D/3D hardware, and 802.11b Wi-Fi via the dswifi library.
</p>

<p>
It is not libnds purpose to give you advanced components that would do all the work for you. It is just a thin layer that will abstract a bit hardware facilities, thanks to suitable low-level primitives which will hide unwanted technical details, such as the actual location of registers in memory.
</p>

<p>
libnds is thin enough not to imply tradeoffs : compared to ad hoc lowest level programming, using it will not hinder anything or result in a loss of performance. 
</p>

<p>
Hence if you are not making a full use of libnds, most of the time it is that you chose to rely on higher level libraries.
</p>

<p>
The installation of libnds is trivial (just a matter of extracting the latest <a href="http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=151608" target="_blank">archive</a>). If you plan to use PAlib, libnds will be provided with it, no need for a specific libnds install then.
</p>

<p>
One can use also the <a href="http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=159894" target="_blank">libnds examples</a> to learn how to use the library. They are not installed by LOANI currently.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="libfat"></a>
<h4>Third : a FAT library, libfat</h4>

<p>
Most applications and games need some way of reading and writing from and to non-volatile media, and to access it as a filesystem rather than, say, a sequence of data blocks. This is useful notably to read resource files (images, sounds, etc.) and to write highscores, settings and saved games.
</p>

<p>
In the case of the DS many filesystems could be used, but one of them, FAT16, is by far the most common. To manage such filesystems, a dedicated library, <a href="http://chishm.drunkencoders.com/libfat/" target="_blank">libfat</a>, can be used. It depends on libnds, both of which being packaged as part of DevkitPro.
</p>

<p>
With libfat files can be managed almost exactly as they would be on POSIX systems. Directories follows different conventions.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="dswifi"></a>
<h4>Fourth : a library to manage Wifi, dswifi</h4>

<p>
<a href="http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=199021" target="_blank">dswifi</a> offers a low level interface to the DS Wifi connectivity. Access points, connexions, IP adresses, frames and packets can be easily handled thanks to that library.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="palib"></a>
<h4>Fifth : an (optional) higher level library, PAlib</h4>

<p>
<a href="http://www.palib.info" target="_blank">PAlib</a> (<a href="https://sourceforge.net/projects/pands/" target="_blank">alternate site</a> on Sourceforge) is one of those abstracting libraries. It is built on top of libnds and offers various higher-level integrated services to the homebrewer.
</p>

<p>
Like HAM for the GameBoy Advance, its intended public is developers wanting to use the most time-effective methods to write their software. Hardware purists often consider any library beyond libnds being useless (bloating software), restrictive or performance-killer. One should try both ways. As for me, I found interesting to use first libnds only, to learn how things work. Once done, anything allowing to gain some time sounds interesting to me, and I would not like to reinvent the wheel too often. So I use PAlib for most of my needs.  
</p>

<p>
To install it, follow <a href="http://www.palib.info/wiki/doku.php" target="_blank">PAlib's tutorial</a> or use LOANI.
</p>

<p>
There are still many other libraries, but they are less used. <a href="http://libsdl.org/" target="_blank">SDL</a> has been <a href="http://gpf.dcemu.co.uk/ndsSDL.shtml" target="_blank">ported to the DS</a>. This abstraction layer is very useful to port (often PC) applications to lesser known platforms such as the homebrew-enabled DS, but in our case a few issues remains : the DS SDL implementation is not complete, it uses a lot of memory with regard to what is available, and a lot of hardware acceleration would be bypassed because of the layer. SDL may be here a way of starting a port, even though finally the game ought not rely on it for performance reasons.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="building"></a>
<h3>Building your first DS program</h3>

<p>
Now has come the time for a first test. LOANI users should first source the <code>LOANI-installations/OSDL-environment.sh</code> file to update their environment : <center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
. OSDL-environment.sh
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>
 
 
<p>
Then let's build some tests : go for example in <code>devkitPro/PAlibExamples/Input/Keyboard/Keyboard</code> and just execute <code>make</code>. It will read the <code>Makefile</code> and generate, from the sources (in <code>source/main.c</code>), the corresponding ROM : <code>Keyboard.ds.gba</code>, <code>Keyboard.nds</code> and
<code>Keyboard.sc.nds</code> (all occupying around 95 ko). Refer to our section about <a href="#romformats">ROM formats</a> for a reminder of their respective role.
</p>

<p>
Something similar to this should occur :
<center>
    <table summary="a box" style="border : none">
        <tr>
          <td>
            <div class="box">
&gt; make<br>
main.c<br>
arm-eabi-g++ -g -mthumb-interwork -mno-fpu -LYourLOANIDir/LOANI-0.5/LOANI-installations/devkitPro/PAlib/lib -specs=ds_arm9.specs main.o -LYourLOANIDir/LOANI-0.5/LOANI-installations/devkitPro/PAlib/lib -lpa9 -LYourLOANIDir/LOANI-0.5/LOANI-installations/devkitPro/libnds/lib -lfat -lnds9 -ldswifi9 -o build.elf<br>
Nintendo DS rom tool 1.33 - Jan 27 2007 16:00:04<br>
by Rafael Vuijk, Dave Murphy,  Alexei Karpenko<br>
built ... Keyboard.ds.gba<br>
dsbuild 1.21 - Jan 28 2007<br>
using default loader<br>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
To decrypt a bit, the Makefile will try to rebuild target <code>$(OUTPUT).ds.gba</code>, whose name is deduced from the current directory (here, Keyboard). To build <code>Keyboard.ds.gba</code>, <code>Keyboard.nds</code> is needed, which in turns implies <code>Keyboard.bin</code> exists, then <code>Keyboard.elf</code>, then <code>$(OFILES)</code>. This variable contains all the object files needed, deduced from the source code (<code>*.c, *.cpp</code>) but also from the resources to be embedded (ex : <code>*.jpg, *.bmp</code>, etc.).
</p>

<p>
Thus the first thing is to obtain these object files. The C++ compiler for ARM (<code>arm-eabi-g++</code>) is called to generate an object file, main.o, for the ARM9, from main.c. Have a look at this file, this is the main one you are expected to write on the future. 
</p>

<p>
Once all the object files are created, they can be aggregated by the linker (here, <code>arm-eabi-g++</code> again) in <code>Keyboard.elf</code> (ELF for <code>External Link Format</code>).
</p>

<p>
More precisely main.o, that provides the <code>main()</code> function, will be linked (statically; no dynamic linking available on the DS) with PAlib (<code>-lpa9</code> refers to <code>libpa9.a</code>, 9 for the ARM9), which itself uses some helper libraries : libfat, libnds9, dswfi9, even if simple this example do not use them all. Linking with unused libraries will not make your ROM bigger : they will not be included if really not used.
</p>

<p>
<code>Keyboard.elf</code> can then be converted in <code>Keyboard.bin</code> by <code>arm-eabi-objcopy</code>, whose role is to copy and translate object files from a given format to another.
</p>

<p>
From <code>Keyboard.bin</code>, <code>Keyboard.nds</code> (at last, a ROM file !) will be generated thanks to <code>devkitARM/bin/ndstool</code>, whose role is to combine the two executables and the data resources into a single file ready for DS distribution. Note that <code>Keyboard.bin</code> contains everything but the executable for the ARM7. This one is retrieved here from a precompiled default version, a kind of template, located in <code>arm7.bin</code>.
</p>

<p>
Finally the <code>devkitARM/bin/dsbuild</code> executable is used to generate <code>Keyboard.ds.gba</code> from <code>Keyboard.nds</code>. This involves adding a slot-2 loader. 
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="testing"></a>
<h3>Testing your first DS program</h3>

<p>
You have two options here : either the ROM must come one way or another to the DS (transfer), or the DS must come to the ROM and the PC (emulation). 
</p>


<h4>Transferring</h4>
<p>
The most obvious method is to transfer your ROM, here <code>Keyboard.sc.nds</code>, to your DS : copy it to, say, your microSD card, insert that card in your DS and run the ROM, for example thanks to the SuperCard menu. That should work.
</p>

<p>
This method has however two drawbacks. The minor one is that on some computers, notably laptops like mine, Linux support for SD card is still quite limited, and often you end up with mounting, reading or writing problems. The major drawback is, even if the SD are well recognized, it becomes soon tiedous to swap the card again and again between its adapter on PC and the DS. For most people, the developing process requires too frequent tests to do so.     
</p>

<p>
Using a Wifi transfer, preferably thanks to a router, could do the trick, and be more convenient than the card swap. One could use DSLinux for a SSH or FTP transfer followed by a reboot. This is not necessarily the best solution ever though. As for cable (parallel, USB, etc.), as already discussed, they either require soldering efforts or are quite expensive. 
</p>


<h4>Emulating</h4>

<p>
The second method for testing your programs is to use an <a href="http://en.wikipedia.org/wiki/Emulator" target="_blank">emulator</a>. This will allow a PC to mimic your DS, so that you can test in-place the (approximated) result of your ROM.
</p>

<p>
Though the imitation is not always perfect, emulators have progressed a lot. For the Linux user, in decreasing order of interest, one should use :
<ol>
<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li>
	<p>
	<a href="http://www.desmume.org/" target="_blank">DeSmuME</a> : there is a <a href="http://desmume.org/?p=19" target="_blank">Linux</a> version and Debian packages, based on a <a href="http://gpf.dcemu.co.uk/ndsSDL.shtml" target="_blank">SDL</a> port. Some people prefer to run the Windows version from Wine (<code>apt-get install wine</code> for Debian-based distributions). 
	</p>

	<p>
	To do so, <a href="http://www.desmume.com/download.htm" target="_blank">download</a> DeSmuME latest stable version, unzip it, and simply run <code>wine NDeSmuME.exe</code>. In the <code>File</code> menu, you can select <code>Open and Execute</code>, and choose your .nds file (ex : <code>Keyboard.nds</code>). You should then be able to test it immediately
<center>
    <img src="DeSmuME-screenshot.png" alt="DeSmuME"></img>
</center>
	</p>
	</li>
	
     <li><a href="http://nocash.emubase.de/gba.htm" target="_blank">NO$GBA</a> should be used with Wine too. Just <a href="http://nocash.emubase.de/no$gba-w.zip" target="_blank">download</a> it, unzip it, run <code>wine NO\$GBA.EXE</code> and select, this time, your .ds.gba file (ex : <code>Keyboard.ds.gba</code>)
<center>
    <img src="NoCashGBA-screenshot.png" alt="NO$GBA"></img>
</center>

</li>
	 
    <li><a href="http://dualis.1emu.net/dsti.html" target="_blank">Dualis</a> (not tested; known to be faster than NO$GBA, but now unable to manage libfat unless FCSR drivers are used)</li>
	
    <li><a href="http://www.ndsemulator.com/nintendo-ds/ideas-download.htm" target="_blank">Ideas</a> (not tested)</li>
	
    <li><a href="http://www.ndsemulator.com/nintendo-ds/ensata.htm" target="_blank">Ensata</a> (not tested; illegal material leaked from Nintendo, according to some sources)</li>
	
</ol>
</p>

<p>
See also the <a href="http://www.ndsemulator.com/" target="_blank">NDSEmulator.com</a> site.
</p>


<p>
Having the general hardware specifications and the relevant toolchain is not enough to be able to program effectively the DS : there is still additional informations to gather before being able to write full-blown applications for it.
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="usinghardware"></a>
<h3>Using effectively the hardware</h3>

<a name="twocpu"></a>
<h4>Two general-purpose CPU to handle</h4>

<h5>Respective intended use &amp; performance</h5>

<p>
For newcomers, one of the most disturbing specificities of the DS is its having multiple processors. They are expected to share the load : even if both ARM are rather general-purpose, the ARM9 should take the most of computation-intensive tasks, including graphic-related operations (it is the only one that can interact with the 3D rendering engine), the ARM7 should concentrate on input management (touchscreen, most keys), wireless communications, audio output and any GameBoy emulation, whereas the 2D/3D engines will be dedicated to visual rendering.
</p>

<p>
Roughly speaking, the ARM9 can be somewhere between 1.5 and about 4 times faster than the ARM7, depending on what task is involved.
</p>

<p>
ARM7 and ARM9 are often configured to use thumb mode (16 bit). The reason for this, in both cases, is memory space : ARM7 has limited program space, whereas ARM9 has limited instruction cache space. As for the 16-bit wide bus accesses (there are severa of them), ARM (32-bit) instructions would saturate the bandwidth and seriously decrease overall performance.
</p>

<p>
Some applications manage to rely on very tight 32-bit loops that fit in the instruction cache (IWRAM), so that they can benefit from a more "powerful" instruction set, for critical parts. Apart from the 32-bit memory regions fed by 32-bit buses, one should prefer Thumb (16-bit) instructions.
</p>

<p>
Neither CPU of the DS has a Floating Point Unit (FPU), so all floating-point operations must be emulated (they have to be done in software), which is very slow. Most computations use therefore :
<ul>
        <li><b>fixed-point (integer) arithmetics</b> for basic operations (addition, substraction, multiplication and division), see <a href="http://www.coranac.com/tonc/text/fixed.htm" target="_blank">TONC</a> and <a href="http://en.wikipedia.org/wiki/Fixed-point_arithmetic" target="_blank">Wikipedia</a> for further informations on this subject</li>

       <li><b>(precomputed) Look-Up Tables</b> (LUT) for other computations, such as trigonometric ones (<code>cos</code>, <code>sin</code>, etc.). See <a href="http://www.coranac.com/tonc/text/fixed.htm#sec-lut" target="_blank">TONC</a> for more details on this</li>

</ul>
</p>

<p>
As a consequence of having two CPU, the DS ROM has to include at least two executables, one for each of the ARM (not mentioning application-specific data). At runtime the executables will have to work simultaneously, which involves often having to be synchronized and to share data. 
</p>


<p>
Monitoring the ARM loads is not easy, even when using emulators. Profiling can be done via <a href="#timers">timers</a> : one can start some hardware timers when a task starts, and then stop and read them when the task is done. That information is rather precise, and you can use it to provide a lot of information about how much of the CPU power is being used; but it's a bit of a hassle to set up.
</p>

<p>
Some <a href="http://www.coranac.com/tonc/text/first.htm#sec-notes" target="_blank">guidelines</a> should be applied to write effective code for the DS.
</p>

<h5>CPU &amp; Memory</h5>
<p>
The main built-in memory, consisting of one big block of 4MB memory, can be accessed by both ARM's, but one at a time. When both CPUs are trying to read main memory, one will have priority over the other.
</p>

<p>
Depending on a data being const or not, the linker will place it respectively either on an average memory rather unconstrained or in IWRAM, which is the fastest but one of the smallest. Therefore each time one forgets to specify the <code>const</code> qualifier for an actual constant, it may use unnecessarily the most researched IWRAM instead of low-end memory.
</p>

<h5>Interrupts</h5>

<h6>Interrupts in general</h6>

<p>
An interrupt (or IRQ, for <em>Interrupt Request</em>) is a way of stopping immediately the current execution of a CPU to run another function, called an interrupt handler. Hence when a hardware or software interrupt occurs, the processor saves first some information so that it knows where to go back and in which state, then the handler associated to this interrupt for that CPU is called at once and, when that function returns, the DS continues executing the piece of code it was executing before it was interrupted, as if nothing had happened.
</p>

<p>
Therefore interrupts allow to perform tasks that should not wait, either because otherwise they might be missed (ex : a keypress described in a hardware register) or because the application must react directly to them (ex : a Vertical Blank Interrupt that would trigger rendering, see below).
</p>

<p>
Interrupts allow also to use the CPU sleep mode, since they provide a way of waking it up as soon as it becomes needed again, thanks to a BIOS routine. In this low power mode, the ARM9 stops processing instructions and powers down some memory banks to save battery charge. There is a ARM instruction named SWI (for <em>SoftWare Interrupt</em>) with one numerical parameter that means : enter the SWI handler and pass that value to know  which interrupt or combination of interruption the CPU should be waiting for, from now on. Helper libraries, including libnds, offer higher-level interrupt management. If most of the program is in interrupt handlers, then the CPU may sleep most of the time, preserving the charge of the DS batteries.
</p>

<p>
By default when an interrupt is triggered, the CPU jumps to the standard BIOS interrupt routine, a function which is stored in a special memory address that we can write to. By storing at this memory address a pointer to one of our own function, we can cause the interrupt to be processed by our own function, i.e. we can define our custom interrupt (IRQ) handler.
</p>

<p>
The ARM7 stores the addresses of its interrupt handlers in a hardcoded memory location, whereas the ARM9 defines these addresses relativey to the DTCM, a special memory area in the ARM9 which can be mapped to reside at various actual physical addresses.
</p>

<p>
Both CPU can trigger interrupts to each other (if the ARM9 allows it). It is convenient to send a notification to the other CPU when for example there is data for it waiting to be read on a shared area in RAM, once the calling CPU has finished filling it.
</p>

<p>
Beyond screens and sometimes keys, FIFO, IPC and <a href="#timers">timers</a> make heavy use of interrupts.
</p>


<h6>Screen-related interrupts : Horizontal &amp; Vertical Blank Interrupts</h6>

<p>
The DS screens are updated neither as a whole nor permanently : the graphics hardware draws pixels one by one, from the top left to the bottom right of each screen, line by line.
</p>

<p>
If the framebuffer (the place in memory where the pixels are stored) is modified during this process, the user may see visual artefacts in the form of partly-updated images, the top-left part being rendered according to the previous state of the framebuffer, bottom-right with the current one.
</p>

<p>
During a short duration after a line is drawn, during a longer one once a full screen is rendered, the hardware remains idle. These moments can be used to perform safe rendering : no partial redraw is to be feared.  
</p>

<p>
Two special interrupts are fired so that the programs can use these two favorable periods : one, the <em>Horizontal Blank Interrupt</em>, occurs whenever a line has been rendered. Your program can use this first amount of time. The other one, more famous, is the <em>Vertical Blank Interrupt</em> (VBI) that is fired once a full screen has be redrawn. Your program should use this longer duration to perform at least framebuffer-related operations, while the hardware moves from the last line back up to the first line. This stage is called Vblank, as opposed to Vdraw, the screen refresh time.
</p>

<p>
 At both screens are refreshed at 60 Hz, the period between two VBI is 16,7 ms long. More <a href="http://www.coranac.com/tonc/text/video.htm#sec-blanks" target="_blank">info</a> (coming from GBA but still applies here). The VBI is called also vsync, since it allows for vertical synchronisation.
</p>

<p>
Note that all other operations (input reading, sound output, application logic, etc.) can be performed regardless of these two interrupts. The VBI, beyond its use to avoid visual artefacts, provides a hard real-time 60Hz time-base too. This time base can be used to schedule operations on a regular basis.
</p>


<h6>Key Interrupts</h6>

<p>
Keys can be read thanks to <a href="#keys">several methods</a>, including the interrupt-based one. In this case a specific IRQ handler is registered. This handler will be triggered indeed when a key is pressed, but it will not be called when the key will be released, which reduces quite a lot the interest of this key handling method.
</p>


<h5>ARM7 role</h5>

<p>
The ARM7 is the only CPU that can be used for controlling the touchscreen. Most applications use boilerplate code that sets up an interrupt handler for the already mentioned <em>Vertical Blank Interrupt</em> (VBI). Not for rendering purpose here, but for synchronization, so that the interrupt handler dedicated to ARM7 input reporting can be scheduled regularly. The ARM7 boilerplate code gets the value of the touchscreen parameters and stores them in a data structure we can access from the ARM9.
</p>

<p>
devkitPro includes a default ARM7 program to handle basic tasks like interrupts, touchscreen, etc. It is the <code>arm7.bin</code> discussed in our <a href="#building">building</a> section. Usually there is no need to write custom ARM7 code. The standard Makefiles include this default ARM7 program.
</p>


<h5>ARM9 role</h5>

<p>
Due to its superior power compared to the ARM7, the ARM9 is the main processor and as such will take in charge most of the work. Application-specific code is expected to run on it.
</p>

<p>
A single <code>main()</code> function defines usually :
<ol>

	<li>an <b>initialization</b> stage, to set screen modes, memory banks, interrupt handlers, to initialize various libraries (ex : PAlib, libfat, dswifi, etc.) and to perform as many tasks as possible (ex : loading the resources from mass storage, setting up Wifi connections, etc.)</li>

	<li>a <b>main loop</b>, in charge of : 
		<ul>

		<!--
		        <li><b></b> : </li>
		-->

  		     <li><b>game logic</b>, including any AI algorithms</li>
  		     <li><b>input management</b>, partly read from the ARM7 (touchscreen, some keys)</li>
  		     <li><b>audio and video rendering</b>, partly managed by the 2D/3D engines too</li>
  		     <li><b>I/O exchanges</b> with a mass storage device, if any</li>
		</ul>
	</li>

	<li>a <b>shutdown</b> stage, to stop all subsystems properly, including flushing write buffers (closing files, unmounting mass storage, etc.), stopping the Wifi connections, etc.</li>
</ol>
</p>

<h5>Inter-CPU communication</h5>

<p>
As each ARM has specific abilities (ex : the ARM7 is the only one that can access the hardware for sound and wireless), they have to communicate to send to the other ARM commands to be executed on the sender behalf.
</p>

<p>
The ARM CPU can communicate thanks to <a href="http://en.wikipedia.org/wiki/Inter-process_communication" target="_blank">IPC</a> (<em>Inter-process communication</em>) based on a set of registers, managed thanks to a <a href="http://en.wikipedia.org/wiki/FIFO" target="_blank">FIFO</a> (<em>First In, First Out</em>) data structure. It corresponds actually to a <a href="http://en.wikipedia.org/wiki/Message_queue" target="_blank">message queue</a> with an asynchronous communication protocol.
</p>

<h6>Custom-made IPC (not recommended)</h6>
<p>
More precisely, commands can be described by the ARM9 in a data structure for the ARM7, for example a C union or a non-abstract C++ class inheriting from an abstract command class. These commands should specify the requested action (ex : play sound) and its associated data (ex : a pointer to the samples stored in main memory). A set of commands can then be kept in shared memory, accessible by the ARM7 and ARM9.
</p>

<p>
The command set can be implemented thanks to a circular C array or a C++ (FIFO) std::queue that would be instanciated into the shared memory area, after the libnds IPC region, i.e. after the libnds-defined IPC starting address at the <code>IPC</code> symbol incremented of an offset equal to the length of <code>TransferRegion</code>.
</p>

<p>
So the ARM9, after having initalized the queue, is expected to place a command in it whenever needed, whereas the ARM7 is expected to poll regularly the queue (ex : thanks to the VBI) in order to gather and execute commands.
</p>

<p>
This IPC method has two drawbacks. First it is only one-way : the ARM7 cannot send commands or results to the ARM9, as no protection against concurrent accesses is available here. Second it requires the ARM7 to perform polling, at the expense of uselessly burnt CPU cycles.
</p>


<p>
See <a href="http://www.double.co.nz/nintendo_ds/nds_develop6.html" target="_blank">Chris Double tutorial #6</a> for more details about custom-made IPC. 
</p>


<h6>Harware-based IPC (recommended)</h6>

<p>
The DS provides a built-in interrupt-based FIFO queue. Therefore the ARM7 can receive immediately interrupt notifications, instead of having to poll, which is rather inefficient. The FIFO handles concurrent accesses in hardware, which allows fast reliable bidirectional communications. This queue can only hold 16 items (<code>int</code>, that can be taken as integers or as pointers to user-defined data) on each side, so the other processor should be receiving these items in a timely manner.
</p>

<p>
Each CPU has a queue which it can put data on. The other CPU can receive this data by reading from a register or thanks to an interrupt. It will get the oldest item that the original CPU put on the queue. A kind of small application-specific protocol could be specified to manage the queue exchanges.
</p>

<p>
See <a href="http://www.double.co.nz/nintendo_ds/nds_develop7.html" target="_blank">Chris Double tutorial #7</a> for more details about hardware-based IPC. 
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


 
<a name="subsystems"></a>
<h4>Activating only the relevant subsystems</h4>

<p>
First, the DS can run in different modes, including the GBA Mode (ARM9 not used), sleep (for the ARM7), stop, halt, etc. The DS can be woken up from various IRQ (<em>Interrupt Requests</em>) :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li>timer triggered</li>
	<li>screen being opened</li>
	<li>slot-1 or slot-2 card being removed</li>
	<li>certain key combination pressed (with the exception of X and Y)</li>
</ul>
</p>

<p>
Second, most subsystems of the DS can be powered independently : sound speakers, Wifi, LCD screens, the two 2D engines, the 3D rendering and geometry engines.
</p>

<p>
Selective activation is useful notably to save energy.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>





<a name="rendering"></a>
<h4>2D/3D Rendering</h4>

<h5>Rendering in general</h5>

<p>
Most of the informations related to the graphical rendering are stored in the VRAM, for <em>Video RAM</em>.
</p>

<p>
2D/3D rendering requires images, geometries, textures, etc. to render, see our <a href="#datastorage">data storage</a> section explaining how to access the resources needing by your application.
</p>

<p>
If the rendering takes place during the screen are redrawn, then the user will see on its screens images partly updated, leading to unwanted visual artefacts. The solution is either to modify the screen content only between two redraws or to use <a href="#pageflipping">page flipping</a>.
</p>

<p>
 The first approach can be implemented by waiting the aforementioned VBI (<em>Vertical Blank Interrupt</em>) and performing the rendering only in its handler, i.e. in hard real time. One has just to ensure it does not last more than the period between two VBI, i.e. 16 ms at 60 Hz.
</p>


<a name="pageflipping"></a>
<h6>Page flipping</h6>
<p>
When rendering is not trivial, it might not be short enough to fit in the VBI. <a href="http://www.coranac.com/tonc/text/bitmaps.htm#sec-page" target="_blank">Page flipping</a> (not to be mixed up with the more expensive double-buffering, which involves an extra screen copy) is a method so that the software can create a screen buffer while the hardware, simultaneously, displays another buffer. At each VBI buffers are exchanged so that they can both continue their task. Page flipping is thus a way of eliminating nasty artefacts like tearing in animations. 
</p>


<h6>Screens</h6>

<p>
In software you manipulate a <em>main</em> screen abstraction (main rendering core), that can be mapped either to the top actual screen or to the bottom one, and a <em>sub</em> screen (sub rendering core), which will correspond to the other hardware screen. They can be swapped at any time thanks to <code>lcdSwap()</code>.
</p>


<h6>Video modes</h6>

<p>
Both cores can be set in various <em>video modes</em>, each with different capabilities and features. The <em>sub core</em> has only five different video modes, whereas the  <em>main core</em> is more powerful : it is able to reallocate more VRAM, and has the ability to render basic vertex 3D (with a 2048 polygon limit) and several vertex shaders, such as Toon Shading. It also has an extra video mode called Mode6. In addition, the display capture device is capable to take a capture screen only from this core. See <a href="http://liranuna.drunkencoders.com/nds-2d-tuts/lesson-1" target="_blank">LiraNuna's 2D tutorial</a> for more details.
</p>

<p>
 In a given screen mode, pixels are described according to a specific pixel format, that dictates their memory layout : their length (ex : 16 bit per pixel), their convention (ex : RGB-color space with, say, GBR ordering), the size of each color component (ex : 5 bit per component, 555, components range each from 0 to 31), and some other informations including transparency (based on an alpha bit), that dictates whether a given pixel should be displayed or not. There are libnds-provided macros (ex : RGB15) that help defining pixels according to specific formats. See <a href="http://www.double.co.nz/nintendo_ds/nds_develop2.html" target="_blank">Chris Double tutorial #2</a> for more details. 
</p>


<h6>VRAM Memory Banks</h6>

<p>
Depending on the video mode, each rendering core will retrieve its video-related informations (ex : bitmaps, sprites, tiles) from hardcoded regions defined in memory address space.
</p>

<p>
These are <em>address</em> regions (i.e. a lower and higher addresses), but by default at these adresses there is no actual memory. You therefore need to map predefined chunks of actual video RAM into these areas for the cores to use them. Each of these chunks is called a bank, there are nine of them, labelled VRAM_A through to VRAM_I. Each of these has a particular size and are best suited for different purposes. The banks are:
<center>
  <table border="1" summary="VRAM Memory Banks">
    <caption>VRAM Memory Banks</caption>

    <tr>
        <th>Bank name</th>
        <th>Bank size (in Kilobytes)</th>
    </tr>

    <tr>
        <td>VRAM_A</td>
        <td>128</td>
   </tr>

    <tr>
        <td>VRAM_B</td>
        <td>128</td>
   </tr>

    <tr>
        <td>VRAM_C</td>
        <td>128</td>
   </tr>

    <tr>
        <td>VRAM_D</td>
        <td>128</td>
   </tr>

    <tr>
        <td>VRAM_E</td>
        <td>64</td>
   </tr>

    <tr>
        <td>VRAM_F</td>
        <td>16</td>
   </tr>

    <tr>
        <td>VRAM_G</td>
        <td>16</td>
   </tr>

    <tr>
        <td>VRAM_H</td>
        <td>32</td>
   </tr>

    <tr>
        <td>VRAM_I</td>
        <td>16</td>
   </tr>

  </table>
</center>
</p>


<a name="2D"></a>
<h5>2D Rendering</h5>

<p>
The system has two 2D engines, one per screen. Each screen can be put into a variety of different modes, with different feature sets. These engines are each quite similar to the Game Boy Advance's single 2D engine, though more powerful.
</p>



<h6>Backgrounds</h6>

<p>
Each video mode has a number of <em>backgrounds</em> (BG) that can be used. A background is a surface that, when drawn upon, displays on the hardware like a layer. Modes that have multiple backgrounds allow these backgrounds to be overlayed, so that they are drawn on top of each other. This, and the support of transparency, enables for example a background with text to be overlayed on top of a background displaying an image. Backgrounds are opposed to sprites : the former take care of the decoration, the often static environment that may take the entire screen, whereas the later take care of the living entities (small moving objects, like animated characters).
</p>

<p>
There are three types of backgrounds : Rotoscale, Extended Rotoscale and Text.
</p>

<h7>Rotoscale backgrounds</h7>
<p>
<em>Rotoscale</em> backgrounds are framebuffer-like bitmaps (or surfaces, in SDL-like language) that can be manipulated (affine transformations : 2-axis scrolled, scaled in or out, rotated, sheared, thanks a <a href="http://user.chem.tue.nl/jakvijn/tonc/affine.htm" target="_blank">transformation matrix</a>) and displayed directly on screen, all in hardware, i.e. with little overhead for the CPUs, no additional VRAM copy and no specific developing effort (it only involves setting some registers). They can be smaller or bigger than a screen, in which case only the relevant parts will be shown (clipping). 
</p>

<p>
As they can be accessed (read and write) like the framebuffer and they provide additional hardware capabilities, they tend to make it useless.
</p>

<p>
One may use for example a 16-bit 256x256 background size, which is larger than the DS screen (256x192), to demonstrate scrolling around an image. It would use 128 kilobytes to store the image, VRAM_A could be used. 
</p>

<p>
When using tiles, rotoscale backgrounds can use only up to 256 of them.
</p>

<p>
Finally, hardware scrolling can be of great help to implement parallax scrolling (a fake sense of depth), when having multiple backgrounds sliding at different paces.
</p>


<h7>Extended Rotoscale backgrounds</h7>
<p>
<em>Extended Rotation Backgrounds</em> (ERB) are more powerful versions of Rotoscale backgrounds.
If in 256-color mode, the ERB uses a palette.
</p>

<p>
ERB can be used as normal (non-extended) rotate-scale backgrounds, even with tiles, but with a full 1024-tile set in a full 256-color palette mode, whereas normal rotoscale backgrounds are limited to 256 tiles.
</p>


<h7>Text backgrounds</h7>

<p>
In a very similar way to palettized surfaces, that contain color index instead of pixels, some backgrounds can be <em>tiled</em> : instead of being a kind of array of pixels they are a kind of array of references to tiles, each tile being a fixed-size array of pixels (a rectangle 8 pixels wide and 8 pixels tall, i.e. 64 pixels). 
</p>

<p>
Thus a tiled background (also called a text background) is made of :
<ul>
        <li>a <b>tileset</b> : a collection of up to 1024 tiles. Each tile is identified by its index, which is its number in the set, ranging from 0 to 1023</li>
        <li>a <b>map</b>, which is mainly a 2D array, whose size is at least 32x32 (depending on the background setup), that specifies for each of its cells which tile from the tileset should be rendered (blitted). A tile entry occupies two bytes (16 bits) : the first ten encode the tile index (<code>2^10=1024</code>), and the 6 remaining bits records the tile attributes (more on that later)</li>
</ul>
So with text backgrounds you have nothing like an overall screen buffer that could be written at the pixel level : you just can manipulate tiles and maps, and it is the DS hardware that will read it to recompose the screen.
</p>

<p> 
The pixels of a tile are described as color index taken from a palette. As palettes here are a collection of either 256 colors or 16 sub-palettes of 16 colors each, there are two color modes for tiles in text backgrounds :
<ul>
        <li>a <b>256-color mode</b> (a.k.a. 8-bit color mode) :  a pixel is an index to the 256-color palette. The index is then an 8-bit integer, ranging for 0 to 255</li>
        <li>a <b>16-color mode</b> (a.k.a. 4-bit color mode) :  a pixel is an index to a 16-color palette. The index is then an 4-bit integer, ranging for 0 to 15. Less memory is required, thus making room for more tiles and other elements in VRAM, but with only 16 possible colors per tile the rendering quality of the result might be poor</li>
</ul>
</p>

<p>
The DS tiling engine is quite feature-rich : beyond displaying tiles as they are, it can flip them (horizontally and/or vertically), and use different palettes to render the same tile, for example for palette-based animation. These per-tile informations are stored in the aforementioned 6-bit attributes : one bit for each flip (on/off) and 4 bits to designate one of the 16 sub-palettes. 
</p>

<p>
In the VRAM (Video RAM) there are locations dedicated to the storage of map data, in <em>map bases</em> (2 Kbytes each), or tile data, in <em>tile bases</em> (16 Kbytes each, a.k.a. charblock). Map and tile bases share the same region in VRAM, whose layout must be carefully planned. Usually one counts in map base units, for example the size of a tile base is 8 map bases.
</p>

<p>
As each tile base occupies 16 Kbytes, in 256-color mode there can be no more than 256 tiles per tile base  (<code>16*1024/(64*1)</code>), whereas in 16-color mode there can be 512 tiles per tile base (<code>16*1024/(64*0.5)</code>).
</p>

<p>
The tileset of a given map can refer up to 1024 tiles : more than a tile base can be referred to by a map base. Therefore in 256-color mode, there can be up to 4 tile bases per map base (<code>1024/256</code>), whereas in 16-color mode there can be up to 2 tile bases per map base (<code>1024/512</code>).
</p>

<p>
Map bases always have 32×32 entries. To create bigger backgrounds (like 64×64), you need to use several map bases. More infos on <a href="http://www.coranac.com/tonc/text/regbg.htm" target="_blank">regular tiled backgrounds</a> can be found in TONC.
</p>


<h6>Framebuffer mode</h6>
<p>
The framebuffer mode, or bitmap mode, is the easiest to directly draw to, but the less powerful of all modes. A <em>framebuffer</em> is a mode where the screen is mapped directly to a portion of main memory. Pixel informations written to this memory area will immediately result in their appearing on the screen. If it remains quite simple, it does not offer the various useful features offered by other modes, such as sprites, scrollings, etc., not to mention 3D primitives : with the framebuffer only software rendering is performed. And only the main screen can use this framebuffer mode.
</p>

<p>
Hence a good practise is to prefer sprites and tiled backgrounds over bitmap modes, very few 2D games do not rely on the hardware acceleration.
</p>


<h6>Format conversions</h6>

<p>
Finally, the graphics to render are most of the time available first in general-purpose formats (png, jpeg, etc.). They have therefore to be converted into data that the DS may use natively, i.e. split into the appropriate palettes, tilesets, etc. This can be either precomputed (done at build time, once for all) or done at runtime, which may allow to benefit from the features of the general-purpose format, for example for compression.
</p>


<h7>Precomputed conversions</h7>

<p>
Tools include <a href="http://www.coranac.com/projects.php#grit" target="_blank">grit</a> (<em>GBA Raster Image Transmogrifier</em>, new name for git) and <a href="http://www.aaronrogers.com/ham/gfx2gba_readme.php" target="_blank">gfx2gba</a> which, when given a file in 16 or 256-color PCX, TGA, SPR, BMP or TIM formats (one may use The Gimp to preconvert PNG and JPEG files beforehand), can create a binary tileset (<code>*.raw</code>) with 8x8 tiles), a binary background map (<code>*.map</code>) and a 256-color palette file (<code>*.bin</code>) :
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
gfx2gba -c256 -m -t8 -pmyPalette.bin myImage.bmp
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
These converted graphics will then have to be <a href="#datastorage">stored</a> so that the DS application will find it. 
</p>


<h7>Runtime conversions</h7>

<p>
Tools include <a href="http://www.aaronrogers.com/ham/gfx2gba_readme.php" target="_blank">gba-jpeg</a>.
</p>

<p>
See also : <a href="http://liranuna.drunkencoders.com/nds-2d-tuts/" target="_blank">LiraNuna's 2D tutorial</a> and <a href="http://www.double.co.nz/nintendo_ds/nds_develop10.html" target="_blank">Chris Double tutorial #10</a> for more details. 
</p>


<h6>Sprites</h6>

<p>
Sprites are small (8x8 to 64x64 pixels) graphical objects that can be transformed independently from each other and can be used in conjunction with either bitmap or tiles background types (which are mutually exclusive). Like backgrounds, sprites are built out of tiles, but both have their own set of tiles. The tiles available for sprites are stored in object VRAM, or OVRAM for short.
</p>

<p>
To perform animations, one should better have its sprites refer to different tiles, rather than considering that a sprite owns the tiles it uses, and therefore updating these tiles.
</p>

<p>
OAM means <em>Object Attribute Memory</em>. This is where you control the sprites, which are managed by the DS hardware. At most 128 sprites are supported at a time. Each of them has three so-called attributes (hence OAM).
</p>

<p>
Generally speaking, the OAM is not directly read or written to, as during the VDraw this memory area is locked and cannot be accessed. This is less a limitation than a protection, as visual artefacts could be seen if the OAM was changed during screen update. Therefore programmers usually relies on OAM double buffering : they have their own shadow copy in RAM of the OAM attributes, they can modify it at any time (including Vdraw), and during Vblank they update the real OAM from their shadow copy.
</p>

<p>
Each sprite behaves a bit like a big tile : it has an identifier and some overall informations such as flipping flags and palette-info for 16-color sprites. It is nevertheless made from several real tiles, which can be stored in memory according to two <a href="http://www.coranac.com/tonc/text/regobj.htm#sec-tiles" target="_blank">conventions</a> : 1D mapping or 2D mapping.
</p>

<p>
To follow TONC naming conventions, each sprite is either regular (standard, basic) or affine (being able to be rotated, scaled, sheared).
</p>


<h7>Regular sprites</h7>
<p>
A regular sprite has several attributes that define its size, actual shape (depending both on the shape and size attributes), position (x,y of the top-left sprite corner in screen space), background priority (higher priorities are drawn first, hence are below smaller ones), flipping (horizontal and/or vertical), base tile, bit depth (palette range), activation (shown/hidden), alpha-blending status, mosaïc effect status, and more.
</p>


<h7>Affine sprites</h7>
<p>
Affine sprites are extended regular sprites. They have all regular attributes, and additional affine-specific informations. Each affine sprite is transformable : it has its own affine 2x2 transformation matrix, which defines how it should be rotated, scaled or sheared when being rendered. This matrix transforms points expressed in screen space into points in texture space, not the other way round. More infos about that can be read from <a href="http://www.coranac.com/tonc/text/affine.htm" target="_blank">TONC</a>.
</p>

<p>
More infos on <a href="http://www.coranac.com/tonc/text/video.htm#sec-vid-types" target="_blank">bitmaps, backgrounds and sprites</a>, coming from the GBA but mostly relevant for the DS as well.
</p>



<a name="3D"></a>
<h5>3D Rendering</h5>

<p>
The system's 3D hardware can perform a lot of operations :
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://en.wikipedia.org/wiki/Transform_and_lighting" target="_blank">transform and lighting</a> : performs 3D space to screen conversion, including lighting. Having it hardware accelerated frees the CPU from this computation-intensive task</li>
    <li>texture-coordinate transformation : so that textures (images used to wrap 3D shapes) can be used</li>
    <li><a href="http://en.wikipedia.org/wiki/Texture_mapping" target="_blank">texture mapping</a> : applies a texture to a shape</li>
    <li><a href="http://en.wikipedia.org/wiki/Alpha_blending" target="_blank">alpha blending</a> : combines an image with a background to create the appearance of partial transparency</li>
    <li><a href="http://en.wikipedia.org/wiki/Anti-aliasing" target="_blank">anti-aliasing</a> : minimizes the distortion artifacts due to on-screen rendering (enhances the resulting image)</li>
    <li><a href="" target="_blank">cel shading</a> : simulates hand-drawn ( like cartoon or comic books) computer-generated graphics</li>
    <li><a href="http://en.wikipedia.org/wiki/Z-buffering" target="_blank">z-buffering</a> : management of image depth coordinates, one of the solutions to the visibility problem</li>
</ul>
</p>

<p>
Character rendering might have a blocky appearance due to Point (nearest neighbor) texture filtering. 2D sub-pixel glyph rendering could be used though, as it is done with the TextViewer homebrew.
</p>

<p>
The DS can render at most about 2048 triangles per scene as 60 frames per second. Rendering can occur only to a single screen at a time, so having 3D on both screens decreases performance significantly. The DS is more limited by its polygon budget than by its pixel fill rate.
</p>

<p>
There are 512 kB of texture memory per screen, and the maximum texture size is 1024x1024 pixels.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="sound"></a>
<h4>Sound</h4>
<p>
Sound tends to consume a lot of CPU and RAM resources, hence the best is often to target first the hardware-supported features. 
</p>

<p>
Only the ARM7 can access the sound hardware, so we somehow have to have the ARM9 notify the ARM7 that it wants to play a sound. 
</p>

<h5>Sound output</h5>
<p>
Relying on the sound mixing hardware is the best bet : it can manage 16 channels with about 5% memory bandwidth usage. Therefore using MOD-like soundtracks is favored, even by commercial games.
</p>
 
<p>
With ogg/mp3 decoding, one would eat around 50% ARM9 or almost 100% of the ARM7 with a pretty low bitrate.
</p>

<p>
Sample data can be assigned independently to any of the 16 channels. For a given channel, the playback frequency of the sample (ex : 22 050 Hz), the sample size (ex : 8bit) and the sample data length can be set, among other informations (channel enabled or not, looping mode or one shot, etc.). Stereo sound can be output, with panning from left to right for example.
</p>

<p>
Sample data also need to be passed to the hardware in raw format, i.e. as a series of uncompressed samples without any header. This is not the case of the most usual formats (wav, mp3, OggVorbis, etc.), therefore they have to be converted one way or another (beforehand or by the program itself, at start-up or in-game) to the expected raw format. This can be done thanks to the <a href="http://sox.sourceforge.net/" target="_blank">sox</a> tool, or thanks to the <code>wav2gba</code> tool. More info about the conversion can be found <a href="http://www.double.co.nz/nintendo_ds/nds_develop4.html" target="_blank">here</a>.
</p>

<p>
Sound output requires sound to play, see our <a href="#datastorage">data storage</a> section explaining how to access the resources needing by your application.
</p>

<a name="soundinput"></a>
<h5>Sound input</h5>

<p>
Once the amplifier has been powered on, the DS microphone is accessed through the <em>Serial Peripheral Interface</em> (SPI) on the ARM7, in a very similar way to the touchscreen is read. However helper libraries hide this inner working under higher level interfaces.
</p>

<p>
The built-in microphone can be used to perform some limited speech-recognition, as it is done in a few games.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="datastorage"></a>
<h4>Data storage &amp; application ressources</h4>

<h5>Linking the data directly in a ARM executable</h5>
<p>
This is the simplest method, but it provides only limited space, as the whole ROM (including the data) will have to fit in the 4MB of built-in RAM and as the executables for each ARM must be under specific thresholds (64 kB for the ARM7). Only read-only access to the data will be possible.
</p>

<p>
The data has to be converted to an object file (*.o) thanks to objcopy (actually <code>arm-eabi-objcopy</code>) before being linked with the other object files in the the executable that will need them, thanks to the linker (actually <code>arm-eabi-g++</code>). For sounds it will be likely by the ARM7, the only one able to access the sound hardware, in the unlikely case where the only 64 kB permitted are enough. Otherwise the data can be linked to the ARM9 executable. More info about the data embedding in executables can be found <a href="http://www.double.co.nz/nintendo_ds/nds_develop4.html" target="_blank">here</a>.
</p>


<h5>Using the non-volatile RAM available in slot-2 cartridges</h5>

<p>
Gameboy Advance cartridges (slot-2) have a 64 kB place where data can be stored and retrieved, notably for game save. DS can use it, including in order to feed a program with data from the slot 2. 
</p>

<p>
This area is called SRAM, but it should be understood as Save RAM, and not the usual <a href="http://en.wikipedia.org/wiki/Static_random_access_memory" target="_blank">Static RAM</a> : it is non-volatile memory, its data will be kept even if the DS is switched off.
</p>

<p>
The GBA cartridge memory must be mapped to either the ARM7 or the ARM9 (then wait a few millisecond before accessing it). Before writing to it, the cartridge ID should be checked to ensure there is a cartridge indeed and that the homebrew (maybe downloaded by Wifime) will not write over a commercial cartridge. It is done by reading 4 bytes from a given address in ROM space and by <a href="http://www.double.co.nz/nintendo_ds/nds_develop5.html" target="_blank">checking</a> whether the four bytes form the string <code>PASS</code>.
</p>

<p>
All reads and writes to the SRAM must be 8 bits at a time (neither 16 nor 32-bit). These accesses can be performed anywhere in the SRAM memory space, and do not have to follow any specific rule. Therefore anything can be stored here : texts, images, sounds, etc. A good practise is to write at the beginning of this memory a small header that helps identifying the structure of the data being stored.
</p>

<p>
Some flash cartridges have more than one SRAM space, but apparently only one of them can be easily accessed.
</p>

<p>
More info about reading from SRAM can be found <a href="http://www.double.co.nz/nintendo_ds/nds_develop5.html" target="_blank">here</a>.
</p>


<h5>Reading the data from a filesystem</h5>
<p>
Instead of decreasing the available RAM by adding data to executables, one may access selectively the cartridge, as a filesystem, and retrieve only the chunks of chosen files taken from a directory tree.
</p>

<p>
With that method you can organize your data in as many files as you wish, and more important you are only limited by the size of the game cartridge, which is huge (up to 2 GB and more) compared to the other traditional storage locations in the DS. The main drawback is that it implies a cartridge must be used and your program must be stored on it. This method will not work for Wifi-downloadable applications.
</p>


<h6>Choosing a filesystem</h6>
<p>
The <a href="#romformats">.nds</a> ROM format and others offer space for a filesystem., and a buit-in filesystem too. The <em>ndstool</em> program can be used to add and remove files from it. Unfortunately there are no homebrew libraries available yet that allow reading this filesystem from the DS hardware.
</p>

<p>
Fortunately several other filesystems can be used, including the ancestor GBFS (<em>Gameboy Advance Filesystem</em>) and its successor, and now recommended, <code>libfat</code>, a library to manage (read/write/list) the FAT16 filesystem. It features better reentrancy support, cleaner source code, is built as a proper library and packaged as part of <a href="#devkitARM">devkitPro</a>.
</p>


<h6>Using a filesystem</h6>
<p>
The method to use most filesystems is quite simple : one gathers first, on a PC, all the files to be stored on the ROM filesystem, sorted according to the target directory structure. 
</p>

<p>
Then a tool is used to create a single file that contains the filesystem (including these files). That file is then simply appended to the program binary. In some cases the program binary must be padded to a 256 byte boundary beforehand, thanks to the  <code>padbin</code> tool, ex : <code>padbin 256 MyProgramBinary.nds</code>. Then the filesystem can be simply appended, ex : <code>cat MyProgramBinary.nds MyFileSystem.fat &gt; MyProgram.nds</code>.
</p>

<p>
Finally the DS program have to use filesystem-specific code to manipulate its own ROM-embedded filesystem. It requires including the corresponding headers (ex : <code>#include &lt;fat.h&gt;</code>), initializing the filesystem support (ex : <code>fatInitDefault()</code>), and using the provided primitives to manipulate files (ex : <code>fopen</code>, <code>fread</code>, etc. like in POSIX systems) and directories (ex : <code>diropen</code>, <code>dirnext</code>, etc. here in a libfat-specific way).  
</p>

<p>
Note that with libfat both slot-1 and slot-2 memory can be accessed, and simultaneously. More info about the recommended lifat can be found <a href="http://chishm.drunkencoders.com/libfat/" target="_blank">here</a>.
</p>

<p>
More info about the mostly deprecated GBFS can be found <a href="http://www.double.co.nz/nintendo_ds/nds_develop6.html" target="_blank">here</a>.
</p>

<p>
More info on embedded <a href="http://www.coranac.com/tonc/text/bitmaps.htm#sec-data" target="_blank">external data</a> (written for GBA but applies to the DS too).
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="inputdevice"></a>
<h4>Input device management</h4>

<a name="keys"></a>
<h5>Keys</h5>

<p>
For all keys (or buttons) except X and Y, there is a read-only hardware register that can be read by either of the ARM to tell whether they are pressed or released. As for the X and Y keys, their state is available thanks to another register that can only be read from the ARM7.
</p>

<p>
For the ARM9 to have these last two keys, the ARM7 can read their state during the VBI and send them to the ARM9 thanks to the IPC structure. Two non-key informations can be transmitted that way too : the hinge state (open or closed) and  the stylus state (down or up , i.e. whether it is on the touchscreen or not).
</p>

<p>
Note that the key state is read 60 times per second. It implies that if a key was pressed and released fast enough (it would be quite difficult though), it would not be detected. Another method, more robust, is event-based : each keypress can be detected thanks to a specific interrupt. Then no key change can be lost.
</p>

<p>
On the contrary, most user keypresses last for more than a VBI period (16 ms). Such a keypress should not be interpreted as multiple keypresses though, even if multiple iterations of the main loop in a row saw that key pressed. 
</p>

<p>
For example, if a key is used to pause/unpause a game, the user would press it once, but the program would interpret it as a series of pause and unpause requests, whose length would be random, depending how many VBI were elapsed. 
</p>

<p>
Actually current key state is far less interesting than key transition : even if knowing that a key is pressed might be useful, knowing that this key just went from the released state to the pressed state (or the opposite) is still more useful. libnds allows that thanks to the <code>scanKeys</code>, <code>keysHeld</code>, <code>keysDown</code>, etc. primitives. 
</p>

<p>
 PAlib offers abstractions to read easily the key states, hiding the VBI interrupt, the ARM7/ARM9 IPC communication and the different bit set conventions, and offering transitional reads. 
</p>


<h5>Touchscreen</h5>
<p>

</p>

<h5>Microphone</h5>
<p>
The built-in <a href="#soundinput">microphone</a> can be used to perform some limited speech-recognition, or to detect the user blowing air, shouting at it, etc..
</p>



<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>

<a name="wireless"></a>
<h4>Wireless networking</h4>
<p>
The built-in Wifi support allows the DS to communicate (with a theoretical bandwith of 1-2 Mbit per second) :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li>with a <b>standard access point</b> (i.e. public non-<a href="http://en.wikipedia.org/wiki/Captive_portal" target="_blank">captive portal</a> hotspots or a personal 802.11b or 802.11g wireless routers) to access the Internet. The DS supports <a href="http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy" target="_blank">WEP</a>
 encryption but not <a href="http://en.wikipedia.org/wiki/Wi-Fi_Protected_Access" target="_blank">WPA</a></li>
 
	<li>with <b>other DS</b> in the vicinity, through <a href="http://en.wikipedia.org/wiki/NiFi" target="_blank">Nifi</a>, a modified WiFi protocol created by Nintendo for the DS and the Wii, partially secured using RSA security signing. It is used in non-online multiplayer mode, and to download game demos or multiplayer game software</li>
	
</ul>

</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="miscellaneous"></a>
<h4>Miscellaneous informations</h4>

<p>
Most of these informations come from the listed <a href="#detailedhardware">hardware resources</a>.
</p>

<h5>Game Logic</h5>
<p>
We saw in the <a href="#rendering">rendering section</a> that screen updates are in most cases hard-realtime synchronized. For the overall game logic as well, a simple infinite <code>while()</code> loop in the <code>main()</code> function would not be very convenient, as either it would run at a random pace (depending on the amount of tasks to be performed on each iteration), or it would require to monitor the time interval between two iterations and to compute accordingly the behaviour of each simulated game actor. You then enter the realm of equation robustness against too high timesteps, etc.
</p>

<p>
These are real issues in the PC world where no two hardware platforms behave the same and where uncoupling all subtasks (audio/video rendering, AI, input reading, network management, etc.) becomes soon a nightmare, but in the console world the situation is somewhat simpler : everything ought to be hardwired and paced according to the same clock, here the 60 Hz rhythm provided by the VBI. 
</p>

<p>
Instead of putting that logic code is the VBI handler, the best way is to keep the <code>while()</code> loop in the <code>main()</code> function, but to make each iteration end with a request for the DS to sleep until next interrupt occurs (with libnds one would use <code>swiWaitForVBlank()</code>). Therefore both rendering and logic will run at a predictable 60 Hz, and thanks to the sleeps the DS will exhaust its batteries later.
</p>


<h5>MMU</h5>
<p>
The DS does not have a Memory Management Unit (<a href="http://en.wikipedia.org/wiki/Memory_management_unit" target="_blank">MMU</a>), a hardware component responsible for handling memory accesses requested by the CPU, notably to enable virtual memory management, memory protection, cache control, bus arbitration or bank switching.
</p>

<p>
It reduces the potential stability of operating systems (as Linux; if they are to be used on a DS), and prevents to access through swap to memory that would be available in Slot-2-provided removable media. 
</p>


<h5>Non rendering-related hardware accelerations</h5>
<p>
The DS contains both divide and square root accelerators.
</p>


<h5>16/32 bit</h5>
<p>
The ARM7 processor supports both 32-bit and 16-bit instructions via respectively the ARM and Thumb instruction sets (the later is a subset of the former). 16-bit code is smaller than 32-bit one and, in some specific cases, faster (usually slower though). 16-bit code is often preferred, as it has more chances to fit in the tiny instruction caches. Moreover the size of ARM7 code must be 64 kB or smaller.
</p>

<p>
The ARM9 is a full 32-bit CPU, but may be programmed in 16-bit too.
</p>

<p>
An important developing rule is to prefer using the <code>CPU native words</code> (16-bit datatype if the CPU is in 16-bit mode, 32-bit datatype if the CPU is in 32-bit mode) for most of your calculations, loop index, etc. : then the bus, the CPU registers and the instruction set will be "inline", as efficient as obtainable, whereas smaller datatypes would lead to runtime performance penalties. Unless they are packed in a structure, they will not be any smaller. Using such words only requires careful casting, because the ARM CPU are quite picky about memory alignment.
</p>



<h5>Power management</h5>
<p>
Various subsystems (power management, firmware, touchscreen, sound volume and control, microphone amplifier control and gain control, back-lighting of screens, power LED, battery status) can be accessed only thanks to the SPI (<em>Serial Peripheral Interface</em>) bus.
</p>

<h5>DMA</h5>

<p>
A <a href="http://en.wikipedia.org/wiki/Direct_memory_access" target="_blank">DMA</a> (<em>Direct Memory Access</em>) copy is basically a fast, CPU efficient, hardware accelerated copy : it allows certain hardware subsystems within the DS to access system memory for reading and/or writing independently of the CPU.
</p>

<p>
There are four prioritized DMA channels. They can transfer data asynchronously from the main CPU : the ARM9 initiates the transfer and, if it does not access to main memory, can continue its work while the DMA transfer is going on. Then it will receive an interrupt from the DMA controller once the operation has been done. It results in data transfer with much less CPU overhead. Note though that during a DMA transfer the CPU is locked off the bus, thus restraining a lot what it can done in the mean time.
</p>


<a name="timers"></a>
<h5>Timers</h5>
<p>
A timer is a hardware function that can be set to raise an interrupt at regular intervals, once enabled. There are eight incrementing 16bit timers, four for each CPU.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>





<a name="otherinfos"></a>
<h2>Some other information sources</h2>



<!-- ########################################################################-->
<a name="tutorials"></a> 
<h3>Tutorials</h3>
<p>
<ul>

<!--
    <li>[T] <a href="" target="_blank"></a></li>
-->

    <li>[T1] <a href="http://www.double.co.nz/nintendo_ds/" target="_blank">Double</a> : interesting, well explained but often deprecated</li>
	
    <li>[T2] <a href="http://www.dev-scene.com/NDS/Tutorials" target="_blank">Devoto</a>'s tutorial : a really good one</li>
	
    <li>[T3] <a href="http://www.playeradvance.org/forum/showthread.php?t=4277" target="_blank">PAlib for Linux</a> (1/2)</li>
	
    <li>[T4] <a href="http://www.palib.info/wiki/doku.php" target="_blank">PAlib for Linux</a> (2/2)</li>
	
    <li>[T5] <a href="http://www.coranac.com/tonc/text/" target="_blank">TONC</a> : lots of GBA informations, most of which still applies to the DS</li>
	
    <li>[T6] <a href="http://www.patatersoft.info/manual_online.html" target="_blank">Patatersoft</a></li>
	
    <li>[T7] <a href="http://www.drunkencoders.com/index.php?system_id=1&page=Tutorials" target="_blank">drunkencoders</a> tutorials</li>

    <li>[T8] <a href="http://scorpei.com/TBGTDSHB/The_Beginners_Guide_To_NDS_Homebrew.pdf" target="_blank">Running Nintendo DS homebrew</a> [PDF], by Simon van de Berg. Helps to understand and choose linkers</li>
	
</ul>

</p>


<!-- ########################################################################-->
<a name="forums"></a> 
<h3>Forums</h3>
<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://forum.gbadev.org/viewforum.php?f=18" target="_blank">gbadev forums</a></li>

    <li><a href="http://forums.abxy.org/f/nintendo-ds" target="_blank">abxy DS forums</a></li>
	
</ul>

</p>


<!-- ########################################################################-->
<a name="irc"></a> 
<h3>IRC channels</h3>
<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="irc://irc.blitzed.org" target="_blank">Dev-Scene IRC</a> (channel : #dsdev)</li>

    <li><a href="irc://irc.freenode.net" target="_blank">DSLinux IRC</a> (channel : #DSLinux)</li>
	
</ul>

</p>


<!-- ########################################################################-->
<a name="applications"></a>
<h3>Homebrew applications &amp; games</h3>

<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

	 <li><a href="http://scummvm.drunkencoders.com/" target="_blank">ScummVM DS</a></li>
	 
    <li><a href="http://www.mrdictionary.net/lemmings/" target="_blank">Lemmings DS</a></li>

    <li><a href="http://mdxonline.dyndns.org/archives/nds/" target="_blank">Moonshell</a></li>

    <li><a href="http://www.dragonminded.com/?loc=ndsdev/DSOrganize" target="_blank">DSOrganize</a>, transform your DS into a PDA</li>

<!-- Apparently a piracy-related site ?
    <li><a href="http://www.nintendo-ds-roms.com/" target="_blank">DS ROMs</a></li>
-->
	
</ul>

</p>


<!-- ########################################################################-->
<a name="otherlinks"></a>
<h3>Some interesting links</h3>
<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->
    <li><a href="http://en.wikipedia.org/wiki/Nintendo_DS_homebrew" target="_blank">Nintendo DS</a> on Wikipedia</li>
	
    <li><a href="http://en.wikipedia.org/wiki/Nintendo_DS_booting_tools" target="_blank">DS booting tools</a> on Wikipedia</li>
	
    <li><a href="http://forum.gbadev.org/viewtopic.php?t=8353" target="_blank">Link repository from gbadev</a></li>

    <li><a href="http://www.ndshb.com/modules.php?name=Content&pa=showpage&pid=27" target="_blank">Extension for DS ROMs explained</a> (twice)</li>
	
    <li><a href="http://www.dev-scene.com" target="_blank">Dev-Scene</a></li>
	
    <li><a href="http://www.aaronrogers.com/nintendods/" target="_blank">Aaron Rogers</a></li>
	
    <li><a href="http://www.drunkencoders.com" target="_blank">Drunk Encoders</a></li>
	
    <li><a href="http://nintendo-ds.dcemu.co.uk/" target="_blank">DS News</a></li>

	<li><a href="http://www.nintendods.com/" target="_blank">Nintendo official website</a></li>


    <li><a href="http://www.warioworld.com/" target="_blank">WarioWorld</a>, software development support group (for professionals, authorized Nintendo developers and licensees). Nintendo only accepts official companies with a game development team, and sufficient experience in certain areas for their official developer support program. Small structures are expected to find a "Nintendo-certified" publisher prior to submit their games</li>

    <li><a href="http://tobw.net/dswiki" target="_blank">DS Developing Wiki</a></li>

    <li>Resources in French :
	<ul>

<!--
    	<li><a href="" target="_blank"></a></li>
-->

    	<li><a href="http://www.gamebe.com/articles/lire/4/nintendo-ds-r-evolution/" target="_blank">Présentation de la DS</a></li>

    	<li><a href="http://www.portabledev.com/pages/ds/tutoriels/tutos.-chris-double" target="_blank">Traduction des tutoriels de Chris Double</a> </li>
	
    	<li>Les <a href="http://mobiles.gx-mod.com/modules/tutos/index.php?id=37" target="_blank">linkers pour DS</a></li>
		
    	<li><a href="http://www.playeradvance.org/forum/showthread.php?t=4277" target="_blank">Installation de PALib sous Linux</a></li>
	
    	<li>Présentation de <a href="http://playeradvance.org/forum/showthread.php?t=5340" target="_blank">Moonshell</a>, <a href="http://www.supercard-france.info/index.php?option=com_content&task=view&id=19&Itemid=78" target="_blank">installation</a> (sous Windows)</li>

    	<li>Informations sur la <a href="http://www.supercard-france.info/" target="_blank">SuperCard</a>, notamment pour <a href="http://www.supercard-france.info/index.php?option=com_content&task=view&id=29&Itemid=141" target="_blank">la mettre à jour</a></li>
	</ul>
	</li>

		
</ul>

 
 </p>

<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>
  <br>
  <br>
  <br>
  <br>

 <h3>Please react !</h3>

  <p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, <a href="mailto:toshiba.laptop@esperide.com?subject=[OSDL]%20Homebrew%20for%20Nintendo%20DS">drop us a line</a>!</p><br>
  <br>
  <hr>
  <br>
 
  <center>
    [<a href="#_top_">Top</a>]
	<br>
    <br>
    <em>Last update : Saturday, June 23, 2007</em>
  </center>
</body>
</html>
