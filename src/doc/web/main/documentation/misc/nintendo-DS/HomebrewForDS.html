<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">

<!--    Ce document fait partie du projet OSDL.
		Pour toute remarque, envoyer un courriel à toshiba.laptop@esperide.com
-->
<!--    
        Date de création : Saturday, June 2, 2007.
        Auteur : Olivier Boudeville (toshiba.laptop@esperide.com)
        Version : 0.1
-->

<html lang="EN">
<head>
  <title>OSDL - A guide to homebrew development for the Nintendo DS</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="description" content="OSDL">
  <meta name="keywords" content="OSDL, installation, laptop, multiboot">
  <link rel="stylesheet" type="text/css" href="../../../../common/css/OSDL.css">
  <link href="../../../../images/OSDL-icon.png" rel="OSDL icon">
</head>

<body>
  
  <div class="banner">
  
    <p><em>General</em> <a href="../../../../common/black.html" onclick="parent.toolbar.location='../../MainMenu.html'">home page</a>
    <a href="../../../../Map.html">site map</a> <a href="mailto:homebrew@esperide.com?subject=[OSDL]%20Homebrew%20for%20Nintendo%20DS">mail us</a></p>
	
  </div><a name="_top_"></a>
  

<h1>A guide to homebrew development for the Nintendo DS</h1>


<a name="toc">
<center>
	<table summary="Table of content" style="border: none">
        <tr>
          <td>
		<!--
		       <a href="#"></a><br>
		-->

		   <div class="box">
		       <a href="#overview">Overview</a><br>
		       <a href="#tobuy">What should be bought</a><br>
			   <ul>

		<!--
			<li><b></b> : </li>
		-->

					<li>A <a href="#buytheconsole">console</a></li>
					<li>Some recommended <a href="#accessories">accessories</a></li>
					<li>Required <a href="#addons">add-ons</a></li>
					
				</ul>
		       <a href="#inaction">The console in action, with and without its add-ons</a><br>
			   
		       <a href="#hardware">Hardware resources</a><br>
			   <ul>	   
					<li>The console <a href="#innerconsole">inner workings</a></li>
					<li>The <a href="#cartridges">cartridges</a></li>
				</ul>	
					   
		       <a href="#thirdparty">Using some third-party software</a><br>
			   <ul>
					<li>Understanding the various <a href="#romformats">ROM formats</a></li>
					<li><a href="#linkerstorage">Linker storage &amp; DLDI</a></li>
					<li>An example : <a href="#linuxonds">Linux on DS</a>
				</ul>		   
			   
		       <a href="#programmingDS">Programming the DS</a><br>
			   <ul>
			   		<li>Gathering the <a href="#tools">adequate tools</a> for homebrew</li> 
					<ul>
						<li>the compiler toolchain, with <a href="#devkitarm">devkitARM</a>
						<li>the low-level library, <a href="#libnds">libnds</a>
						<li>a FAT library, <a href="#libfat">libfat</a> 
						<li>a library to manage Wifi, <a href="#dswifi">dswifi</a> 
						<li>an (optional) higher level library, <a href="#palib">PAlib</a></li>
					</ul>
						
			   		<li><a href="#building">Building</a> your first DS program</li>
					<li><a href="#testing">Testing</a> your first DS program</li>

					<li> <a href="#usinghardware">Using effectively the hardware</a><br>
			   		  <ul>
						<li><a href="#twocpu">Two</a> general-purpose CPU to handle</li>					
						<li>Activating only the relevant <a href="#subsystems">subsystems</a></li>			
						<li>2D/3D <a href="#rendering">Rendering</a></li>		
						<li><a href="#wireless">Wireless</a> networking</li>	
						<li><a href="#miscellaneous">Miscellaneous</a></li>
					  </ul>	
					</li>
							   
			   </ul>		   
			   
		       <a href="#otherinfos">Some other information sources</a><br>

          </div>

          </td>
        </tr>
      </table>
</center>
<!--
<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>
  -->

  
<a name="overview"></a>
<h2>Overview</h2>

<p>
The goal here is to develop applications, mostly games, to be run on the <a href="http://en.wikipedia.org/wiki/Nintendo_DS" target="_blank">Nintendo DS</a>, from the hobbyist point of view, as opposed to a software/game production company. This kind of developments is called <a href="http://en.wikipedia.org/wiki/Homebrew_(video_games)" target="_blank">homebrew</a>. We do not support piracy or the illegal use of the copyrighted Nintendo SDK by non-licensed developers. We use here unofficial development kits, such as <a href="http://www.devkitpro.org/" target="_blank">devkitPro</a>. These coding efforts are to remain free and legal.
</p>

<p>
Portable development will be kept in mind, as having one's game working both on a DS and on a PC is quite enjoyable. In this guide the C/C++ language will be favored. The development platform will be a standard PC, preferably using GNU/Linux.
</p>

<p>
Most of the informations here came from homebrew websites and IRC discussions, many thanks to the fearless homebrewers !
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="tobuy"></a> 
<h2>What should be bought</h2>


<a name="buytheconsole"></a> 
<h3>The console</h3>

<p>
First of course is the Nintendo DS itself (see a video <a href="http://www.youtube.com/watch?v=Xp7Be1qsblI" target="_blank">presentation</a>). It should be a DS <a href="http://en.wikipedia.org/wiki/Nintendo_DS_Lite" target="_blank">Lite</a>, which is quite superior to the previous "<a href="http://en.wikipedia.org/wiki/Nintendo_DS" target="_blank">fat</a>" version : better screens, thiner, lighter, better autonomy, more beautiful, etc. The color does not matter, but the black version is quite sober, which opens it the possibility of somewhat faking a classical PDA. This is one of the intended uses in my case, besides game programming.
</p>

<p>
The main competitor for the DS would be Sony's PlayStation Portable, PSP, although they are quite different in price, capabilities and market shares. The lack of input device other than the gamepad, the quite low autonomy, the price and Sony policies make a lot of people favour DS over PSP, at least for the intended usage (PDA and homebrew).
</p>

<p>
As most console manufacturers enforce a unique pricing for all vendors, choose the one with the better conditions (guarantee, return policy, etc.), preferably not online : dealing with real shops is convenient, especially to have its DS replaced whenever there are dead pixels. This happens quite often apparently, and not all vendors accept easily to replace it. 
</p>

<p>
As for me, I bought my DS Lite in France, in a FNAC shop (I could cancel my buying during a 15-day period), in may 2007, for 150 euros, and had no dead pixel.
</p>

<p>
Here is the content of the Nintendo box :
<center>
    <a href="content.jpeg" target="_blank"><img src="content-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>

</p>

<p>This box includes only :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li>the <b>DS Lite</b></li>
	<li>the <b>power supply</b> to charge the batteries</li>
	<li>some (rather useless) <b>documentation</b></li>
</ul>
</p>

<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>




<a name="accessories"></a>
<h3>Some recommended accessories</h3>

<p>
You can make a better use of your DS potential thanks to them.
</p>

<center>
    <a href="accessories.jpeg" target="_blank"><img src="accessories-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>
</p>

<p>
From the most useful to the least :

<ul>

<!--
	<li><b></b> : </li>
-->

	<li><b>screen protectors</b>, necessary at least for the touch screen, whose life duration would be quite low otherwise (note : beware to the way they should be applied, I screwed up the first protection, and the second, for the touch screen, trapped nasty micro-bubbles of air; no, the screens do not have the same exact dimensions !). A kind of fabric could help cleaning the screens and the console itself : finger prints are quite visible on it, especially on the black DS</li>
	
	<li>a <b>case</b> for transporting safely your DS. Mine is in leather on purpose : wanting to look like a casual PDA</li>
	
	<li><b>replacement stylus</b>, in case you loose the only one provided (the smaller ones are for the "fat" DS)</li>

	<li><b>car power supply</b> : well, why not...</li>

	<li>specific <b>headphones</b> are quite useless, as the DS uses standard 3.5 jack. Would be interesting only if they included a microphone (seems to be a proprietary plug for audio input)</li>

	<li><b>game stylus</b>, to be placed on the user thumb. Not helpful here, for mostly non-gaming usage</li>
	
	<li><b>boxes for game cartridges</b>. I bought the DS only to program it, I do not plan to buy any game (hope you do not sell the DS at loss, Nintendo : the razor and blades business model won't work for homebrewers)</li>

</ul>

</p>

<p>
I bought a Bigben Interactive pack of 5 accessories (6 euros) and a (black) Subsonic Premium Pack (mostly for the leather case; 15 euros), both of course for DS Lite. Hence one can have all these recommended accessories for quite a low price.
</p>

<p>
See also the Wikipedia <a href="http://en.wikipedia.org/wiki/Nintendo_DS_accessories" target="_blank">article</a> about DS accessories.
</p>

<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>



<a name="addons"></a>
<h3>The add-ons for homebrew development</h3>

<h4>Needing a console that can be programmed</h4>
<p>
Having a basic console is not enough to be able to program it : Nintendo, due to the fear of piracy, preferred to make the life of homebrewers more difficult than technically needed, notably thanks to hardened firmwares preventing modifications or execution of non-acknowledged code : apparently they are encrypted with a private key from Nintendo, the device uses the embedded public one to decipher the firmware before running it.
</p>

<p>
Hence, to have access to a DS that can be programmed, one has to circumvent these protections. One of the simplest ways of doing so is to use special game-like cards, at least once. This is a vast subject and many cases have to be taken into account, see <a href="http://en.wikipedia.org/wiki/Nintendo_DS_booting_tools" target="_blank">Booting Tools</a> on Wikipedia for details.
</p>
  
  
<h4>A rather cheap and easy solution</h4>

<p>
Since the DS is not sold with a rewritable storage medium, some storage device is required to store homebrew. Though one could instead use <a href="http://en.wikipedia.org/wiki/Wireless_Multiboot" target="_blank">WMB</a> (<em>Wireless Multiboot</em>), which is a method to send programs to be run on the DS using a PC with specific Wi-Fi adaptors, but it would not be convenient enough : transferred content would be lost on DS power-off, a Ralink-compatible Wifi adaptor would be required, the sent applications could not occupy more than 4 MB, a hacked firmware would be needed, etc.
</p>

<p>
As for me, I intended to have Linux working on my DS, and for that the native 4 MB of RAM where quite small, so I wanted to have both 32 MB of additional RAM (the maximum size that can be addressed by the DS bus) and access to <a href="http://en.wikipedia.org/wiki/Nintendo_DS_storage_devices" target="_blank">mass storage</a> on removable media. 
</p>

<p>
The best and simplest bet was to use in the slot-1 (the DS-specific one, small and at the top of the console, a.k.a the DS card) a <a href="http://eng.supercard.cn/products.htm" target="_blank">SuperKey</a> (a kind of <a href="http://en.wikipedia.org/wiki/NoPass" target="_blank">NoPass</a>) as a fake game used to enable the execution of code from the slot-2 (the big one at the bottom, used for GBA compatiblity, a.k.a the GBA cartridge). This slot-2 would host a <a href="http://eng.supercard.cn/products.htm" target="_blank">SuperCard Lite</a> (note : avoid the rumble series, it does not provide more RAM), which indeed, besides the 32 MB of RAM, offers a <b>micro-SD</b> port.</p>

<p>
I bought both the SuperKey and the SuperCard Lite (black version) from <a href="http://www.fl-games.com/" target="_blank">FL-games</a> for 65 euros (shipping included) and was quite happy of it (no compatibility issue between the two cards to be afraid of).
</p>

<p>
Here are the three boxes : the Nintendo DS Lite one, the SuperKey and the SuperCard. Note the two-euro coin : there are quite small indeed.

<center>
    <a href="boxes.jpeg" target="_blank"><img src="boxes-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>
</p>
 
<p>
Here is a view of a bare DS running the default firmware (hence the mandatory health and safety warning) and, below, the quite tiny SuperKey and SuperCarde Lite themselves :

<center>
    <a href="warning.jpeg" target="_blank"><img src="warning-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>
</p>

 
<p>
Last be not least, one should have at least one micro-SD card, I bought a 2 GB Kingston one from <a href="http://www.pc-look.com/" target="_blank">PC-look</a> for 28 euros, shipping included. My laptop had a SD reader/writer (well, Ubuntu could not use it properly but it is another story), so no real need to buy anything else. Separate USB reader/writer are quite inexpensive anyway. Check that your micro-SD card is sold with a SD adapter, so that the actual tiny micro-card can fit in a basic SD reader. 
</p>

<p>
To use your micro-SD, you should first format it in <b>FAT</b> (i.e. FAT16, not FAT32), as factory settings are not reliable in all cases, or not the expected ones. Formatting can be done both from Windows or from Linux.
</p>

<p>
FAT is for the moment favored over other filesystems by most homebrewers, mainly because it is adequate for small size storage media, and for the sake of simplicity : there already exists a library for it on the DS, <a href="http://chishm.drunkencoders.com/libfat/" target="_blank">libfat</a>.
</p>

<p>
Finally in my case the full equipment cost only 265 euros.
</p>

<a name="limitations"></a>
<h4>Some limitations for the seasoned homebrewer though : transferring files to the DS</h4>

<p>
Such removable media (as microSD) are not the magic bullet for the frantic homebrewer : to anticipate a bit on further subjects, when generating programs for the DS from your PC, to test them you may either execute them "in place", directly on your PC thanks to <a href="#emulators" target="_blank">DS emulators</a> (but they do not behave always as a DS would behave) or you have to send them to the DS by one way or another. This can be done thanks to the aforementioned microSD card, but it soon becomes tedious to swap again and again the card and its adapter. 
</p>

<p>
An alternate way would be to use a Wifi access point or a Wifi router, preferably not a mere Wifi adapter, which would have to embed a specific chip etc. in order to work with the DS. Such devices could be for example the famous <a href="http://en.wikipedia.org/wiki/WRT54G" target="_blank">Linksys WRT54G routers</a> (55 euros approximately) or <a href="http://en.wikipedia.org/wiki/Fonera" target="_blank">La Fonera</a>, both of which are inexpensive and, on a side node, run Linux, whose firmware and software can be programmed, etc., in a very similar way to the one we are to program applications for the DS.
</p>

<p>
Other still less usual methods would be :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li>a <b>parallel-port cable</b> :  you can open your DS, solder about 10 points to the motherboard, and get a parallel-port cable. But that's quite a lot of work</li>

	<li>the <a href="http://natrium42.com/blog/?p=38" target="_blank">dserial</a> ($45+shipping)</li>

	<li>the <b>Ds Xtreme</b>, if available. It is quite expensive though</li>
	
</ul>


<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>


 
<a name="inaction"></a>
<h2>The console in action, with and without its add-ons</h2>

<p>
The snapshot below shows the official main screen :  
<center>
    <a href="pictochat.jpeg" target="_blank"><img src="pictochat-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>
</p>

<p>
What happens when the cards are inserted ? Both ought to be used : if only the slot-1 one (SuperKey) is inserted, you will have two white screens, and if only the slot-2 one (SuperCard) is active, then your DS will run in backward compatibility mode for the GBA. 
</p>

<p>
When both cards are inserted, you can see the SuperCard splash screen, but here one could not go further, as the microSD card was not inserted. See it in its case, on the right, the SD adapter being on the left. The SuperCard-like black object below the DS is just the default plastic filler to protect the console from dust.
<center>
    <a href="supercard-run.jpeg" target="_blank"><img src="supercard-run-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>
</p>

<p>
Inserting the microSD card and rebooting is not really interesting, as this card  is still empty.
</p>

<p>
We see nevertheless that our customized console works well and is ready to be used.
</p>

 <p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>

 
 
 
 
<a name="hardware"></a> 
<h2>Hardware resources</h2>

<p>
Buying things was quite easy. Now, let's try to use them ! First of all, let's learn what is available for our developments.
</p>


<a name="innerconsole"></a>
<h3>The console inner workings</h3>
<p>
Even though Nintendo designed a low-cost handheld, the DS offers quite a lot of features :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li><b>two TFT back-lighted screens</b> (hence the DS meaning <em>Dual Screen</em>, although <em>Developer System</em> is mentioned sometimes), whose maximal resolution is 256x192, with up to 260 000 colors (5 bit for each channel). These are 3-inch screens (61x46 mm), with a dot pitch of 0,24 mm (contrast is 162:1). Screens are separated by about 21 mm. The DS Lite ones are far brighter and more resitant than the DS "fat" ones, and support four levels of brightness</li>
	
	<li>a resistive <b>touchpad</b> integrated with the bottom screen. The resulting touchscreen can be used with a stylus, the user's finger, wrist strap, etc. It can measure at most one press at a time, so it will average multiple presses, by reporting only a single one at their barycenter</li>
	
	<li>
	<p>

	<b>two all-purpose processors (CPU)</b> :
	  <ul>
		<li>an <b>ARM9</b> : <a href="http://en.wikipedia.org/wiki/ARM9E" target="_blank">ARM946E-S</a>, main CPU, 67 MHz, between 200 and 300 MIPS (<em>Million Instructions Per Second</em>), RISC 32 bit</li>
		<li>an <b>ARM7</b> : <a href="http://en.wikipedia.org/wiki/ARM7TDMI" target="_blank">ARM7TDMI</a>, co-processor, 33 MHz, about 20 MIPS, 16-bit/32-bit RISC</li>
	  </ul>
	</p>

	<p>
	Both can be running code at the same time. 
	</p>

	<p>
	The ARM (<em>Arcos Risc Machine</em>) family is quite widespread on embedded devices, and is known to be small, cheap and power-savvy. The Nintendo 64 offered roughly 100 MIPS, PlayStation 2 and PSP (PlayStation Portable) roughly 560 MIPS, GameCube 980 MIPS. According to some sources, the DS processors are under-clocked to save some power. Some people <a href="http://youtube.com/watch?v=PYIvASbELkw" target="_blank">overclocked</a> them, which involves quite some electronical skills and risks</p>
	</li>
	
	<li>several <b>memory banks</b>, notably 4 MB (4096 kB) of built-in RAM, whose layout is somewhat complex but for the most part is shared by the two processors. There is an additional 656 KB of video RAM, and 64 kB of <a href="http://en.wikipedia.org/wiki/Static_random_access_memory" target="_blank">SRAM</a> intended for game saves</li>
	
	<li>one GPU (<em>Graphical Processing Unit</em>) made of two <b>advanced 2D rendering systems</b> (one for each screen) and a <b>3D rendering system</b>, able to offer various <a href="#3D">3D features</a>. It can render up to 120 000 triangles per second at 60 frames per second, a fill rate of about 30 million pixels per second. This is a completely custom chip integrated in the same chip as both ARM. It is <b>not</b> the PowerVR MBX that was announced by some <a href="http://portables.p-nintendo.com/articles/D-232-1.html" target="_blank">sources</a></li>

	<li>A <b>flashable</b> <a href="http://en.wikipedia.org/wiki/Firmware" target="_blank">firmware</a>, on NVRAM (Non-Volatile RAM)</li>
	
	<li>A <b>gamepad</b> (four-direction keys), with <b>6 bigger buttons</b> (X, Y, A, B in a cross layout; L and R on the far side of the DS) and <b>two smaller</b> (Start and Select)</li>
	
	<li>integrated <b>wireless networking</b>, able to offer proprietary protocol (called <em>NiFi</em>, for Nintendo Wifi) and 802.11b Wifi connectivity, both for local exchanges between DS and communications through the Internet (range between 10 and 30 meters)</li>
	
	<li>a <b>16 hardware channel Virtual Surround sound output</b> with stereo speakers (whose quality is rather good) and standard headphone plug (3.5 mm jack). A sliding button allows to set the volume. DAC runs at 10-bit 32768 Hz stereo</li>
	
	<li>a <b>microphone</b> for sound input, which allows (application-specific) speech-recognition</li>
	
	<li>two <b>slots for FLASH cards</b> : the Slot-1 (DS specific, looking a bit like a small Compact Flash card, up to 1 GB of internal storage) and the Slot-2 (legacy GBA port, used by several add-ons)</li>
	
	<li><b>lithium-ion battery</b> (1000 mAh battery, whereas the DS "fat" has 850 mAh) : with a DS Lite in DS mode, depending on the screen brightness, at least 6 to 10 hours of play, in GBA mode up to 12 hours, in sleep mode two weeks, all when starting from a fully charge battery (4 hours of charge). Of course autonomy decreases with slot-1/slot-2 cards being added. After five hundred charges, the battery capacity drops to about seventy percent and should be replaced</li>
	
	<li><b>small form factor</b> : the (closed) DS Lite is 133 mm × 73.9 mm × 21.5 mm (versus 148,6 x 84,6 x 28,7 mm for the DS "fat"), for 218g (275g for the DS "fat")</li>

	<li><b>built-in realtime 33MHz clock</b>, maintaining time and date even when the DS has been shutdown</li>

	<li><b>two green/orange/red LEDs</b> are available, they can be seen both when the console is open or closed. By default they inform about the Wifi and the battery status</li>
		
</ul>
</p>

<p>
The ARM RISC architecture is heavily inspired from the <em>GameBoy Advance</em> one. Both have an ARM7 (but the DS one is running at 66 MHz instead of 33 MHz), explaining partly the very good retrocompatibility of DS for GBA, and the DS hardware is quite close to the one of PocketPC devices. The performances are expected to be somewhat near the Nintendo 64 ones.
</p>

<a name="memorylayout"></a>
<p>
See the <a href="http://www.dev-scene.com/NDS/Tutorials_Day_2#Memory_Layout" target="_blank">diagram explaining the DS memory layout</a> on Dev-Scene website.
</p>

<p>
Input handling can be done thanks to the traditional gamepad, but also thanks to the touchscreen (it can be used to offer a virtual keyboard, or with a mouse-like interface, or as an handwriting tool, etc.) and/or the microphone (speaking, blowing, shouting, etc.).
</p>

<p>
The two screens can be used also with the DS rotated of 90 degrees, on its side, like an open book.
</p>

<a name="detailedhardware"></a>
<p>
More low-level informations about the DS hardware : 

<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->
	
	<li><a href="http://neimod.com/dstek/" target="_blank">DS Tek</a></li>
	<li><a href="http://nocash.emubase.de/gbatek.htm" target="_blank">GBATEK</a></li>
	<li><a href="http://auia.net/ds/" target="_blank">NDSTech</a></li>
	<li><a href="http://www.dev-scene.com/NDS/Tutorials_Day_2" target="_blank">Dev-Scene tutorial</a></li>
	
</ul>
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br>



<a name="cartridges"></a>
<h3>The cartridges</h3>
<p>
There are two different ports in which cards can be inserted : Slot-1 and Slot-2. In both cases, cards are mostly <a href="p://en.wikipedia.org/wiki/Read-only_memory" target="_blank">ROM</a>, but some of them have a small amount of non-volatile memory, usually <a href="http://en.wikipedia.org/wiki/EEPROM" target="_blank">EEPROM</a> (notably <a href="http://en.wikipedia.org/wiki/Flash_memory" target="_blank">Flash</a> memory), to save some data (highscores, game saved, etc.).
</p>

<h4>The Slot-1 port (a.k.a. DS port)</h4>

<p>
Usual DS game cards are 33.0 × 35.0 × 3.8 mm, and weigh around 3,5 g. They can contain up to 128 MB, but in this case they are a smaller transfer rate than 64 MB ones.  
</p>

<p>
SuperKey and the other Slot-1 <a href="http://en.wikipedia.org/wiki/NoPass" target="_blank">NoPass</a> counterparts, apart from allowing the use of the Slot-2 devices, do not add any memory or feature. They just set the program counter so that it points to a memory location in the GBA slot, allowing programs to be run from storage there. On the contrary, they consume some power that reduces the console autonomy. A <a href="http://en.wikipedia.org/wiki/Flashme" target="_blank">flashed</a> firmware can be used instead, for the most daring.
</p>


<h4>The Slot-2 port (a.k.a. GBA cart, or Flash Cart)</h4>

<p>
There are several slot-2 add-ons, which all provide their own set of features. From the ARM9 point of view, they can offer up to 32 MB of additional ROM (which can be actually RAM) and 64 kB of RAM. This GBA slot bus only supports 16-bit writes, which leads to problems when needing to perform 8-bit only write operations.</p>

<p>
The SuperCard Lite is one of the most interesting linkers, as it fits well in the GBA port (it does not protrude when used with DS Lite) and provides both the optimal 32 MB of RAM and an access to removable storage, here a microSD card. Most of these removable cards are formatted in <a href="http://en.wikipedia.org/wiki/File_Allocation_Table" target="_blank">FAT</a> (i.e. FAT16, not FAT32), which implies no more than 2 GB can be managed. 
</p>

<p>
These linkers use their built-in RAM as a mock flash cartridge, as a cache fed from their mass storage. Some DS homebrew also uses this additional RAM, though addressing issues and speed make it less useful than the DS's built in memory. Some people complained about Supercard's built-in RAM being too slow for some GBA games.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>






<a name="thirdparty"></a>
<h2>Using some third-party software</h2>

<p>
Software distribution on the DS is mostly based on ROM images, which can be downloaded on a PC as unique files. These files are read by the DS system, which see them as a kind of archive (a filesystem actually) containing possibly numerous files and directories.  
</p>



<a name="romformats"></a>
<h3>Understanding the various ROM formats</h3>

<p>
One can find several file extensions for Nintendo ROM. Each extension has a <a href="http://www.ndshb.com/modules.php?name=Content&pa=showpage&pid=27" target="_blank">specific meaning</a>, is associated to a specific executable format, and must be chosen adequately.
</p>

<p>
Their sole purpose is to contain binaries (i.e. executables) for the two ARMs and, most often, application-specific data (icons, bitmaps, sounds, etc.), stored as a unique flat file or as a full filesystems, in one or more files, each filesystem containing in turn files and directories. To be run from the GBA ROM (slot-2), they should include a loader that transfers them to the RAM.
</p>


<h4>Known formats &amp; extensions</h4>

<p>
The most frequent extensions are :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li><p><b>.nds</b> (ex: <code>myGame.nds</code>) : 
	this binary for the DS embeds the two executables needed, one for each ARM, and optionally some appended data. This file format was designed to be run from RAM filled from the slot-1, hence it does not include any specific loader. Therefore old generation .nds do not have a loader at all, and thus an external one must be used, generally provided by the menu loader of the flash cart device.</p>
	
	<p>Some newer .nds put nevertheless a loader, which they store into some unused space of the header. Sadly, many GBA flashers mess up the NDS header, thinking it's a corrupted GBA header. An external loader is then needed again.
	</p>
	
	<p>
	.nds files are made of a (NDS) header, then a region dedicated to the ARM7, then a region dedicated to the ARM9, then the data, for example a filesystem. The FlashMe + WMB method and GBA Movie Player support .nds files. They are often used with slot-1 cards, such as M3 and DS-X
	</p>
	</li>
	
	<li><b>.ds.gba</b> (ex: <code>myGame.ds.gba</code>) : this binary for the DS is designed to run from GBA ROM. It is usually made of a small loader (to transfer thanks to the ARM7 the ROM content from the GBA card to the main RAM) contained in a 512-byte (GBA) header, then a .nds file, and zero or more appended data files. The code from the .nds reads from the appended data files using reads from GBA ROM space. GBA flash carts, M3, and SuperCard support this. They are often used with slot-2 cards, such as EZ4</li>
	
	<li><b>.gba.nds</b> : the SuperCard firmware seems to believe that the .ds.gba format is indicated by the .nds extension. Hence to run a .ds.gba program on a SuperCard, one has to rename it first so that its extension becomes .nds. However by doing so one could mix it up with real .nds. One work-around is then to rename that program with, for example, a .gba.nds extension, instead of a mere .nds. However for a SuperCard, an original <code>myGame.ds.gba</code> could be renamed preferably to <code>myGame.sc.nds</code> (see below)</li>

	<li><b>.sc.nds</b> : extension to be used with SuperCard (sc) and, in some cases, G6 lite. This is a renamed .ds.gba (and maybe too DLDI-patched, see below). The .sc.nds extension is a (better since clearer) alternative to the ds.gba one</li>
	
</ul>
</p>

	
<p>
Some quite uncommon names and extensions are :
<ul>

<!--
	<li><b></b> : </li>
-->
	
	
	<li><b>.srl</b> : also called <em>clean dump</em>, it is a dump of commercial ROM, made of a .nds file and an appended file system, usually in Nitro-FAT format. The code in the .nds file reads from the appended file system, using block transfers, through the DS game card access registers. Homebrew tools do not generate .srl, and WMB does not support .srl. These clean dumps are sometimes distributed as .nds ROM, because they use the same header</li>
	
	<li><b>_BOOT_MP.nds</b> : the GBAMP (<em>GBA Movie Player</em>) will boot automatically on this file</li> 
	 
</ul>
</p>


<h4>Conversions between ROM formats</h4>

<p>
.nds programs can be converted into ds.gba programs. It involves prepending a loader, which may load the first appended .nds file, or allow selection of one of many .nds files.
</p>

<p>A loader can be a file named <em>ndsloader.bin</em>, which could be prepended that way :
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
On Windows :
copy /b ndsloader.bin &lt;the .nds file to convert&gt; &lt;the resulting merged file&gt; 

For example :
copy /b ndsloader.bin myGame.nds myGame.ds.gba

On Linux :
cat ndsloader.bin &lt;the .nds file to convert&gt; &gt; &lt;the resulting merged file&gt; 

For example :
cat ndsloader.bin myGame.nds > myGame.ds.gba
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
The other way round, from ds.gba to .nds, usually cannot be performed if not already done by the author, because most often the application relies on specific data meant to be embedded, which is not supported with a .nds file.
</p>

<p>
There are some tools, such as the <a href="http://l33t.spod.org/ratx/DS/SC/scmhbp/" target="_blank">Supercard Magic Homebrew Patcher</a>, that turns your .nds / .ds.gba files into a fixed supercard .sc.nds file. 
</p>

<p>Finally, most of the recent FAT-based homebrew applications need to be patched according to the relevant DLDI script, before being run.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="linkerstorage"></a>
<h3>Linker storage and DLDI</h3>

<p>
Before rushing for the numerous homebrew softwares available on the Internet, one must understand the problem encountered with the various <em>linkers</em>, the specific cards inserted in Slot-2 to provide dedicated storage. It therefore applies mostly to ROM using the .ds.gba format, including .gba.nds and .sc.nds. 
</p>

<p>
As each linker offers its own memory interface (the way it writes to the Flash ROM), as soon as an application has to access to a memory provided by the linker, this homebrew has to be aware of the specific linker it will run with. Several solutions exist : one may build as many versions of one's software as supported linkers (it becomes soon tedious and messy), or one may use Chishm's DLDI, for FAT-based applications.
</p>

<p>
<a href="http://chishm.drunkencoders.com/DLDI/" target="_blank">DLDI</a> stands for <em>Dynamically Linked Device Interface for libfat</em>. The DLDI-aware software can be storage-agnostic. It has just to be built once, and patched according to the target linker it is to run with, before being transferred to the DS.
</p>

<p>
The point is that for the user it is quite easy to patch the software, and it frees the developer from having to take into account each and every linker variation on the market. Even linkers released years after one's software will be supported thanks to DLDI, with no additional efforts from the original author.
</p>

<p>
DLDI is needed whenever libfat versions more recent than Christmas 2006 are being used.
</p>


<a name="dldiexample"></a>
<p>
In practice, the user will need :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li>the target <b>DLDI-enabled software to patch</b> (of course)</li>
	<li>a <b>patching tool</b> : the command-line or GUI <a href="http://chishm.drunkencoders.com/DLDI/" target="_blank">dlditool</a>, available for Windows, <a href="http://chishm.drunkencoders.com/DLDI/downloads/dlditool-linux-x86.zip" target="_blank">Linux</a> and Mac OS X</li>
	<li>the <b>device-specific patch file</b> which corresponds to your linker (see <a href="http://chishm.drunkencoders.com/DLDI/" target="_blank">DLDI Device patches</a>, including the one for <a href="http://chishm.drunkencoders.com/DLDI/downloads/sclt.dldi" target="_blank">SuperCard Lite (SD Card)</a>)</li>
</ul>

</p>

<p>
Linux users just have to put the dlditool archive (here <code>dlditool-linux-x86.zip</code>) and the device-specific patch file (here <code>sclt.dldi</code>) in a new directory and prepare them. For example :
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
mkdir ~/dldi
mv ~/dlditool-linux-x86.zip ~/sclt.dldi ~/dldi
cd ~/dldi
unzip dlditool-linux-x86.zip
chmod +x dlditool
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>



<p>
One just has then to use the DLDI tool to patch the software (here <code> myGame.nds</code>) according to its linker-specific patching specification : <code>./dlditool sclt.dldi myGame.nds</code> for example. Check that the tools returned that the operation was successfully performed.
</p>

<p>
Another option for Windows users is to install <a href="http://psychowood.altervista.org/getDLDIrc.html" target="_blank">DLDIrc</a>, which is configured once for all with a target linker and adds to the contextual menus for each selected DS ROM (the menu obtained with the right-click) the possibility to patch it.
</p>

<p>
More informations about DLDI : on <a href="http://www.dev-scene.com/NDS/Libfat_DLDI" target="_blank">Dev-Scene</a>.
</p>

<p>
Finally, some homebrew make use the SRAM (actually, a non-volatile RAM) that may be provided by a flash cart.
</p>



<a name="linuxonds"></a> 
<h3>An example : Linux on DS</h3>

<p>
Even though most DS applications are to be run standalone (i.e. by themselves, not using any other specific operating system), one can nonetheless have its DS run a dedicated <a href="http://en.wikipedia.org/wiki/Operating_system" target="_blank">operating system</a> (OS). Beneath the fun experience, it may allow for multitasking, or may just provide an environment familiar to the user, with useful tools.
</p>

<p>
Should an OS be used, it will have to be executed as any other application. This OS will then be able itself to run the applications it hosts. They may even run simultaneously, if the OS supports multitasking and if it does not monopolize too much of the DS resources for its own need, thus not letting enough CPU or RAM for these executables.  
</p>

<p>
Among all other operating systems, homebrewers often favor <a href="http://en.wikipedia.org/wiki/Linux" target="_blank">Linux</a>.
</p>

<p>
On the DS this OS is provided thanks to <a href="http://en.wikipedia.org/wiki/DSLinux" target="_blank">DSLinux</a>, based on <a href="http://en.wikipedia.org/wiki/UClinux" target="_blank">uClinux</a>.
</p>

<p>
It can be <a href="http://kineox.free.fr/DS/" target="_blank">installed</a> quite easily (this can be taken in charge through LOANI too, see <a href="#loaninds">below</a>) :
<ol>
<!--
	<li><b></b> : </li>
-->
	<li><b>download</b> <a href="http://kineox.free.fr/DS/dslinux-dldi.tgz" target="_blank">dslinux-dldi.tgz</a> on your computer
 </li>
	<li><b>extract</b> it in a new directory</li>
	<li><b>patch</b> the extracted <code>dslinux.nds</code> with the adequate DLDI device patch (refer to our DLDI <a href="#dldiexample">nano-guide</a>)</li>
	<li><b>copy</b> the full directory content (i.e. <code>dslinux.nds</code> and the <code>linux</code> directory extracted from the archive) at the root of your SD</li>
	<li><b>reboot your DS</b>, select Linux and enjoy</li>
</ol>
 
</p>

<p>
See DSLinux running, with the virtual stylus-based keyboard on the bottom screen :
<center>
    <a href="linux-global.jpeg" target="_blank"><img src="linux-global-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>
</p>

<p>
The terminal output is on the top screen :
<center>
    <a href="linux-zoom.jpeg" target="_blank"><img src="linux-zoom-small.jpeg" alt="Image" width="40%"></img></a><br>(click to enlarge)
</center>

</p>

<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://dslinux.org/" target="_blank">DS Linux Official WebSite</a>, including its <a href="http://dslinux.org/?page=faq" target="_blank">FAQ</a></li>
	
    <li><a href="http://en.wikipedia.org/wiki/DSLinux" target="_blank">DS Linux on Wikipedia</a></li>
	
    <li><a href="http://www.debian.org/ports/arm/" target="_blank">ARM-dedicated Debian build</a></li>
	
    <li><a href="http://popcon.debian.org/" target="_blank">Popularity contest</a> for architectures supported by Debian (see ARM)</li>

</ul>
 
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>





<a name="programmingDS"></a>
<h2>Programming the DS</h2>


<a name="tools"></a>
<h3>Gathering the adequate tools for homebrew</h3>

<p>
Quite a few languages can use sources directly taken from the DS. They are mostly interpreted : there are ports for python, perl or lua, maybe one day Erlang. Some of them are expected to be run from DSLinux.  
</p>

<p>
As for C/C++, one would need a full build toolchain, since these languages are compiled instead of being interpreted. No native toolchain is available directly from the DS : it would demand more RAM than the built-in 4 MB (hence specific flash carts would be required), compilation would be long, and the development process would be quite painful.
</p>

<p>
Therefore the development process starts usually on a computer rather than on the DS : the built binaries are cross-compiled, i.e. they are generated on a PC but according to the conventions of another architecture, so that they can be executed finally on this target architecture (here, the DS). This is quite common in embedded environments.
</p>

<p>
Once the programs are compiled and linked, they can be tested in place, i.e. on the PC thanks to DS emulators, or they can be <a href="#limitations">transferred</a> to the DS and run on it.
</p>

<p>
We consider here that you have the basic tools installed on your computer, notably a text editor (vi, emacs, nedit, etc.) or an IDE (KDevelop, etc), and the <code>GNU make</code> program.
</p>

<p>
Most of the tools that will be mentioned here (i.e. devkitARM, libnds, libfat, dswifi, PAlib, DeSmuME, NO$GBA), plus dlditool, can be installed by hand or thanks the <a href="http://osdl.sourceforge.net/OSDL-latest/LOANI.html" target="_blank">LOANI</a> script, provided by OSDL for GNU/Linux users. One just has to download latest LOANI archive and to run :
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
./loani.sh --nds --buildTools
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
to have them automatically downloaded, extracted and installed in their OSDL reference version, ready to be used. All these tools are open source.
</p>

<p>
See <a href="http://www.dev-scene.com/NDS/Tutorials_Day_1#Installation_Of_Tools" target="_blank">Dovoto's tutorial</a> and <a href="http://www.devkitpro.org/setup.shtml" target="_blank">Dave Murphy's guide</a> (maintainer of devkiptARM) for more information about the installation of tools.
</p>

<p>
Note that the devkitARM tools are designed to run on 32-bit architectures. If your PC uses a 64-bit processor you will need the <code>ia32-libs</code> for Debian-based distributions.
</p>




<a name="devkitarm"></a>
<h4>First : the compiler toolchain, with devkitARM</h4>

<p>
We need the common build tools to generate binaries from our C/C++ sources : a preprocessor, a (ARM) compiler and a linker (not related to the cartridges, just a software) that knows the DS ROM <a href="romformats">formats</a> and its <a href="#memorylayout">memory</a> layout.
</p>

<p>
Tools for commercial developers are not available for homebrewers but, luckily, there is an alternative toolchain, whose name is <a href="http://www.devkitpro.org/" target="_blank">devkitpro</a>. This toolchain is adapted from the <a href="http://en.wikipedia.org/wiki/GNU_Compiler_Collection" target="_blank">GCC</a> one. Its supports many consoles besides the DS (GameBoy Advance, GP32, Playstation Portable and GameCube). DS are ARM-based, hence we need <a href="http://www.devkitpro.org/category/devkitarm/" target="_blank">devkitARM</a>, which provides everything we need (and more). </p>

<p>
Installing devkitARM on UNIX is straightforward : one just has to <a href="http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=124207" target="_blank">download</a> latest stable version and extract it. Nothing more needs to be done, as the toolchain is prebuilt here : you downloaded the appropriate binaries, and there is not real point in recreating them from their sources.
</p>

<p>With devkitARM you will be able to write programs with the classical C/C++ constructs. But what about text output ? Graphics ? Touchpad or key input ? The C/C++ language and runtime do not really provide these features natively, but you can do everything yourself. You just have to figure out for example that at address <code>0x4000000</code> there is a 32-bit register that you can write to, in order to control the display. Even if most relevant <a href="detailedhardware">informations</a> are available, your time and patience might be quite quickly exhausted. Thus you can use a low level library instead, that would spare you these efforts. This is the task of libnds.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="libnds"></a>
<h4>Second : the low-level library, libnds</h4>

<p>
<a href="http://en.wikipedia.org/wiki/Libnds" target="_blank">Libnds</a>, formerly <a href="http://www.drunkencoders.com/documents/DS/ndslib.htm" target="_blank">ndslib</a>, supports nearly all features of the Nintendo DS, including: touch screen, microphone, 2D/3D hardware, and 802.11b Wi-Fi via the dswifi library.
</p>

<p>
It is not libnds purpose to give you advanced components that would do all the work for you. It is just a thin layer that will abstract a bit hardware facilities, thanks to suitable low-level primitives which will hide unwanted technical details, such as the actual location of registers in memory.
</p>

<p>
libnds is thin enough not to imply tradeoffs : compared to ad hoc lowest level programming, using it will not hinder anything or result in a loss of performance. 
</p>

<p>
Hence if you are not making a full use of libnds, most of the time it is that you chose to rely on higher level libraries.
</p>

<p>
The installation of libnds is trivial (just a matter of extracting the latest <a href="http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=151608" target="_blank">archive</a>). If you plan to use PAlib, libnds will be provided with it, no need for a specific libnds install then.
</p>

<p>
One can use also the <a href="http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=159894" target="_blank">libnds examples</a> to learn how to use the library. They are not installed by LOANI currently.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="libfat"></a>
<h4>Third : a FAT library, libfat</h4>

<p>
Most applications and games need some way of reading and writing from and to non-volatile media, and to access it as a filesystem rather than, say, a sequence of data blocks. This is useful notably to read resource files (images, sounds, etc.) and to write highscores, settings and saved games.
</p>

<p>
In the case of the DS many filesystems could be used, but one of them, FAT16, is by far the most common. To manage such filesystems, a dedicated library, <a href="http://chishm.drunkencoders.com/libfat/" target="_blank">libfat</a>, can be used. It depends on libnds, both of which being packaged as part of DevkitPro.
</p>

<p>
With libfat files can be managed almost exactly as they would be on POSIX systems. Directories follows different conventions.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="dswifi"></a>
<h4>Fourth : a library to manage Wifi, dswifi</h4>

<p>
<a href="http://sourceforge.net/project/showfiles.php?group_id=114505&package_id=199021" target="_blank">dswifi</a> offers a low level interface to the DS Wifi connectivity. Access points, connexions, IP adresses, frames and packets can be easily handled thanks to that library.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>


<a name="palib"></a>
<h4>Fifth : an (optional) higher level library, PAlib</h4>

<p>
<a href="http://www.palib.info" target="_blank">PAlib</a> (<a href="https://sourceforge.net/projects/pands/" target="_blank">alternate site</a> on Sourceforge) is one of those abstracting libraries. It is built on top of libnds and offers various higher-level integrated services to the homebrewer.
</p>

<p>
Like HAM for the GameBoy Advance, its intended public is developers wanting to use the most time-effective methods to write their software. Hardware purists often consider any library beneath libnds being useless (bloating software), restrictive or performance-killer. One should try both ways. As for me, I found interesting to use first libnds only, to learn how things work. Once done, anything allowing to gain some time sounds interesting to me, and I would not like to reinvent the wheel too often. So I use PAlib for most of my needs.  
</p>

<p>
To install it, follow <a href="http://www.palib.info/wiki/doku.php" target="_blank">PAlib's tutorial</a> or use LOANI.
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="building"></a>
<h3>Building your first DS program</h3>

<p>
Now has come the time for a first test. LOANI users should first source the <code>LOANI-installations/OSDL-environment.sh</code> file to update their environment : <center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
. OSDL-environment.sh
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>
 
 
<p>
Then let's build some tests : go for example in <code>devkitPro/PAlibExamples/Input/Keyboard/Keyboard</code> and just execute <code>make</code>. It will read the <code>Makefile</code> and generate, from the sources (in <code>source/main.c</code>), the corresponding ROM : <code>Keyboard.ds.gba</code>, <code>Keyboard.nds</code> and
<code>Keyboard.sc.nds</code> (all occupying around 95 ko). Refer to our section about <a href="#romformats">ROM formats</a> for a reminder of their respective role.
</p>

<p>
Something similar to this should occur :
<center>
    <table summary="a box" style="border : none">
        <tr>
          <td>
            <div class="box">
&gt; make<br>
main.c<br>
arm-eabi-g++ -g -mthumb-interwork -mno-fpu -LYourLOANIDir/LOANI-0.5/LOANI-installations/devkitPro/PAlib/lib -specs=ds_arm9.specs main.o -LYourLOANIDir/LOANI-0.5/LOANI-installations/devkitPro/PAlib/lib -lpa9 -LYourLOANIDir/LOANI-0.5/LOANI-installations/devkitPro/libnds/lib -lfat -lnds9 -ldswifi9 -o build.elf<br>
Nintendo DS rom tool 1.33 - Jan 27 2007 16:00:04<br>
by Rafael Vuijk, Dave Murphy,  Alexei Karpenko<br>
built ... Keyboard.ds.gba<br>
dsbuild 1.21 - Jan 28 2007<br>
using default loader<br>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
To decrypt a bit, the Makefile will try to rebuild target <code>$(OUTPUT).ds.gba</code>, whose name is deduced from the current directory (here, Keyboard). To build <code>Keyboard.ds.gba</code>, <code>Keyboard.nds</code> is needed, which in turns implies <code>Keyboard.bin</code> exists, then <code>Keyboard.elf</code>, then <code>$(OFILES)</code>. This variable contains all the object files needed, deduced from the source code (<code>*.c, *.cpp</code>) but also from the resources to be embedded (ex : <code>*.jpg, *.bmp</code>, etc.).
</p>

<p>
Thus the first thing is to obtain these object files. The C++ compiler for ARM (<code>arm-eabi-g++</code>) is called to generate an object file, main.o, for the ARM9, from main.c. Have a look at this file, this is the main one you are expected to write on the future. 
</p>

<p>
Once all the object files are created, they can be aggregated by the linker (here, <code>arm-eabi-g++</code> again) in <code>Keyboard.elf</code> (ELF for <code>External Link Format</code>).
</p>

<p>
More precisely main.o, that provides the <code>main()</code> function, will be linked (statically; no dynamic linking available on the DS) with PAlib (<code>-lpa9</code> refers to <code>libpa9.a</code>, 9 for the ARM9), which itself uses some helper libraries : libfat, libnds9, dswfi9, even if simple this example do not use them all. Linking with unused libraries will not make your ROM bigger : they will not be included if really not used.
</p>

<p>
<code>Keyboard.elf</code> can then be converted in <code>Keyboard.bin</code> by <code>arm-eabi-objcopy</code>, whose role is to copy and translate object files from a given format to another.
</p>

<p>
From <code>Keyboard.bin</code>, <code>Keyboard.nds</code> (at last, a ROM file !) will be generated thanks to <code>devkitARM/bin/ndstool</code>, whose role is to combine the two executables and the data resources into a single file ready for DS distribution. Note that <code>Keyboard.bin</code> contains everything but the executable for the ARM7. This one is retrieved here from a precompiled default version, a kind of template, located in <code>arm7.bin</code>.
</p>

<p>
Finally the <code>devkitARM/bin/dsbuild</code> executable is used to generate <code>Keyboard.ds.gba</code> from <code>Keyboard.nds</code>. This involves adding a slot-2 loader. 
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



<a name="testing"></a>
<h3>Testing your first DS program</h3>

<p>
You have two options here : either the ROM must come one way or another to the DS (transfer), or the DS must come to the ROM and the PC (emulation). 
</p>


<h4>Transferring</h4>
<p>
The most obvious method is to transfer your ROM, here <code>Keyboard.sc.nds</code>, to your DS : copy it to, say, your microSD card, insert that card in your DS and run the ROM, for example thanks to the SuperCard menu. That should work.
</p>

<p>
This method has however two drawbacks. The minor one is that on some computers, notably laptops like mine, Linux support for SD card is still quite limited, and often you end up with mounting, reading or writing problems. The major drawback is, even if the SD are well recognized, it becomes soon tiedous to swap the card again and again between its adapter on PC and the DS. For most people, the developing process requires too frequent tests to do so.     
</p>

<p>
Using a Wifi transfer, preferably thanks to a router, could do the trick, and be more convenient than the card swap. One could use DSLinux for a SSH or FTP transfer followed by a reboot. This is not necessarily the best solution ever though. As for cable (parallel, USB, etc.), as already discussed, they either require soldering efforts or are quite expensive. 
</p>


<h4>Emulating</h4>

<p>
The second method for testing your programs is to use an <a href="http://en.wikipedia.org/wiki/Emulator" target="_blank">emulator</a>. This will allow a PC to mimic your DS, so that you can test in-place the (approximated) result of your ROM.
</p>

<p>
Though the imitation is not always perfect, emulators have progressed a lot. For the Linux user, in decreasing order of interest, one should use :
<ol>
<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li>
	<p>
	<a href="http://www.desmume.org/" target="_blank">DeSmuME</a> : there is a <a href="http://desmume.org/?p=19" target="_blank">Linux</a> version and Debian packages, based on a <a href="http://gpf.dcemu.co.uk/ndsSDL.shtml" target="_blank">SDL</a> port. Some people prefer to run the Windows version from Wine (<code>apt-get install wine</code> for Debian-based distributions). 
	</p>

	<p>
	To do so, <a href="http://www.desmume.com/download.htm" target="_blank">download</a> DeSmuME latest stable version, unzip it, and simply run <code>wine NDeSmuME.exe</code>. In the <code>File</code> menu, you can select <code>Open and Execute</code>, and choose your .nds file (ex : <code>Keyboard.nds</code>). You should then be able to test it immediately
<center>
    <img src="DeSmuME-screenshot.png" alt="DeSmuME"></img>
</center>
	</p>
	</li>
	
     <li><a href="http://nocash.emubase.de/gba.htm" target="_blank">NO$GBA</a> should be used with Wine too. Just <a href="http://nocash.emubase.de/no$gba-w.zip" target="_blank">download</a> it, unzip it, run <code>wine NO\$GBA.EXE</code> and select, this time, your .ds.gba file (ex : <code>Keyboard.ds.gba</code>)
<center>
    <img src="NoCashGBA-screenshot.png" alt="NO$GBA"></img>
</center>

</li>
	 
    <li><a href="http://dualis.1emu.net/dsti.html" target="_blank">Dualis</a> (not tested; known to be faster than NO$GBA, but now unable to manage libfat unless FCSR drivers are used)</li>
	
    <li><a href="http://www.ndsemulator.com/nintendo-ds/ideas-download.htm" target="_blank">Ideas</a> (not tested)</li>
	
    <li><a href="http://www.ndsemulator.com/nintendo-ds/ensata.htm" target="_blank">Ensata</a> (not tested; illegal material leaked from Nintendo, according to some sources)</li>
	
</ol>
</p>

<p>
See also the <a href="http://www.ndsemulator.com/" target="_blank">NDSEmulator.com</a> site.
</p>


<p>
Having the general hardware specifications and the relevant toolchain is not enough to be able to program effectively the DS : there is still additional informations to gather before being able to write full-blown applications for it.
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="usinghardware"></a>
<h3>Using effectively the hardware</h3>

<a name="twocpu"></a>
<h4>Two general-purpose CPU to handle</h4>
<p>
For newcomers, one of the most disturbing specificities of the DS is its having multiple processors. They are expected to share the load : even if both ARM are rather general-purpose, the ARM9 should take the most of computation-intensive tasks, including graphic-related operations (it is the only one that can interact with the 3D rendering engine), the ARM7 should concentrate on input management (touchscreen, most keys), wireless communications, audio output and any GameBoy emulation, whereas the 2D/3D engines will be dedicated to rendering.
</p>

<p>
The main built-in memory, consisting of one big block of 4MB memory, can be accessed by both ARM's, but one at a time. When both CPUs are trying to read main memory, one will have priority over the other.
</p>

<p>
The ARM CPU can communicate thanks to <a href="http://en.wikipedia.org/wiki/Inter-process_communication" target="_blank">IPC</a> (<em>Inter-process communication</em>) based on a set of registers, managed thanks to a <a href="http://en.wikipedia.org/wiki/FIFO" target="_blank">FIFO</a> (<em>First In, First Out</em>) data structure. 
</p>

<p>
Both CPU can trigger interrupts to each other (if the ARM9 allows it). It is convenient to send a notification to the other CPU when for example there is data for it waiting to be read on a shared area in RAM, once the calling CPU has finished filling it.
</p>

<p>
As a consequence the DS ROM has to include at least two executables, one for each of the ARM (not mentioning application-specific data). At runtime the executables will have to work simultaneously, which involves often having to be synchronized and to share data. 
</p>


<h5>ARM7 role</h5>

<p>
The ARM7 is the only CPU that can be used for controlling the touchscreen. Most applications use boilerplate code that sets up an interrupt handler for the <em>Vertical Blank Interrupt</em> (VBI). This interrupt occurs once each frame (each time the screen is redrawn), hence it provides a hard real-time 60Hz time-base.
VBI is useful to draw on the each screen while it is not being refreshed : doing so allows to avoid disturbing visual artefacts.
</p>

<p>
This time-base can be used for synchronization too. It is what interests us here, so that an interrupt handler dedicated to ARM7 input reporting can be scheduled regularly. The ARM7 boilerplate code gets the value of the touchscreen parameters and stores them in a data structure we can access from the ARM9.
</p>

<p>
devkitPro includes a default ARM7 program to handle basic tasks like interrupts, touchscreen, etc. It is the <code>arm7.bin</code> discussed in our <a href="#building">building</a> section. Usually there is no need to write custom ARM7 code. The standard Makefiles include this default ARM7 program.
</p>


<h5>ARM9 role</h5>

<p>
Due to its superior power compared to the ARM7, the ARM9 is the main processor and as such will take in charge most of the work. Application-specific code is expected to run on it.
</p>

<p>
A single <code>main()</code> function defines usually :
<ol>

	<li>an <b>initialization</b> stage, to set screen modes, memory banks, interrupt handlers, to initialize various libraries (ex : PAlib, libfat, dswifi, etc.) and to perform as many tasks as possible (ex : loading the resources from mass storage, setting up Wifi connections, etc.)</li>

	<li>a <b>main loop</b>, in charge of : 
		<ul>

		<!--
		        <li><b></b> : </li>
		-->

  		     <li><b>game logic</b>, including any AI algorithms</li>
  		     <li><b>input management</b>, partly read from the ARM7 (touchscreen, some keys)</li>
  		     <li><b>audio and video rendering</b>, partly managed by the 2D/3D engines too</li>
  		     <li><b>I/O exchanges</b> with a mass storage device, if any</li>
		</ul>
	</li>

	<li>a <b>shutdown</b> stage, to stop all subsystems properly, including flushing write buffers (closing files, unmounting mass storage, etc.), stopping the Wifi connections, etc.</li>
</ol>
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>



 
<a name="subsystems"></a>
<h4>Activating only the relevant subsystems</h4>

<p>
First, the DS can run in different modes, including the GBA Mode (ARM9 not used), sleep (for the ARM7), stop, halt, etc. The DS can be woken up from various IRQ (<em>Interrupt Requests</em>) :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li>timer triggered</li>
	<li>screen being opened</li>
	<li>slot-1 or slot-2 card being removed</li>
	<li>certain key combination pressed (with the exception of X and Y)</li>
</ul>
</p>

<p>
Second, most subsystems of the DS can be powered independently : sound speakers, Wifi, LCD screens, the two 2D engines, the 3D rendering and geometry engines.
</p>

<p>
Selective activation is useful notably to save energy.
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="rendering"></a>
<h4>2D/3D Rendering</h4>

<h5>2D Rendering</h5>

<p>
The system has two 2D engines, one per screen. These are each quite similar to the Game Boy Advance's single 2D engine, though more powerful.
</p>

<p>
At most 128 sprites are supported at a time, and there are up to four background layers (text, rotating/scaling, bitmap). 
</p>

<p>
See also : <a href="http://liranuna.drunkencoders.com/nds-2d-tuts/" target="_blank">LiraNuna's 2D tutorial</a>.
</p>


<a name="3D"></a>
<h5>3D Rendering</h5>

<p>
The system's 3D hardware can perform a lot of operations :
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://en.wikipedia.org/wiki/Transform_and_lighting" target="_blank">transform and lighting</a> : performs 3D space to screen conversion, including lighting. Having it hardware accelerated frees the CPU from this computation-intensive task</li>
    <li>texture-coordinate transformation : so that textures (images used to wrap 3D shapes) can be used</li>
    <li><a href="http://en.wikipedia.org/wiki/Texture_mapping" target="_blank">texture mapping</a> : applies a texture to a shape</li>
    <li><a href="http://en.wikipedia.org/wiki/Alpha_blending" target="_blank">alpha blending</a> : combines an image with a background to create the appearance of partial transparency</li>
    <li><a href="http://en.wikipedia.org/wiki/Anti-aliasing" target="_blank">anti-aliasing</a> : minimizes the distortion artifacts due to on-screen rendering (enhances the resulting image)</li>
    <li><a href="" target="_blank">cel shading</a> : simulates hand-drawn ( like cartoon or comic books) computer-generated graphics</li>
    <li><a href="http://en.wikipedia.org/wiki/Z-buffering" target="_blank">z-buffering</a> : management of image depth coordinates, one of the solutions to the visibility problem</li>
</ul>
</p>


<p>
Character rendering might have a blocky appearance due to Point (nearest neighbor) texture filtering. 2D sub-pixel glyph rendering could be used though, as it is done with the TextViewer homebrew.
</p>

<p>
The DS can render at most about 2048 triangles per scene as 60 frames per second. Rendering can occur only to a single screen at a time, so having 3D on both screens decreases performance significantly. The DS is more limited by its polygon budget than by its pixel fill rate.
</p>

<p>
There are 512 kB of texture memory per screen, and the maximum texture size is 1024x1024 pixels.
</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="wireless"></a>
<h4>Wireless networking</h4>
<p>
The built-in Wifi support allows the DS to communicate (with a theoretical bandwith of 1-2 Mbit per second) :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li>with a <b>standard access point</b> (i.e. public non-<a href="http://en.wikipedia.org/wiki/Captive_portal" target="_blank">captive portal</a> hotspots or a personal 802.11b or 802.11g wireless routers) to access the Internet. The DS supports <a href="http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy" target="_blank">WEP</a>
 encryption but not <a href="http://en.wikipedia.org/wiki/Wi-Fi_Protected_Access" target="_blank">WPA</a></li>
 
	<li>with <b>other DS</b> in the vicinity, through <a href="http://en.wikipedia.org/wiki/NiFi" target="_blank">Nifi</a>, a modified WiFi protocol created by Nintendo for the DS and the Wii, partially secured using RSA security signing. It is used in non-online multiplayer mode, and to download game demos or multiplayer game software</li>
	
</ul>

</p>


<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>




<a name="miscellaneous"></a>
<h4>Miscellaneous informations</h4>

<p>
Most of these informations come from the listed <a href="#detailedhardware">hardware resources</a>.
</p>

<h5>MMU</h5>
<p>
The DS does not have a Memory Management Unit (<a href="http://en.wikipedia.org/wiki/Memory_management_unit" target="_blank">MMU</a>), a hardware component responsible for handling memory accesses requested by the CPU, notably to enable virtual memory management, memory protection, cache control, bus arbitration or bank switching.
</p>

<p>
It reduces the potential stability of operating systems (as Linux; if they are to be used on a DS), and prevents to access through swap to memory that would be available in Slot-2-provided removable media. 
</p>


<h5>Non rendering-related hardware accelerations</h5>
<p>
The DS contains both divide and square root accelerators.
</p>


<h5>16/32 bit</h5>
<p>
The ARM7 processor supports both 32-bit and 16-bit instructions via the ARM and Thumb instruction sets. 16-bit code is smaller than 32-bit one and, in some specific cases, faster (usually slower though).
</p>

<p>
The ARM9 is a full 32-bit CPU.
</p>


<h5>Power management</h5>
<p>
Various subsystems (power management, firmware, touchscreen, sound volume and control, microphone amplifier control and gain control, back-lighting of screens, power LED, battery status) can be accessed only thanks to the SPI (<em>Serial Peripheral Interface</em>) bus.
</p>

<h5>DMA</h5>
<p>
There are four prioritized DMA channels. They can transfer data asynchronously from the main CPU : the ARM9, if it does not access to main memory, can continue its work while the DMA transfer is going on.
</p>

<h5>Timers</h5>
<p>
There are eight incrementing 16bit timers, four for each CPU.
</p>

<br><p><center>[<a href="#toc">Back to the table of contents</a>]</center></p><br><br>





<a name="otherinfos"></a>
<h2>Some other information sources</h2>



<!-- ########################################################################-->
<a name="tutorials"></a> 
<h3>Tutorials</h3>
<p>
<ul>

<!--
    <li>[T] <a href="" target="_blank"></a></li>
-->

    <li>[T1] <a href="http://www.double.co.nz/nintendo_ds/" target="_blank">Double</a> : interesting, well explained but often deprecated</li>
	
    <li>[T2] <a href="http://www.dev-scene.com/NDS/Tutorials" target="_blank">Devoto</a>'s tutorial : a really good one</li>
	
    <li>[T3] <a href="http://www.playeradvance.org/forum/showthread.php?t=4277" target="_blank">PAlib for Linux</a> (1/2)</li>
	
    <li>[T4] <a href="http://www.palib.info/wiki/doku.php" target="_blank">PAlib for Linux</a> (2/2)</li>
	
    <li>[T5] <a href="http://user.chem.tue.nl/jakvijn/tonc " target="_blank">TONC</a></li>
	
    <li>[T6] <a href="http://www.patatersoft.info/manual_online.html" target="_blank">Patatersoft</a></li>
	
    <li>[T7] <a href="http://www.drunkencoders.com/index.php?system_id=1&page=Tutorials" target="_blank">drunkencoders</a> tutorials</li>

    <li>[T8] <a href="http://scorpei.com/TBGTDSHB/The_Beginners_Guide_To_NDS_Homebrew.pdf" target="_blank">Running Nintendo DS homebrew</a> [PDF], by Simon van de Berg. Helps to understand and choose linkers</li>
	
</ul>

</p>


<!-- ########################################################################-->
<a name="forums"></a> 
<h3>Forums</h3>
<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://forum.gbadev.org/viewforum.php?f=18" target="_blank">gbadev forums</a></li>

    <li><a href="http://forums.abxy.org/f/nintendo-ds" target="_blank">abxy DS forums</a></li>
	
</ul>

</p>


<!-- ########################################################################-->
<a name="irc"></a> 
<h3>IRC channels</h3>
<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="irc://irc.blitzed.org" target="_blank">Dev-Scene IRC</a> (channel : #dsdev)</li>

    <li><a href="irc://irc.freenode.net" target="_blank">DSLinux IRC</a> (channel : #DSLinux)</li>
	
</ul>

</p>


<!-- ########################################################################-->
<a name="applications"></a>
<h3>Homebrew applications &amp; games</h3>

<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

	 <li><a href="http://scummvm.drunkencoders.com/" target="_blank">ScummVM DS</a></li>
	 
    <li><a href="http://www.mrdictionary.net/lemmings/" target="_blank">Lemmings DS</a></li>

    <li><a href="http://mdxonline.dyndns.org/archives/nds/" target="_blank">Moonshell</a></li>

    <li><a href="http://www.dragonminded.com/?loc=ndsdev/DSOrganize" target="_blank">DSOrganize</a>, transform your DS into a PDA</li>

<!-- Apparently a piracy-related site ?
    <li><a href="http://www.nintendo-ds-roms.com/" target="_blank">DS ROMs</a></li>
-->
	
</ul>

</p>


<!-- ########################################################################-->
<a name="otherlinks"></a>
<h3>Some interesting links</h3>
<p>
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->
    <li><a href="http://en.wikipedia.org/wiki/Nintendo_DS_homebrew" target="_blank">Nintendo DS</a> on Wikipedia</li>
	
    <li><a href="http://en.wikipedia.org/wiki/Nintendo_DS_booting_tools" target="_blank">DS booting tools</a> on Wikipedia</li>
	
    <li><a href="http://forum.gbadev.org/viewtopic.php?t=8353" target="_blank">Link repository from gbadev</a></li>

    <li><a href="http://www.ndshb.com/modules.php?name=Content&pa=showpage&pid=27" target="_blank">Extension for DS ROMs explained</a> (twice)</li>
	
    <li><a href="http://www.dev-scene.com" target="_blank">Dev-Scene</a></li>
	
    <li><a href="http://www.aaronrogers.com/nintendods/" target="_blank">Aaron Rogers</a></li>
	
    <li><a href="http://www.drunkencoders.com" target="_blank">Drunk Encoders</a></li>
	
    <li><a href="http://nintendo-ds.dcemu.co.uk/" target="_blank">DS News</a></li>

	<li><a href="http://www.nintendods.com/" target="_blank">Nintendo official website</a></li>


    <li><a href="http://www.warioworld.com/" target="_blank">WarioWorld</a>, software development support group (for professionals, authorized Nintendo developers and licensees). Nintendo only accepts official companies with a game development team, and sufficient experience in certain areas for their official developer support program. Small structures are expected to find a "Nintendo-certified" publisher prior to submit their games</li>

    <li><a href="http://tobw.net/dswiki" target="_blank">DS Developing Wiki</a></li>

    <li>Resources in French :
	<ul>

<!--
    	<li><a href="" target="_blank"></a></li>
-->

    	<li><a href="http://www.gamebe.com/articles/lire/4/nintendo-ds-r-evolution/" target="_blank">Présentation de la DS</a></li>

    	<li><a href="http://www.portabledev.com/pages/ds/tutoriels/tutos.-chris-double" target="_blank">Traduction des tutoriels de Chris Double</a> </li>
	
    	<li>Les <a href="http://mobiles.gx-mod.com/modules/tutos/index.php?id=37" target="_blank">linkers pour DS</a></li>
		
    	<li><a href="http://www.playeradvance.org/forum/showthread.php?t=4277" target="_blank">Installation de PALib sous Linux</a></li>
	
    	<li>Présentation de <a href="http://playeradvance.org/forum/showthread.php?t=5340" target="_blank">Moonshell</a>, <a href="http://www.supercard-france.info/index.php?option=com_content&task=view&id=19&Itemid=78" target="_blank">installation</a> (sous Windows)</li>

    	<li>Informations sur la <a href="http://www.supercard-france.info/" target="_blank">SuperCard</a>, notamment pour <a href="http://www.supercard-france.info/index.php?option=com_content&task=view&id=29&Itemid=141" target="_blank">la mettre à jour</a></li>
	</ul>
	</li>

		
</ul>

 
 </p>

<p><center>[<a href="#toc">Back to the table of contents</a>]</center></p>
  <br>
  <br>
  <br>
  <br>

 <h3>Please react !</h3>

  <p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, <a href="mailto:toshiba.laptop@esperide.com?subject=[OSDL]%20Homebrew%20for%20Nintendo%20DS">drop us a line</a>!</p><br>
  <br>
  <hr>
  <br>
 
  <center>
    [<a href="#_top_">Top</a>]
	<br>
    <br>
    <em>Last update : Friday, June 15, 2007</em>
  </center>
</body>
</html>
