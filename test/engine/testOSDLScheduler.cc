/*
 * Copyright (C) 2003-2011 Olivier Boudeville
 *
 * This file is part of the OSDL library.
 *
 * The OSDL library is free software: you can redistribute it and/or modify
 * it under the terms of either the GNU Lesser General Public License or
 * the GNU General Public License, as they are published by the Free Software
 * Foundation, either version 3 of these Licenses, or (at your option)
 * any later version.
 *
 * The OSDL library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License and the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License and of the GNU General Public License along with the OSDL library.
 * If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Olivier Boudeville (olivier.boudeville@esperide.com)
 *
 */


#include "OSDL.h"
using namespace OSDL ;
using namespace OSDL::Events ;
using namespace OSDL::Video ;
using namespace OSDL::Engine ;


using namespace Ceylan::Log ;
using namespace Ceylan::Maths ;
using namespace Ceylan::Maths::Random ;


#include <list>
using std::list ;

#include <string>
using std::string ;





/**
 * Test of OSDL scheduler, in real-time (best-effort) mode.
 *
 * Some useful testing can be made during the two seconds this test should last,
 * including running it with various machine loads to examine the skip
 * behaviour.
 *
 * This test applies only to the scheduler on soft real-time (best effort)
 * mode. It is not interactive though.
 *
 * @note If not in batch mode, this test should last for exactly 10 seconds.
 *
 * @see testOSDLSchedulerNoDeadline.cc for the batch (screenshot) version.
 *
 * @see plotIdleCallDurations.p to generate a plot from the idle-calls.dat file
 * that can be generated by the scheduler, so that the forecasted idle call
 * durations can be compared to the actual ones.
 *
 * @note Using the classical plug for this test will likely make it fail, as
 * these synchronous logs are very expensive.
 *
 */




/**
 * The role of this object is to have the scheduler stop at a given simulation
 * time.
 *
 * @note A scheduler must already exist before any of these objects is created.
 *
 */
class SchedulerStopper : public OSDL::Engine::ProgrammedActiveObject
{

public:


  SchedulerStopper( SimulationTick stopSimulationTick,
	bool verbose = false ) :
	ProgrammedActiveObject(
	  stopSimulationTick,
	  /* absolutelyDefined */ true,
	  /* autoregister */ true ),
	_stopTick( stopSimulationTick ),
	_verbose( verbose )
  {

	if ( _verbose )
	  LogPlug::info( "SchedulerStopper constructor for "
		+ Ceylan::toString( this )
		+ ": will stop at simulation tick #"
		+ Ceylan::toString( _stopTick ) + "."  ) ;

  }


  SchedulerStopper(
	SimulationTickList & tickList,
	SimulationTick stopSimulationTick,
	bool verbose = false ) :
	ProgrammedActiveObject(
	  tickList,
	  /* absolutelyDefined */ true,
	  /* autoregister */ true ),
	_stopTick( stopSimulationTick ),
	_verbose( verbose )
  {

	if ( _verbose )
	{

	  string stringifiedList = Ceylan::toString( tickList ) ;

	  LogPlug::info( "SchedulerStopper constructor for "
		+ Ceylan::toString( this )
		+ ", with following activation tick list: ["
		+ stringifiedList + "]; will stop at simulation tick #"
		+ Ceylan::toString( _stopTick ) + "."  ) ;

	}
  }


  ~SchedulerStopper() throw()
  {

	if ( _verbose )
	  LogPlug::info( "SchedulerStopper deleted." ) ;

  }



  virtual void onActivation( Events::SimulationTick newTick )
  {

	if ( _verbose )
	  LogPlug::info( "SchedulerStopper::onActivation: "
		"activated for simulation tick "
		+ Ceylan::toString( newTick ) + "." ) ;

	/*
	 * Note: most traces have been removed as they were slowing down the
	 * scheduler and created fake (artificial) problems.
	 *
	 */

	/*
	  LogPlug::debug( "Scheduler state: "
	  + Scheduler::GetScheduler().toString() ) ;
	*/

	if ( newTick == _stopTick )
	{

	  //std::cout << "SchedulerStopper " << this
	  //			<< " stopping scheduler at tick #" << _stopTick
	  //			<< std::endl ;

	  //LogPlug::info( "SchedulerStopper::onActivation: "
		//	"unregistering from scheduler." ) ;

	  // Useless as implied by the deletion:
	  unregisterFromScheduler() ;

	  //LogPlug::info( "SchedulerStopper::onActivation: "
	  //	"stopping scheduler." ) ;

	  Scheduler::GetExistingScheduler().stop() ;

	  /*
	   * Once its mission has been done, could self-remove, however, as we would
	   * have to delete the stoppers that were not activated yet, we would have
	   * to sort them. Instead we remove all stoppers at the end of the test.
	   */
	  //delete this ;

	}

  }


  virtual void onSkip( Events::SimulationTick newTick )
  {

	LogPlug::warning( "SchedulerStopper::onSkip: the simulation tick "
	  + Ceylan::toString( newTick ) + " had been skipped!" ) ;

	// Thus will always be called, regardless of skips:
	onActivation( newTick ) ;

  }



private:

  SimulationTick _stopTick ;
  bool _verbose ;

} ;





/**
 * The role of this object is to display regularly log messages, until a limit
 * in activations (hence output of log messages) is reached.
 *
 * Then it will unregister itself from the scheduler and delete itself.
 *
 * Policy is strict (and not relaxed) to ensure that these objects can be
 * created in the same sub-slot (test of removal while iterating).
 *
 * @note A scheduler must already exist before any of these objects is created.
 *
 */
class SchedulerPacer : public OSDL::Engine::PeriodicalActiveObject
{

public:


  SchedulerPacer( Events::Period period, Ceylan::Uint32 activationCount,
	bool verbose = false ) :
	PeriodicalActiveObject( period, /* autoRegister */ true,
	  /* policy */ strict, /* weight */ 3 ),
	_activationCount( activationCount ),
	_verbose( verbose )
  {

	if ( _verbose )
	  LogPlug::info( "SchedulerPacer constructor for "
		+ Ceylan::toString( this )
		+ ": will output a log once every "
		+ Ceylan::toString( period )
		+ " ticks, until having been activated "
		+ Ceylan::toString( activationCount ) + " times."  ) ;

  }


  ~SchedulerPacer() throw()
  {

	if ( _verbose )
	  LogPlug::info( "SchedulerPacer (" + toString()
		+ ") deleted." ) ;

  }



  virtual void onActivation( Events::SimulationTick newTick )
  {

	/*
	  if ( _verbose )
	  LogPlug::trace( "SchedulerPacer::onActivation: "
	  "activated for simulation tick "
	  + Ceylan::toString( newTick ) + "." ) ;
	*/

	//LogPlug::info( "Message from: " + toString() ) ;

	_activationCount-- ;

	if ( _activationCount == 0 )
	{

	  LogPlug::info( "SchedulerPacer (" + toString()
		+ ") reached its final activation count, "
		"removing itself from scheduling and deleting." ) ;

	  // Implies unregistering:
	  delete this ;

	}

  }


  virtual void onSkip( Events::SimulationTick newTick )
  {

	LogPlug::warning( "SchedulerPacer::onSkip: the simulation tick "
	  + Ceylan::toString( newTick ) + " had been skipped!" ) ;

	// Thus will always be called, regardless of skips:
	onActivation( newTick ) ;

  }


  const string toString( Ceylan::VerbosityLevels level = Ceylan::low )
	const
  {

	return "SchedulerPacer whose period is "
	  + Ceylan::toString( _period) + ", with "
	  + Ceylan::toString( _activationCount )
	  + " remaining activations" ;

  }


private:

  Events::Period _activationCount ;
  bool _verbose ;

} ;




/**
 * The role of this (programmed) object is to kill (remove from scheduling and
 * delete) any active object (programmed or periodical) at a specified tick.
 *
 * @note A scheduler must already exist before any of these objects is created.
 *
 */
class ActiveObjectKiller : public OSDL::Engine::ProgrammedActiveObject
{

public:


  ActiveObjectKiller( SimulationTick killSimulationTick,
	ActiveObject & toKill, bool verbose = false ) :
	ProgrammedActiveObject(
	  killSimulationTick,
	  /* absolutelyDefined */ true,
	  /* autoregister */ true ),
	_killTick( killSimulationTick ),
	_target( & toKill ),
	_verbose( verbose )
  {

	if ( _verbose )
	  LogPlug::info( "ActiveObjectKiller constructor for "
		+ Ceylan::toString( this ) + ": will kill '"
		+ _target->toString() + "' at simulation tick #"
		+ Ceylan::toString( _killTick ) + "."  ) ;

  }


  ~ActiveObjectKiller() throw()
  {

	if ( _verbose )
	  LogPlug::info( "ActiveObjectKiller deleted." ) ;

  }



  virtual void onActivation( Events::SimulationTick newTick )
  {

	/*
	  if ( _verbose )
	  LogPlug::info( "ActiveObjectKiller::onActivation: "
	  "activated for simulation tick "
	  + Ceylan::toString( newTick ) + "." ) ;
	*/

	if ( newTick == _killTick )
	{

	  LogPlug::info( "ActiveObjectKiller::onActivation: "
		"killing target." ) ;

	  /*
	   * Useless, implied by deletion:

	   _target->unregisterFromScheduler() ;

	   *
	   */

	  delete _target ;

	  /*
	   * Once its mission has been done, self-removes (and therefore
	   * self-unregister):
	   *
	   */
	  delete this ;

	}
	else
	{

	  LogPlug::error( "ActiveObjectKiller::onActivation: "
		"scheduled at an unexpected tick." ) ;

	}

  }


  virtual void onSkip( Events::SimulationTick newTick )
  {

	LogPlug::warning(
	  "ActiveObjectKiller::onSkip: the simulation tick "
	  + Ceylan::toString( newTick ) + " had been skipped!" ) ;

	// Thus will always be called, regardless of skips:
	onActivation( newTick ) ;

  }



private:

  SimulationTick _killTick ;

  ActiveObject * _target ;

  bool _verbose ;

} ;




/**
 * The role of this programmed object is to kill (remove from scheduling and
 * delete) a list of an active objects (programmed or periodical) at a specified
 * tick.
 *
 * @note A scheduler must already exist before any of these objects is created.
 *
 */
class ActiveObjectProgrammedSerialKiller :
  public OSDL::Engine::ProgrammedActiveObject
{

public:


  ActiveObjectProgrammedSerialKiller( SimulationTick killSimulationTick,
	bool verbose = false ) :
	ProgrammedActiveObject(
	  killSimulationTick,
	  /* absolutelyDefined */ true,
	  /* autoregister */ true ),
	_killTick( killSimulationTick ),
	_verbose( verbose )
  {

	if ( _verbose )
	  LogPlug::info(
		"ActiveObjectProgrammedSerialKiller constructor for "
		+ Ceylan::toString( this ) + ": will kill "
		+ _targets.size() + " target(s) at simulation tick #"
		+ Ceylan::toString( _killTick ) + "."  ) ;

  }


  ~ActiveObjectProgrammedSerialKiller() throw()
  {

	if ( _verbose )
	  LogPlug::info( "ActiveObjectProgrammedSerialKiller deleted." ) ;

  }


  virtual void addTarget( ActiveObject & toKill )
  {

	_targets.push_back( & toKill ) ;

  }


  virtual void onActivation( Events::SimulationTick newTick )
  {

	/*
	  if ( _verbose )
	  LogPlug::info(
	  "ActiveObjectProgrammedSerialKiller::onActivation: "
	  "activated for simulation tick "
	  + Ceylan::toString( newTick ) + "." ) ;
	*/

	if ( newTick == _killTick )
	{

	  LogPlug::info(
		"ActiveObjectProgrammedSerialKiller::onActivation: "
		"killing targets." ) ;

	  for ( list<ActiveObject *>::iterator it = _targets.begin();
			it != _targets.end(); it ++ )
	  {

		LogPlug::info(
		  "ActiveObjectProgrammedSerialKiller::onActivation: "
		  "killing '" + (*it)->toString() + "'." ) ;

		/*
		 * Useless, implied by deletion:

		 (*it)->unregisterFromScheduler() ;

		 *
		 */

		delete *it ;

	  }

	  /*
	   * Once its mission has been done, self-removes (and therefore
	   * self-unregister):
	   *
	   */
	  delete this ;

	}
	else
	{

	  LogPlug::error(
		"ActiveObjectProgrammedSerialKiller::onActivation: "
		"scheduled at an unexpected tick." ) ;

	}

  }


  virtual void onSkip( Events::SimulationTick newTick )
  {

	LogPlug::warning(
	  "ActiveObjectProgrammedSerialKiller::onSkip: "
	  "the simulation tick " + Ceylan::toString( newTick )
	  + " had been skipped!" ) ;

	// Thus will always be called, regardless of skips:
	onActivation( newTick ) ;

  }



private:

  SimulationTick _killTick ;

  list<ActiveObject *> _targets ;

  bool _verbose ;

} ;



/**
 * The role of this periodical object is to kill (remove from scheduling and
 * delete) a list of an active objects (programmed or periodical) at a specified
 * tick.
 *
 * Strict policy chosen to be in the same sub-slot as the targets.
 *
 * @note A scheduler must already exist before any of these objects is created.
 *
 */
class ActiveObjectPeriodicalSerialKiller :
  public OSDL::Engine::PeriodicalActiveObject
{

public:


  ActiveObjectPeriodicalSerialKiller( Events::Period period,
	Ceylan::Uint32 periodCount,	bool verbose = false ) :
	PeriodicalActiveObject(
	  period,
	  /* autoregister */ true,
	  /* policy */ strict,
	  /* weight */ 1 ),
	_periodCount( periodCount ),
	_verbose( verbose )
  {

	if ( _verbose )
	  LogPlug::info(
		"ActiveObjectPeriodicalSerialKiller constructor for "
		+ Ceylan::toString( this ) + ": will kill "
		+ _targets.size() + " target(s) after "
		+ Ceylan::toString( periodCount ) + " periods."  ) ;

  }


  ~ActiveObjectPeriodicalSerialKiller() throw()
  {

	if ( _verbose )
	  LogPlug::info( "ActiveObjectPeriodicalSerialKiller deleted." ) ;

  }


  virtual void addTarget( ActiveObject & toKill )
  {

	_targets.push_back( & toKill ) ;

  }


  virtual void onActivation( Events::SimulationTick newTick )
  {

	/*
	  if ( _verbose )
	  LogPlug::info(
	  "ActiveObjectPeriodicalSerialKiller::onActivation: "
	  "activated for simulation tick "
	  + Ceylan::toString( newTick ) + "." ) ;
	*/

	if ( _periodCount == 0 )
	{

	  LogPlug::info(
		"ActiveObjectPeriodicalSerialKiller::onActivation: "
		"killing targets." ) ;

	  for ( list<ActiveObject *>::iterator it = _targets.begin();
			it != _targets.end(); it ++ )
	  {

		LogPlug::info(
		  "ActiveObjectPeriodicalSerialKiller::onActivation: "
		  "killing '" + (*it)->toString() + "'." ) ;

		/*
		 * Useless, implied by deletion:

		 (*it)->unregisterFromScheduler() ;

		 *
		 */

		delete *it ;

	  }

	  /*
	   * Once its mission has been done, self-removes (and therefore
	   * self-unregister):
	   *
	   */
	  delete this ;

	}
	else
	{

	  LogPlug::info(
		"ActiveObjectPeriodicalSerialKiller::onActivation: "
		"still " + Ceylan::toString( _periodCount )
		+ " periods to wait." ) ;

	  _periodCount-- ;

	}


  }


  virtual void onSkip( Events::SimulationTick newTick )
  {

	LogPlug::warning(
	  "ActiveObjectPeriodicalSerialKiller::onSkip: "
	  "the simulation tick " + Ceylan::toString( newTick )
	  + " had been skipped!" ) ;

	// Thus will always be called, regardless of skips:
	onActivation( newTick ) ;

  }



private:

  Ceylan::Uint32 _periodCount ;
  list<ActiveObject *> _targets ;
  bool _verbose ;

} ;




/**
 * Testing the services of the OSDL scheduler for active objects, in real-time
 * mode.
 *
 * @see ActiveObject
 *
 */
int main( int argc, char * argv[] )
{

  LogHolder myLog( argc, argv ) ;

  try
  {


	LogPlug::info( "Testing OSDL scheduler services in real-time mode." ) ;

	/*
	 * Tells when the test will stop, by default after 10s (100 Hz):
	 * (now shorten to 2s, for convenience)
	 *
	 */
	Events::SimulationTick stopTick = /*10 */ 2 * 100 ;


	bool isBatch = false ;

	std::string executableName ;
	std::list<std::string> options ;

	Ceylan::parseCommandLineOptions( executableName, options, argc, argv ) ;

	std::string token ;
	bool tokenEaten ;


	while ( ! options.empty() )
	{

	  token = options.front() ;
	  options.pop_front() ;

	  tokenEaten = false ;

	  if ( token == "--batch" )
	  {

		LogPlug::info( "Batch mode selected" ) ;
		isBatch = true ;

		/*
		 * Will stop the scheduler after 1 second:
		 * (100 simulation ticks, since logic frequency is 100 Hz here)
		 *
		 */
		stopTick = 100 ;

		tokenEaten = true ;

	  }

	  if ( token == "--interactive" )
	  {
		LogPlug::info( "Interactive mode selected" ) ;

		// Relying thus on default durations.
		isBatch = false ;
		tokenEaten = true ;
	  }

	  if ( token == "--online" )
	  {

		// Ignored for this test.
		tokenEaten = true ;

	  }

	  if ( LogHolder::IsAKnownPlugOption( token ) )
	  {
		// Ignores log-related (argument-less) options.
		tokenEaten = true ;
	  }


	  if ( ! tokenEaten )
	  {
		throw Ceylan::CommandLineParseException(
		  "Unexpected command line argument: " + token ) ;
	  }

	}


	if ( ! Ceylan::System::areSubSecondSleepsAvailable() )
	{

	  LogPlug::info( "No subsecond sleep available, "
		"scheduler cannot run, test finished." ) ;

	  OSDL::stop() ;

	  OSDL::shutdown() ;

	  return Ceylan::ExitSuccess ;

	}



	LogPlug::info(
	  "Starting OSDL with video and, therefore, events enabled." ) ;

	OSDL::CommonModule & myOSDL = OSDL::getCommonModule(
	  CommonModule::UseVideo | CommonModule::UseEvents ) ;

	LogPlug::info( "Getting events module." ) ;
	EventsModule & myEvents = myOSDL.getEventsModule() ;

	LogPlug::info( EventsModule::DescribeEnvironmentVariables() ) ;

	LogPlug::info( "Displaying a dummy window "
	  "to have access to an event queue." ) ;

	LogPlug::info( "Getting video." ) ;
	OSDL::Video::VideoModule & myVideo = myOSDL.getVideoModule() ;

	// A SDL window is needed to have the SDL event system working:
	myVideo.setMode( 640, 480, VideoModule::UseCurrentColorDepth,
	  VideoModule::SoftwareSurface ) ;


	LogPlug::info( "Asking for a scheduler to be used." ) ;
	myEvents.useScheduler() ;

	// Uncomment to test with classical logs:
	//Scheduler::GetScheduler().setScreenshotMode( /* on */ true,
	//  /* frameFilenamePrefix */ "testOSDLScheduler" ) ;

	LogPlug::info( "Creating an active object whose role is "
	  "to stop the scheduler at simulation tick "
	  + Ceylan::toString( stopTick ) + "." ) ;




	/*
	 * A bit of testing for a programmed object with a tick list:
	 * (ownership not taken)
	 *
	 */
	SimulationTickList firstList ;
	firstList.push_back( stopTick / 4 );
	firstList.push_back( stopTick / 2 ) ;
	firstList.push_back( stopTick ) ;
	firstList.push_back( 2 * stopTick ) ;


	bool testKilledStopper = true ;
	//bool testKilledStopper = false ;

	if ( testKilledStopper )
	{

	  // Will be killed just before being able to stop the scheduler:
	  SchedulerStopper * toKillStopper = new SchedulerStopper( firstList,
		stopTick/2, /* verbose */ true ) ;

	  // Just-in-time (anonymous) killer of the previous stopper:
	  new ActiveObjectKiller( stopTick/2 - 1, *toKillStopper,
		/* verbose */ true ) ;

	}


	bool testSameTickDeletionOfProgrammed = true ;
	//bool testSameTickDeletionOfProgrammed = false ;

	if ( testSameTickDeletionOfProgrammed )
	{

	  /*
	   * Here we define A, B and C, (three programmed actors, with the
	   * stopTick/2 tick in common) knowing than B is expected to remove A and
	   * C, which are by design programmed at the same tick, just before and
	   * just after.
	   *
	   * This is the worst case scenario, one of the two would have been
	   * scheduled just after B, hence the removal is tested when iterating in
	   * the same list.
	   *
	   */
	  SchedulerStopper * stopperA = new SchedulerStopper( firstList,
		/* stop tick */ 1000, /* verbose */ true ) ;

	  // Will hit at the second tick of the list (i.e. stopTick/2):
	  ActiveObjectProgrammedSerialKiller * killerB =
		new ActiveObjectProgrammedSerialKiller(
		  stopTick/2, /* verbose */ true ) ;

	  SchedulerStopper * stopperC = new SchedulerStopper( firstList,
		/* stop tick */ 1000, /* verbose */ true ) ;

	  /*
	   * Thus both stoppers (A and C) will be killed (by B) at stopTick/2,
	   * i.e. before they have a chance of stopping the scheduler.
	   */
	  killerB->addTarget( *stopperA ) ;
	  killerB->addTarget( *stopperC ) ;

	}


	bool enableActualStopper = true ;

	SchedulerStopper * actualStopper = 0 ;

	if ( enableActualStopper )
	{

	  SimulationTickList secondList ;
	  secondList.push_back( stopTick / 3 );
	  secondList.push_back( stopTick ) ;
	  secondList.push_back( 3 * stopTick ) ;

	  // So the actual (and only) stopper of the scheduler will be this one:
	  actualStopper = new SchedulerStopper( secondList, stopTick,
		/* verbose */ true ) ;

	}



	bool testPacer = true ;
	//bool testPacer = false ;

	SchedulerPacer * pacerLeftBehind = 0 ;

	if ( testPacer )
	{

	  // A pacer:
	  new SchedulerPacer( /* period */ 3, /* activation count */ 20,
		/* verbose */ true ) ;


	  // Another one (will never be removed):
	  LogPlug::warning( "The warning about an object of period 7 not being "
		"unregistered (see below) is perfectly normal for this test." ) ;

	  pacerLeftBehind = new SchedulerPacer( /* period */ 7,
		/* activation count */ 3000, /* verbose */ true ) ;

	}



	bool testSameTickDeletionOfPeriodical = true ;
	//bool testSameTickDeletionOfPeriodical = false ;

	if ( testSameTickDeletionOfPeriodical )
	{

	  /*
	   * Here we define D, E and F, (three periodical actors, with the same
	   * period, 5) knowing than E is expected to remove D and F, which are by
	   * design programmed at the same tick, just before and just after.
	   *
	   * This is the worst case scenario, one of the two would have been
	   * scheduled just after E, hence the removal is tested when iterating in
	   * the same list.
	   *
	   */
	  SchedulerPacer * pacerD = new SchedulerPacer( /* period */ 5,
		/* stop tick */ 1000, /* verbose */ true ) ;

	  // Will hit at tick 5*6 = 30:
	  ActiveObjectPeriodicalSerialKiller * killerE =
		new ActiveObjectPeriodicalSerialKiller(
		  /* period */ 5, /* period count */ 6, /* verbose */ true ) ;

	  SchedulerPacer * pacerF = new SchedulerPacer( /* period */ 5,
		/* stop tick */ 1000, /* verbose */ true ) ;

	  killerE->addTarget( *pacerD ) ;
	  killerE->addTarget( *pacerF ) ;

	}



	// A set of stopper active objects can be used as well:

	bool useStoppers = true ;
	//bool useStoppers = false ;

	list<SchedulerStopper *> stoppers ;

	if ( useStoppers )
	{

	  const Ceylan::Uint32 stoppersCount = 300 ;


	  // All these stoppers will arrive after the battle:
	  WhiteNoiseGenerator stopTickRand( 1, stoppersCount ) ;

	  for ( Ceylan::Uint32 i = 1; i < stoppersCount; i++ )
	  {

		// All stoppers will stop at simulation tick stopTick+1 or later:
		stoppers.push_back( new SchedulerStopper(
			stopTick + stopTickRand.getNewValue() ) ) ;

	  }

	}


	if ( ! isBatch )
	{

	  std::cout << std::endl
				<< "Warning: this test should last for exactly "
				<< stopTick / 100 << " seconds (and it is not interactive)."
				<< std::endl
				<< "Moreover it should preferably be run with the "
		"null log plug (i.e. with the --nullPlug command-line option), "
		"otherwise it may fail because of too slow synchronous disk writes."
				<< std::endl ;

	}


	LogPlug::info(
	  "Just before starting the scheduling, scheduler state is: "
	  + Scheduler::GetScheduler().toString() ) ;


	LogPlug::info( "Entering the schedule loop." ) ;
	myEvents.enterMainLoop() ;
	LogPlug::info( "Exit from schedule loop." ) ;

	if ( ! isBatch )
	{

	  std::cout << std::endl << "Scheduling finished" << std::endl ;

	}


	/*
	 * Deallocation summary:
	 *
	 *   - toKillStopper deleted by the anonymous killer
	 *
	 *   - this killer committed suicide once having murdered toKillStopper
	 *
	 *   - the (anonymous) actual stopper committed suicide once having
	 * stopped the scheduler
	 *
	 *   - any remaining (useless) stopper has to be removed
	 *
	 */
	if ( useStoppers )
	{

	  for ( list<SchedulerStopper *>::iterator it = stoppers.begin();
			it != stoppers.end(); it++ )
		delete (*it) ;

	}

	if ( actualStopper != 0 )
	{

	  delete actualStopper ;
	  actualStopper = 0 ;

	}

	delete pacerLeftBehind ;
	pacerLeftBehind = 0 ;

	LogPlug::info( "Stopping OSDL." ) ;

	OSDL::stop() ;

	LogPlug::info( "End of OSDL scheduler test." ) ;

  }

  catch ( const OSDL::Exception & e )
  {

	LogPlug::error( "OSDL exception caught: "
	  + e.toString( Ceylan::high ) ) ;
	return Ceylan::ExitFailure ;

  }

  catch ( const Ceylan::Exception & e )
  {

	LogPlug::error( "Ceylan exception caught: "
	  + e.toString( Ceylan::high ) ) ;
	return Ceylan::ExitFailure ;

  }

  catch ( const std::exception & e )
  {

	LogPlug::error( "Standard exception caught: "
	  + std::string( e.what() ) ) ;
	return Ceylan::ExitFailure ;

  }

  catch ( ... )
  {

	LogPlug::error( "Unknown exception caught" ) ;
	return Ceylan::ExitFailure ;

  }

  OSDL::shutdown() ;

  return Ceylan::ExitSuccess ;

}
