/* 
 * Copyright (C) 2003-2009 Olivier Boudeville
 *
 * This file is part of the OSDL library.
 *
 * The OSDL library is free software: you can redistribute it and/or modify
 * it under the terms of either the GNU Lesser General Public License or
 * the GNU General Public License, as they are published by the Free Software
 * Foundation, either version 3 of these Licenses, or (at your option) 
 * any later version.
 *
 * The OSDL library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License and the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License and of the GNU General Public License along with the OSDL library.
 * If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Olivier Boudeville (olivier.boudeville@esperide.com)
 *
 */


#include "OSDL.h"
using namespace OSDL ;
using namespace OSDL::Events ;
using namespace OSDL::Video ;
using namespace OSDL::Engine ;


using namespace Ceylan::Log ;
using namespace Ceylan::Maths ;
using namespace Ceylan::Maths::Random ;


#include <list>
using std::list ;





/**
 * Test of OSDL scheduler, in real-time (best-effort) mode.
 *
 * Some useful testing can be made during the two seconds this test 
 * should last, including running it with various machine loads to 
 * examine the skip behaviour.
 *
 * This test applies only to the scheduler on soft real-time (best effort) 
 * mode. It is not interactive though.
 *
 * @note If not in batch mode, this test should last for exactly 10 seconds.
 *
 * @see testOSDLSchedulerNoDeadline.cc for the batch (screenshot) version.
 *
 * @see plotIdleCallDurations.p to generate a plot from the idle-calls.dat
 * file that can be generated by the scheduler, so that the forecasted idle
 * call durations can be compared to the actual ones.
 *
 */
 
 
 
 
/**
 * The role of this object is to have the scheduler stop at a given 
 * simulation time. 
 *
 * @note A scheduler must already exist before any of these objects is created.
 *
 */
class SchedulerStopper: public OSDL::Engine::ProgrammedActiveObject
{

	public:
	
	
		SchedulerStopper( SimulationTick stopSimulationTick, 
				bool verbose = false ) :
			ProgrammedActiveObject( 
				stopSimulationTick, 
				/* absolutelyDefined */ true,
				/* autoregister */ true ),
			_stopTick( stopSimulationTick ),
			_verbose( verbose ) 
		{
			
			if ( _verbose )
				LogPlug::info( "SchedulerStopper constructor for "
					+ Ceylan::toString( this ) 
					+ ": will stop at simulation tick #"
					+ Ceylan::toString( _stopTick ) + "."  ) ;
			
		}


		~SchedulerStopper() throw()
		{
		
			if ( _verbose )
				LogPlug::info( "SchedulerStopper deleted." ) ;
			
		}
		
				
		
		virtual void onActivation( Events::SimulationTick newTick )
		{
		
			if ( _verbose )
				LogPlug::info( "SchedulerStopper::onActivation: "
					"activated for simulation tick "
					+ Ceylan::toString( newTick ) + "." ) ;
			
			if ( newTick == _stopTick )
			{	
			
				LogPlug::info( "SchedulerStopper::onActivation: "
					"unregistering from scheduler." ) ;
				unregisterFromScheduler() ;
				
				LogPlug::info( "SchedulerStopper::onActivation: "
					"stopping scheduler." ) ;
				Scheduler::GetExistingScheduler().stop() ;
				
				// Once its mission has been done, self-removes:
				delete this ;
				
			}	
			
		}
		
		
		virtual void onSkip( Events::SimulationTick newTick )
		{
		
			LogPlug::warning( "SchedulerStopper::onSkip: the simulation tick "
				+ Ceylan::toString( newTick ) + " had been skipped!" ) ;
				
			// Thus will always be called, regardless of skips:	
			onActivation( newTick ) ;
			
		}
		
		
		
	private:
	
		SimulationTick _stopTick ;
		bool _verbose ;
		
} ;




/**
 * The role of this object is to kill (remove from scheduling and delete)
 * an active object. 
 *
 * @note A scheduler must already exist before any of these objects is created.
 *
 */
class ProgrammedObjectKiller: public OSDL::Engine::ProgrammedActiveObject
{

	public:
	
	
		ProgrammedObjectKiller( SimulationTick killSimulationTick, 
			ActiveObject & toKill, bool verbose = false ) :
			ProgrammedActiveObject( 
				killSimulationTick, 
				/* absolutelyDefined */ true,
				/* autoregister */ true ),
			_killTick( killSimulationTick ),
			_target( & toKill ),
			_verbose( verbose ) 
		{
			
			if ( _verbose )
				LogPlug::info( "ProgrammedObjectKiller constructor for "
					+ Ceylan::toString( this ) + ": will kill '"
					+ _target->toString() + "' at simulation tick #" 
					+ Ceylan::toString( _killTick ) + "."  ) ;
			
		}


		~ProgrammedObjectKiller() throw()
		{
		
			if ( _verbose )
				LogPlug::info( "ProgrammedObjectKiller deleted." ) ;
			
		}
		
				
		
		virtual void onActivation( Events::SimulationTick newTick )
		{
		
			if ( _verbose )
				LogPlug::info( "ProgrammedObjectKiller::onActivation: "
					"activated for simulation tick "
					+ Ceylan::toString( newTick ) + "." ) ;
			
			if ( newTick == _killTick )
			{	
			
				LogPlug::info( "ProgrammedObjectKiller::onActivation: "
					"killing target." ) ;
				_target->unregisterFromScheduler() ;
				delete _target ;
				
				// Once its mission has been done, self-removes:
				delete this ;	
				
			}
						
		}
		
		
		virtual void onSkip( Events::SimulationTick newTick )
		{
		
			LogPlug::warning( 
				"ProgrammedObjectKiller::onSkip: the simulation tick "
				+ Ceylan::toString( newTick ) + " had been skipped!" ) ;
				
			// Thus will always be called, regardless of skips:	
			onActivation( newTick ) ;
			
		}
		
		
		
	private:
	
		SimulationTick _killTick ;
		
		ActiveObject * _target ;
		
		bool _verbose ;
		
} ;




/**
 * Testing the services of the OSDL scheduler for active objects, in
 * real-time mode.
 *
 * @see ActiveObject
 *
 */
int main( int argc, char * argv[] ) 
{


	LogHolder myLog( argc, argv ) ;
	
	
    try 
	{

		
		LogPlug::info( "Testing OSDL scheduler services in real-time mode." ) ;

		// Tells when the test will stop, by default after 10s (100 Hz):
		Events::SimulationTick stopTick = /*10 */ 2 * 100 ;
	
	
		bool isBatch = false ;
		
		std::string executableName ;
		std::list<std::string> options ;
		
		Ceylan::parseCommandLineOptions( executableName, options, argc, argv ) ;
		
		std::string token ;
		bool tokenEaten ;
		
		
		while ( ! options.empty() )
		{
		
			token = options.front() ;
			options.pop_front() ;

			tokenEaten = false ;
						
			if ( token == "--batch" )
			{
			
				LogPlug::info( "Batch mode selected" ) ;
				isBatch = true ;
				
				/*
				 * Will stop the scheduler after 1 second: 
				 * (100 simulation ticks, since logic frequency is 100 Hz here)
				 *
				 */
				stopTick = 100 ;
				
				tokenEaten = true ;
			}
			
			if ( token == "--interactive" )
			{
				LogPlug::info( "Interactive mode selected" ) ;
				isBatch = false ;
				tokenEaten = true ;
			}
			
			if ( token == "--online" )
			{
			
				// Ignored for this test.
				tokenEaten = true ;
				
			}
			
			if ( LogHolder::IsAKnownPlugOption( token ) )
			{
				// Ignores log-related (argument-less) options.
				tokenEaten = true ;
			}
			
			
			if ( ! tokenEaten )
			{
				throw Ceylan::CommandLineParseException( 
					"Unexpected command line argument: " + token ) ;
			}
		
		}
		

		if ( ! Ceylan::System::areSubSecondSleepsAvailable() )
		{
		
			LogPlug::info( "No subsecond sleep available, "
				"scheduler cannot run, test finished." ) ;
			
			return Ceylan::ExitSuccess ;				
			
		}
		
		
			
		LogPlug::info( 
			"Starting OSDL with video and, therefore, events enabled." ) ;
					
        OSDL::CommonModule & myOSDL = OSDL::getCommonModule(
			CommonModule::UseVideo | CommonModule::UseEvents ) ;		
		
		LogPlug::info( "Getting events module." ) ;
		EventsModule & myEvents = myOSDL.getEventsModule() ; 

		LogPlug::info( EventsModule::DescribeEnvironmentVariables() ) ;
				
		LogPlug::info( "Displaying a dummy window "
			"to have access to an event queue." ) ;
			
		LogPlug::info( "Getting video." ) ;
		OSDL::Video::VideoModule & myVideo = myOSDL.getVideoModule() ; 
		
		// A SDL window is needed to have the SDL event system working:
		myVideo.setMode( 640, 480, VideoModule::UseCurrentColorDepth, 
			VideoModule::SoftwareSurface ) ;

		
		LogPlug::info( "Asking for a scheduler to be used." ) ;
		myEvents.useScheduler() ;
				
		LogPlug::info( "Creating an active object whose role is "
			"to stop the scheduler at simulation tick " 
			+ Ceylan::toString( stopTick ) + "." ) ;

		// Will be killed just before being able to stop the scheduler:
		SchedulerStopper * toKillStopper = new SchedulerStopper( 
			stopTick/2, /* verbose */ true ) ;
		
		// Just-in-time (anonymous) killer:
		new ProgrammedObjectKiller(
			stopTick/2 - 1, *toKillStopper, /* verbose */ false ) ;
			
		// So the actual stopper will be this one:	
		new SchedulerStopper( stopTick, /* verbose */ false ) ;
			
		// A set of stopper active objects can be used:
				
		bool useStoppers = true ;
		
		const Ceylan::Uint32 stoppersCount = 300 ;
		
		list<SchedulerStopper *> stoppers ;

	
		if ( useStoppers )
		{
			
			// All these stoppers will arrive after the battle:
			WhiteNoiseGenerator stopTickRand( 1, stoppersCount ) ;
				
			for ( Ceylan::Uint32 i = 1; i < stoppersCount; i++ )
			{
		
				// All stoppers will stop at simulation tick stopTick or later:
				stoppers.push_back( new SchedulerStopper( 
					stopTick + stopTickRand.getNewValue() ) ) ;	
					
			}
		
		}

		if ( ! isBatch )
		{
		
			std::cout << std::endl
				<< "Warning: this test should last for exactly "
				<< stopTick / 100 << " seconds (and it is not interactive)" 
				<< std::endl ;
						
		}
							
		LogPlug::info( "Entering the schedule loop." ) ;
		myEvents.enterMainLoop() ;
		LogPlug::info( "Exit from schedule loop." ) ;		

		if ( ! isBatch )
		{
		
			std::cout << std::endl << "Scheduling finished" << std::endl ;
						
		}
		
		
		/*
		 * Deallocation summary:
		 *   - toKillStopper deleted by the anonymous killer
		 *   - this killer committed suicide once having murdered toKillStopper
		 *   - the (anonymous) actual stopper committed suicide once having
		 * stopped the scheduler
		 *   - any remaining (useless) stopper has to be removed
		 *
		 */
		for ( list<SchedulerStopper *>::iterator it = stoppers.begin(); 
				it != stoppers.end(); it++ ) 
			delete (*it) ;
					
		LogPlug::info( "Stopping OSDL." ) ;		
		
        OSDL::stop() ;
		
		LogPlug::info( "End of OSDL scheduler test." ) ;

   }
	
    catch ( const OSDL::Exception & e )
    {
	
        LogPlug::error( "OSDL exception caught: "
        	 + e.toString( Ceylan::high ) ) ;
       	return Ceylan::ExitFailure ;

    }

    catch ( const Ceylan::Exception & e )
    {
	
        LogPlug::error( "Ceylan exception caught: "
        	 + e.toString( Ceylan::high ) ) ;
       	return Ceylan::ExitFailure ;

    }

    catch ( const std::exception & e )
    {
	
        LogPlug::error( "Standard exception caught: " 
			 + std::string( e.what() ) ) ;
       	return Ceylan::ExitFailure ;

    }

    catch ( ... )
    {
	
        LogPlug::error( "Unknown exception caught" ) ;
       	return Ceylan::ExitFailure ;

    }

    return Ceylan::ExitSuccess ;

}

